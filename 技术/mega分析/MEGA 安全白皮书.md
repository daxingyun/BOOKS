# MEGA 安全白皮书
## 1 引言
超过 1.5 亿注册用户依靠 MEGA 作为其安全文件存储和协作平台。  MEGA 在 2013 年通过网络浏览器率先开发了用户控制的端到端加密。在本白皮书中，我们将详细介绍构建 MEGA 的安全原则，其技术实现及其背后的原理。
### 1.1 什么是 MEGA ？
MEGA 是一个安全的云存储和通信平台，具有用户控制的端到端加密（E2EE）。端到端加密意味着没有中介（甚至 MEGA）也无法访问用户的加密密钥，因此也无法读取存储数据。但是，用户可以选择共享数据（单个文件或整个文件夹），以及其他相关的加密密钥。

MEGA 是目前唯一支持浏览器访问端到端加密的云存储提供商。这降低了准入门槛，并支持大规模采用加密。除了其复杂的 Web 界面外，MEGA 还为所有主要操作系统提供了同步应用程序（Windows，macOS和Linux）实时将本地文件夹中的数据与用户的云同步。MEGA 也提供移动应用程序，可在旅途中进行文件访问，相机上传和通信。MEGA 的通讯套件支持与单个用户或组进行文本聊天和音/视频通话，并且与所有加密存储功能紧密集成，在两者之间提供了独特的交叉点，在聊天中安全地共享和都非常容易引用存储中的数据。
### 1.2 端到端加密
与大多数云存储提供商不同，只有用户可以控制谁有权访问其数据。 从一开始 MEGA 围绕用户控制的端到端加密而设计。 这意味着文件，消息和音/视频内容在传输到 MEGA 平台之前，已在用户的客户端计算机上进行了加密。只有用户持有其数据的加密密钥，MEGA 甚至无法访问它。 如果用户希望与其他用户共享数据，会先使用收件人的公钥对所需的文件的加密密钥进行加密，然后传送它们。 为了确保接收者的身份，可以通过独立渠道。 任何更改都会触发警报，从而消除了通过验证后中间人攻击的冒名顶替的风险。
### 1.3 源代码透明度
与用户数据安全性相关的所有加密操作都由用户在自己的设备上完成。 MEGA 通过发布所有客户端、应用程序完整、最新的的源代码信息提供给用户。 这使所有感兴趣的第三方可以独立验证 MEGA 的安全性是否正确，代码是否正确，以及是否有后门或意外漏洞。 允许用户将源代码用于研究目的并构建源代码。客户端应用直接来自源：

- [mega.nz](https://mega.nz/sourcecode)
- [github](https://github.com/meganz)

### 1.4 隐私权
与大多数竞争对手相比，MEGA 通过设计适当的 E2EE 流程，获得了实际的隐私仅，并根据政策提供隐私的人。 尽管所有通信和文件都是用户加密的，并且无法通过 MEGA 或任何其他第三方查看，(除非密钥是自愿共享的），但 MEGA 会存储各种其他类型的交易和元数据（例如用户的电子邮件地址和IP地址等），（根据政策适用于隐私）。此数据的存储严格用于操作和合规性目的。 MEGA 不执行任何有关此类数据的其他处理活动。 有关完整信息，另请参见

- [隐私权](https://mega.nz/privacy)

### 1.5漏洞管理
为了确保 MEGA 的持续安全，MEGA 会向举报未知的与安全性相关的错误或设计缺陷的任何人提供奖励。合格类别为：

- 远程服务器端代码执行（包括SQL注入）；
- 远程客户端代码执行（例如，通过XSS在浏览器中）；
- 任何破坏密码安全模型，允许未经授权的远程访问或操纵的问题键或数据的格式；
- 任何绕过访问控制的问题，允许未经授权覆盖/销毁密钥或用户数据;
- 如果关联的电子邮件地址，则任何有损帐户数据机密性的妥协问题。

MEGA 为每个漏洞提供最高 10,000 欧元的费用，具体取决于其严重性。MEGA 已为 2013 年至 2019 年之间报告的一些小漏洞共支付了 20,000 欧元。但是，MEGA 自2013年2月以来开放的蛮力挑战尚未对外宣布，并且可能永远不会。

可以将您的发现提交至 security@mega.nz
有关更多信息，请参见：https://mega.nz/blog_6

### 1.6数据冗余
MEGA 的端到端加密，使其区别于云存储主流，但数据保护并非如此就足够了。基础架构的可靠性，以及对硬件故障和人为错误的恢复能力也是重要注意事项。

MEGA 直接拥有并控制其服务器基础架构，并且不依赖任何第三方 VPS 提供商，这在 CPU 侧通道攻击（“ Spectre”）时代很有用。所有硬件都托管在安全的设施中,数据在欧洲委员会确定的欧洲或其他国家/地区（例如新西兰和加拿大）根据 GDPR 第45条获得充分的保护。没有用户文件存储或制作可被美国获得。MEGA 具有各种基础架构，每种基础架构都有自己的冗余和数据完整性保护机制：

- 主要后端基础架构:(API，数据库集群等)

	这些服务器拥有所有的加密密钥，加密的文件元数据和个人用户数据。用户帐户中的任何操作都通过 API，并存储在 MEGA 的一个数据库集群中。

	- 所有数据库集群在各个地理区域都具有实时和延迟的从属复制位置并具有各种异地备份机制。主要基础架构存储在卢森堡最先进的 Tier IV 数据中心。
	- API 基础结构的代码更新（允许 MEGA 客户端与数据库集群“对话”）是通过严格的过程完成的，并通过不同的密钥对各个级别的代码进行了审查 MEGA 的工作人员保护数据库集群的完整性。
- 文件存储基础结构

	这些服务器存储所有加密的用户数据。MEGA 有 200 多个PB级的存储容量，目前已存储了超过 680 亿个文件。

	- 所有存储服务器均使用标准 RAID 级别6。多个硬盘驱动器可能会发生故障，而不会影响数据的可用性。快速更换发生故障的硬盘驱动器，以最大程度地减少多个硬盘的风险并发故障。
	- 此外，MEGA 还存储分布在多个地理位置的用户数据，以保护以应对更多不可控的灾难（例如，多个硬盘驱动器同时发生故障，或者破坏整个服务器或数据中心）。我们将这种安排称为 CloudRAID，表示“冗余独立数据中心阵列”。即使整个数据中心不可用，用户数据仍然可访问。
- 文件元数据基础结构

	这些服务器存储文件的所有用户生成和加密的属性存储在 MEGA 上，例如图像，视频和文档的缩略图。这些服务器是实时复制的跨多个地理位置

### 1.7 合规
MEGA 的设计和运行旨在确保其达到最高的法规合规性要求。MEGA 的服务受新西兰法律管辖，并且用户仅服从于新西兰仲裁争端解析。 MEGA 已就其服务向新西兰和其他地区(其他司法管辖区，包括美国)的律师寻求广泛的法律建议，以最大程度地减少不遵守法规的风险它提供服务的主要司法管辖区的要求。MEGA 保持市场领先的处理与上载和共享侵犯版权等重大或违反任何其他法律要求的流程。 

MEGA 无法查看或确定所存储文件的内容，因为文件在到达 MEGA 之前已由用户加密。但是，如果用户自愿共享链接到他们存储的文件（带有解密密钥），那么具有该链接的任何人都可以解密和查看该文件内容。 MEGA 的服务条款规定，版权所有者必须了解与其链接的公共链接版权材料可以与MEGA 联系以禁用违规链接。

在实施其下架通知政策和流程时，MEGA 开始与新西兰执法部门进行讨论。 MEGA 已采纳了建议的政策和流程。符合他们的要求。

美国数字千年版权法案（DMCA）流程，欧盟指令  2000/31/EC 和新西兰的《版权法》第92B条为 MEGA 提供了安全的条款，使 MEGA 免受对用户使用 MEGA 的服务上传和共享的材料。 MEGA 符合以下条件通过允许任何人提交其版权材料的通知来提说明公共链接是侵权行为。 

MEGA 收到此类通知后，会立即将其删除或根据要求的类型（与条款一致），禁止访问有问题的文件。每个注册用户都同意的服务条款。已被删除的文件数通知的数量仍然非常少，表明用户群体对它的速度和灵活性有所了解 MEGA 的系统，用于合法的商业和个人使用。 DMCA 需要快速删除链接。多数云提供商将取消目标定在 24 小时。 MEGA 的目标是在最多 4 个小时内进行下架，很多情况更快。

MEGA 定期发布有关其合规活动的统计信息，以使公众确信该服务它提供的是合法的，并且以保护用户权利的方式进行操作。

最新的透明度报告可以在这里找到：

[合规信息统计](https://mega.nz/Mega_Transparency_Report_201909.pdf)

## 2 客户端应用安全
### 2.1 浏览器中的密码学
当 MEGA 在2013年向公众介绍基于浏览器的加密技术时，引起了一些争议。批评的三个要点是：

- A 传输层路径安全

	著名密码学家 Moxie Marlinspike 告诉《福布斯》，“如果能打破 SSL，则可以破坏 MEGA”；
- B 本地安全

	每次现场访问时都重新加载代码，从而可以通过后门获取；
- C 游览器安全

	有关浏览器环境的担忧，例如缺乏加密功能强大的伪随机数生成器，侧通道攻击以及通过远程执行跨站脚本代码的风险。

尽管这些担忧都可以成立，但传统的选择绝不是更好。正在下载加密应用程序的二进制文件，同样也取决于传输路径的安全性-“如果可以破坏 SSL，可以将后门二进制 pgp.exe 插入 ”。有目标的后门可以在用户访问供应商站点或使用内置的自动更新时，下载并安装后们应用程序二进制文件。

很少有用户能够在信任前执行全面的代码审查前-不论是否为源代码、预编译二进制文件还是 JavaScript。现代浏览器具有加密 API，API 具有本机代码可以实现的任何功能。远程执行代码由于引入了内容安全策略，几乎已成为不可能。而且，除了加密方面，浏览器还可以充当安全沙盒（假设没有已知的未修补漏洞）保护受害者的系统不受恶意代码的侵害，将损害限制在最低水平。这比无意中运行后门二进制文件所造成的潜在损害要好多了。

认为加载 `https://mega.nz/` 时,导致后门注入的用户，可以选择 MEGA 的浏览器扩展的安装。该扩展在本地运行代码并支持密码签名更新（尽管用户必须对此进行完整的代码审查才能真正安全）。

毫无疑问，当用户可以通过访问网络URL访问应用程序，可以充分的降低准入门槛，而不是必须首先下载和安装二进制文件。因此，MEGA 比 PGP 晚 20 年但活跃用户比 PGP 多得多毫不奇怪。

### 2.2 浏览器扩展
MEGA 将桌面网络客户端构建为针对 Firefox，Chrome、Chromium 的三个单独的浏览器扩展以及用于 Palemoon 的旧版 Firefox 扩展。扩展包含所有 JavaScript，HTML和CSS文件，这意味着可执行的客户端代码直接从用户的本地计算机运行，而不是从 MEGA 通过 SSL 在运行时加载（更多信息，请参见8.3中的内容）。扩展可以从 `https://mega.nz/extensions` 下载 。浏览器扩展自动更新受到密码保护。更新机制是浏览器的一部分，可以关闭。 

Firefox 扩展是加密方式使用 Mozilla 提供的密钥签名，并直接从 MEGA 的基础架构提供服务。

将扩展程序更新加载到 Chrome 扩展程序更新后，Google 会对其进行加密签名 Chrome 网上应用店。用于将扩展程序加载到商店中的 Google 帐户具有很强的独特性密码和两因素身份验证。当然，当用户确实需要信任 Google，使用 Chrome 扩展程序，或使用 Firefox 扩展程序时使用 Mozilla。希望从本地计算机使用 MEGA Web 客户端而不必依赖浏览器的用户扩展可以通过克隆 Webclient 存储库并从本地 Web 服务器运行它来实现：

[http://www.github.com/meganz/webclient](http://www.github.com/meganz/webclient)
### 2.3 安全启动（webclient 的运行时通过 https://mega.nz/）
主要的核心网络客户端文件（index.html 和 secureboot.js）是通过 SSL 从根网络群集中传递，通过 MEGA 的主域加载时，这是网络客户端安全性的根（https://mega.nz/）。通过 MEGA 的主域加载网络客户端的用户，在运行时通过SSL时，需要信任所提供的网络客户端代码库。这是用户通过浏览器访问 MEGA 的便捷选项，而无需安装任何东西（对于首次使用的用户特别方便），与使用浏览器扩展程序或本机应用程序相比确实降低了安全性。由于在运行时对 SSL 的内在依赖，因此级别较高。

为了在上述降低的安全级别下，最小化潜在的攻击媒介，验证静态服务器提供的可执行文件，以便仅根 Web 群集（https://mega.nz）必须得到信任。 MEGA 在不同地理位置运行多个静态集群以提供 JavaScript 服务和其他客户端文件，以确保 Web 客户端能够尽快加载给用户。

在构建 Webclient 版本时，JavaScript，HTML 和通过 https://mega.nz/secureboot.js 加载的 CSS 文件使用 SHA-256 进行哈希处理，文件名以十六进制表示。 secureboot.js 文件包含所有有效列表静态文件及其哈希摘要在相应的文件名中。每个文件都是从静态集群加载的哈希，在 secureboot.js 中将计算的哈希摘要与预先加载的有效哈希摘要进行比较，任何失败都意味着网站将无法加载，并且将向用户显示错误。这个流程早于 Subresource Integrity（SRI）Web API，但实际上非常相似。字体和图像由于使用图片或字体作为合理的攻击媒介具有很高的理论性（并且仍然需要攻击者实际破坏我们的任何静态群集）。

这同样适用于在移动浏览器中使用 MEGA 的用户，但移动浏览器不允许扩展程序，推荐使用 MEGA 的移动应用程序来增强安全性。
### 2.4 安卓
从 Google Play 商店下载并安装 MEGA 的 Android 应用程序包（APK）。安装文件和更新均由 MEGA 和 Google 加密签名。毫无疑问，安装时用户必须需要信任 Android 操作系统和 Google Play 商店平台和 Google Play 商店中的 APK。

希望在不依赖 Google Play 商店的情况下使用 MEGA Android 应用的用户，可以通过克隆 MEGA Android 存储库并直接从源代码构建自己的 MEGA Android 客户端

	https://github.com/meganz/android
### 2.5 iOS
从 Apple App Store 下载并安装 MEGA 的 iOS 应用程序档案（IPA）。安装文件和更新均由 MEGA 和 Apple 加密签名。毫无疑问从 Apple App Store 安装 IPA 时，用户确实需要信任 iOS 操作系统和 Apple App Store 平台。

希望在不依赖 Apple App Store 的情况下使用 MEGA iOS 应用程序的用户，可以通过克隆 MEGA iOS 存储库并直接从源代码构建自己的 MEGA iOS 客户端：

	https://github.com/meganz/ios
但是，这确实需要 Apple 开发人员证书或越狱的 iOS 版本。如果是后者，请确保您所在的司法管辖区允许iOS越狱：

	https://zh.wikipedia.org/wiki/IOS_jailbreaking#Legal_status

### 2.6 MEGAsync
对于 Windows 和 macOS 用户，我们提供了通过 MEGA 的安全根服务器提供的初始安装二进制文件使用 SSL 加密和认证。 

- Windows 

	安装程序使用扩展验证（EV）签名 GlobalSign 的代码签名证书。 
- macOS 

	安装程序已使用 Apple 发行的证书签名。随后的更新将通过使用以下方法的安全密码更新机制自动安装：SHA-256 和由 MEGA 控制的 4096位RSA密钥。这些自动更新可以由用户关闭（尽管建议始终使用最新版本以提高稳定性和安全性）。
- Linux

	提供了存储二进制文件并提供更新的存储库。储存库还提供一个公共可用于检查所提供软件包的真实性和完整性的密钥。为了做到这一点，MEGA Linux 存储库还包括描述存储库和文件内容的标准化元数据指纹。因此，用户可以依靠 MEGA 软件包的完整性。更新是由系统的包管理器，用于验证存储库中的内容是否已由 MEGA 正确签名并且没有被篡改。用户可以通过将我们的公钥添加到他们的存储库来手动配置我们的存储库到客户的受信任列表或者在安装 MEGAsync 软件包后自动生成。我们提供公钥和通过 SSL 保护安装包以确保其真实性。

希望直接从源代码构建 MEGAsync 的用户，可以通过克隆和关注来实现该存储库中的说明

	https://github.com/meganz/megasync

### 2.7 MEGAcmd
对于 Windows 和 macOS 用户，我们提供了通过 MEGA 的安全根提供的初始安装二进制文件使用 SSL 加密和认证的服务器。在 Linux（MEGAcmd 主要目标平台）上，我们在 MEGAsync 中提到的存储库。因此，适用相同的安全机制。目前，我们不提供 Windows 或 macOS 的自动 MEGAcmd 更新。这些更新必须通过重新安装从 MEGA 受 SSL 保护的根目录下载的新二进制文件来手动安装。

希望直接从源代码构建 MEGAcmd 的用户可以通过克隆和关注来实现该存储库中的说明

	https://github.com/meganz/megacmd
### 2.8 端点(设备)安全
与许多人相比，MEGA 的 E2EE 范例确实通过设计提高了隐私的整体安全性,但与许多仅根据政策提供隐私的竞争对手相比，这并不是解决所有潜在安全问题威胁的灵丹妙药。 毫无疑问，在 E2EE 范例中, 默认为端点是安全设备。 端点设备上的任何破坏都会破坏E2EE链。 例如，用户终端设备或操作系统上的后门或病毒可能会允许流氓攻击者拦截未加密的数据。日志键位记录或直接从设备的麦克风/相机捕获音频/视频。 

因此，重要的是用户不仅仅依赖于 MEGA，而且还确保了用户在其上运行 MEGA 的端点设备客户端软件是安全的。 MEGA 不会直接保护端点设备。 MEGA 建议使用设备级加密和针对恶意软件和物理设备安全性的一般最佳实践。
## 3 用户注册与登录
记号和符号说明

- || = 串联
- ⊕ = 异或按位运算	

### 3.1 注册流程
注册和登录过程的安全性紧密基于研究论文“保护方法 Web 应用程序数据库中的密码" 。

重要的是要注意，所有与 API 的通信都是通过 TLS 完成的。如果可能，API 服务器的 TLS 公钥固定在客户端中。

1. 在注册时，用户再次输入其 `电子邮件`，`密码`和再一次 `密码`。密码条目必须完全匹配，否则用户将无法继续。
- 在客户端和 API 端都限制了电子邮件地址最多不能超过190个字符（其原因将在后面说明）。
- 客户将允许使用最小长度为8个字符且最小长度为密码的注册，根据当前的 ZXCVBN 密码强度估算器库（v4.4.2）得分为1，该得分为密码介于0到4之间。
- 密码强度检查器库在密码上至少激活8个字符后才会激活。如果尚未输入8个字符，则应用程序会以红色文字显示“太短”键入字段旁边。这样就可以避免接受太短的密码，例如“€cc”但仍被评为1分（弱）。综上所述：

		Length < 8 Too short
		Score 0 and Length >= 8 Too weak
		Score 1 and Length >= 8 Weak
		Score 2 and Length >= 8 Medium
		Score 3 and Length >= 8 Good
		Score 4 and Length >= 8 Strong
- 对于密码处理功能(Password Processing Function-简称PPF），使用已建立的 PBKDF2 标准。 虽然这是它不是最新的，最好的或最先进的，而是众所周知且具有广泛的语言支持，尤其是在 WebCrypto API(重要的本机执行速度)。 对于 Web 客户端，当前没有可靠的 WebCrypto API 或对 Argon2（首选），Scrypt 等的 asmCrypto 库支持。有一个等效的 JavaScript 库，其性能太慢，以至于我们可能不得不降低处理成本因数（迭代-iterations 次数）相应地仍在中低端范围内有效移动设备，这会对安全性产生不利影响。
- 客户端使用客户端的本机 CSPRNG 生成128位（16字节）的随机 (`Master Key`)。例如，网络客户端使用 WebCrypto API 的 `Crypto.getRandomValues()`函0数。
- 对于密码处理功能，客户端还将生成 128 位的客户端随机值 (`Client Random Value`)。
- 对于 Salt，客户端将计算：		

		Salt = SHA-256( “mega.nz” || “Padding” || Client Random Value )

	字符串 "mega.nz" 和 "Padding" 的总长度将恰好为 200 个字符。 填充字符将为字母“ P”（大写），重复直到组合的字符串为 200 字符长度。 这有助于使所有盐的计算花费相同的计算时间来减少定时攻击。

	研究论文“保护Web应用程序数据库中密码的方法”建议包括用户标识符（在本例中为电子邮件）以及 Salt 计算中。 但是，对于 MEGA 电子邮件地址可能会被用户更改（在这种情况下，我们将需要重新进行密码处理功能的计算并在他们每次更改电子邮件时重新加密  Master Key）。 另外，电子邮件必须能够由后台根据用户的要求进行更改，但这会在用户使用 Salt 时，将其锁定在基于已被覆盖的旧电子邮件参数的计算和密码处理功能，从而不利于可用性
- 对于密码处理功能，迭代次数(Iterations)将设置为100,000。 该迭代次数设置为由于 MEGA 具有 iOS，Android 和 Windows，因此在中低端移动硬件设备上，应用程序和移动Web客户端具有合理的性能。
- 对于密码处理功能，派生密钥(Derived Key)的长度将设置为256位（32字节）
- 客户端将通过计算来创建派生密钥

		Derived Key = PBKDF2-HMAC-SHA-512( Password , Salt , Iterations , Length )
- 派生密钥（128位）的前半部分（从左开始）称为派生密钥 `Derived Encryption Key`，并且它会加密使用当前方法的主钥匙

		Encrypted Master Key = AES-ECB( Derived Encryption Key , Master Key )
- 派生密钥的后半部分（128位）用作派生身份验证密钥(` Derived Authentication Key`)，该密钥用于使用 API 获取敏感的数据(例如加密密钥，会话ID等)。
- 客户端现在将计算身份密钥hash(`Hashed Authentication Key`)

		Hashed Authentication Key = SHA-256( Derived Authentication Key )
	哈希认证密钥仅包含 SHA-256 输出的前128位，因此它减少了 API 上的存储空间量。
- 客户将通过发送以下内容向 API 注册帐户

		First Name
		Last Name
		Email
		Client Random Value (128 bits / 16 Bytes)
		Encrypted Master Key (128 bits / 16 Bytes)
		Hashed Authentication Key (128 bits / 16 Bytes)

	API 按原样存储所有这些信息。 请注意 Salt 不会发送到 API，因为它始终会被来自客户随机值的计算，原因将在后面说明。
- API 使用其本机 CSPRNG 生成一个随机的电子邮件确认令牌( `Email Confirmation Token` )（128位）并发送确认链接

		Confirm Link = “https://mega.nz/#confirm” || Base64UrlEncode( “ConfirmCodeV2” || Email ConfirmationToken || Email )
	Base64 URL 编码替换了两个非字母数字字符，因此可以在 URL 中工作（有关示例，请参见 `https://github.com/meganz/webclient/blob/master/nodedec.js#L491`）
- 单击电子邮件中的“确认链接”后，客户端将在 #confirm 令牌返回到可以对其进行解码的 API。 如果该 API 请求成功，则客户端将转到登录页面以再次登录，可以在其中预填充“电子邮件”字段，但是手动输入密码是必需的。 用户需要再次登录，以防他们在另一个浏览器中打开了链接
- 用户首次登录后，他们直接进入密钥生成步骤，其中以下密钥生成：
	- 2048位 RSA 密钥对（用于共享文件夹/文件/登陆 token 加密）
	- 256位的 Ed25519 密钥（用作用户指纹验证和签名的信任根）其他键。 该密钥对称为签名密钥
	- 256 位 Curve25519 密钥对（用于MEGAchat）

		私钥通过使用 AES-ECB 的 `Master Key` 进行加密，并由 API 存储。 MEGA 无法获取

### 3.2 登录流程
1. 用户必须在本地客户端界面中输入其电子邮件和密码
- 电子邮件已发送到 API。 如果电子邮件属于有效的用户帐户，则 API 将发回

		Salt (computed by SHA-256( “mega.nz” || “Padding” || Client Random Value )
- 如果在数据库中找不到电子邮件，则 API 将发送回

		Salt (computed by SHA-256( Email || “mega.nz” || “Padding” || Server Random Value )
	- Email，“ mega.nz”和“ Padding”这三个字段的字符串的长度总共为200个字符。填充字符 `Padding` 将大写字母“ P”，直到组合字符串长度为200个字符。
	- 电子邮件的最大长度为190个字符，否则将被拒绝。
	- 因为有效电子邮件和无效电子邮件的字符串均长度为200个字符，因此 SHA256 计算花费的时间相同，这可以防止计时攻击。
	- 服务器随机值 `Server Random Value`（128位）是由 CSPRNG 随机生成存储在 API 存储的静态字符串。每当电子邮件不在数据库中时，将使用此选项。这样可以防止垃圾邮件发件人枚举电子邮件以查找有效的电子邮件，并且每年更改一次。因为 Salt 通过对有效登录名和无效登录名使用哈希函数来计算，这可以防止计时攻击。
	- API 为此响应还引入了一个0到50毫秒的随机延迟。 50毫秒是搜索所有数据库记录和不找到结果的最长时间。通过模拟数据库响应的延迟，有助于防止攻击者发通过它判断电子邮件是否有效。
	- 从用户那里收到的电子邮件仅限于有效的电子邮件，最大为190个字符，超过会被请求被拒绝。这也可以防止 API 散列大量数据并防止 DOS 攻击。此请求也是受0-50毫秒速率限制的。
- 客户端现在可以使用以下方法计算派生密钥

		Derived Key = PBKDF2-HMAC-SHA-512( Password , Salt , Iterations , Length )
- 派生加密密钥是派生密钥的前半（128）位
- 使用身份验证密钥（即派生密钥的后半部分（128位）），客户端将向 API 发送以下信息：

		Email
		Authentication Key
- API 将计算以下内容

		Hashed Authentication Key = SHA-256( Authentication Key ) 
	- API 对照数据库中存储的密钥检查哈希认证密钥 `Hashed Authentication Key` 的前128位为用户。如果匹配，则认为用户已成功通过身份验证，因此 API 会将其发送回加密的主密钥 `Encrypted Master Key`，加密的 RSA 私钥 `Encrypted Private RSA Key`，加密的会话 ID `Encrypted Session ID` 等加密敏感数据，客户端就可以继续正常了。 
	- 该 API 不存储用户发送的未加密的身份验证密钥。它只存储哈希身份验证密钥 `HashedAuthentication Key`，用于防止“通过哈希”攻击（在数据库泄漏的情况下，攻击者只需传递 “哈希身份验证密钥” `Hashed Authentication Key` 就可以按照真实用户进行身份​​验证）。服务器始终对从客户端收到的身份验证密钥进行哈希处理，以防止出现这种情况攻击向量。
	- 如果哈希身份验证密钥 `Hashed Authentication Key` 与数据库中的结果不匹配，则 API 会以负面反应表明失败。 API 端通过使用 `Double HMAC` 避免了定时验证攻击（https://www.nccgroup.trust/us/about-us/newsroom-and-events/blog/2011/february/double-hmacverification/）。
- 登录正确后，服务器将返回加密的主密钥 `Encrypted Master Key`、加密的 RSA 密钥 ` Encrypted RSA Private Key`和加密的会话标识符` Encrypted Session Identifier`。
	- 客户端将使用派生加密密钥 `Derived Encryption Key` 解密加密主密钥 `Encrypted Master Key`。
	- 主密钥 `Master Key` 将用于解密 RSA 私钥 `RSA Private Key`。 
	- RSA 私钥 `RSA Private Key` 将用于解密加密会话标识符` Encrypted Session Identifier`。 
	- 会话标识`Session Identifier` 符是 API 在每个登录会话中生成的随机字符串（令牌），并用用户的 RSA 公钥 `RSA Public Key` 加密的 。
- 在所有后续 API 请求上，用户必须通过 TLS 发送其未加密的会话标识符与 API 的连接。 如果用户未发送正确的会话标识符或未解密正确地，他们将无法下载任何用户帐户数据，例如联系信息，加密的文件和文件属性。

### 3.3临时账户
临时帐户是尚未完全注册的试用帐户。 它们的局限性在于只能通过临时会话将文件存储在云中。 这是为了降低初学者门槛，并允许他们尝试 MEGA 而无需先创建完整帐户。 他们无法建立联系关系，共享文件，创建公共链接或与其他用户聊天。 当登陆尚未注册帐户完的用户将文件或文件夹上载到网站或从链接导入文件时，将创建一个临时 `Master Key`。 用户可以稍后通过以下方式升级到完整帐户完成完整的注册过程。	

### 3.4帐户恢复	
由于用户密码实际上是该用户帐户中所有客户端加密的根，因此忘记或丢失它会导致无法解密用户数据，这是高度破坏性的。因此，MEGA 允许并强烈建议用户导出“恢复密钥”（从技术上讲是其主密钥 `Master Key`）。

MEGA 客户端检测用户何时长时间未输入密码（例如，由于在登录时启用了“记住我”复选框），并提醒用户其重要性密码。此提醒对话框提示用户测试其密码和/或导出其恢复密钥。

MEGA具有方便的恢复界面，在密码丢失的情况下，新手用户可以根据自己的情况进行恢复：https：//mega.nz/recovery 

MEGA发现，忘记或丢失密码的用户通常仍在其他客户端上登录（例如 移动应用或 MEGAsync）。因此，MEGA 允许活动会话的用户无需证明当前密码的情况下更改密码。

如果用户没有其他可访问的活动会话，则用户可以使用恢复密钥（实际上是主钥匙 `Master Key`）以重置帐户密码。从技术上讲，用户将使用新密码。这样的过程需要电子邮件确认，因此仅访问恢复密钥不足以破坏账户。

### 3.5 两要素认证
MEGA 使用行业标准的基于时间的一次性密码（TOTP）方法实现了两要素认证（2FA）` Two Factor Authentication (2FA)`。 

	https://en.wikipedia.org/wiki/Time-based_One-time_Password_algorithm

共享机密生成使用32个随机字节。它将转换为基数32，并以 QR 码的形式显示给用户，以便轻松添加到 `Authenticator` 应用程序（例如Google Authenticator）中。 在用户激活其帐户上的 2FA 之前，他们需要根据共享密钥提供有效的6位代码。此时，将启用 2FA 并要求进行身份验证。

就我们的 2FA 实施而言，我们接受有效的代码作为当前代码，即+30秒或-90秒，以允许设备上的时钟漂移或用户花费时间输入它。

登录时，我们首先检查其现有的登录凭据是否匹配。

- 如果这些操作失败，我们不允许用户继续，客户端告知用户其电子邮件和密码组合不正确。
- 成功之后验证这些密码后，如果在其帐户上启用了2FA，则将提示用户输入其6位数代码。如果用户成功输入了有效的6位数代码，我们会将后端 API 服务器上使用的最后一个代码记录到防止对该帐户进行重放攻击。

跟踪失败的登录或 2FA 尝试总计两种类型的失败次数均达到阈值，我们将锁定该帐户以防止访问 MEGA服务一小时以防止 2FA 的强行使用。

此外，帐户中的许多活动，例如关闭2FA或更改帐户电子邮件，都是受到 2FA 保护，如果用户未提供有效且及时的代码，将拒绝用户。此处的失败也计入与登录流程相同的跟踪和锁定保护系统。

由于2FA仅用于身份验证，而不是用于加密数据，因此用户现有的恢复密钥仍可以用于在无法获得种子的2FA应用程序访问权限的情况下重新获得对帐户的访问权限已加载。

由于 2FA 仅用于身份验证，而不是用于加密数据，因此，如果用户无法访问已加载种子的 2FA 应用程序，则仍可以使用用户现有的恢复密钥重新获得对帐户的访问权限。 当用户启用2FA时，如果他们以前没有导出过恢复密钥，则需要这样做。否则，我们提醒用户保持它的重要性。

如果用户丢失了恢复密钥，MEGA员工可以禁用 2FA，如果用户提供足够的证据证明他们是帐户的真实所有者。 但是，这是严格控制的，需要高级工作人员的授权。

### 3.6 远程会话销毁
MEGA 客户端应用具有用户的完整会话历史记录以及 IP 和客户端信息，并且能够远程记录在特定会话或所有其他会话之外。例如，如果 MEGA 用户丢失了设备，则该用户可以远程销毁会话，以便物理设备丢失不会损害用户的 MEGA 帐户的安全性。可以通过以下 URL 在浏览器中查看会话历史记录：`https://mega.nz/fm/account/history`

请注意，如果非常老练的攻击者发现丢失的设备，则从理论上讲，攻击者可以获得任何设备上本地缓存的数据，例如用户的 `Master Key`。由于用户密码永远不会被缓存,仅 `Master Key` 不足以启动新的用户会话，因此远程会话销毁是在这种情况下仍然有用。如果不进行攻击，攻击者将无法从 MEGA 服务访问任何数据、密码，因此，即使使用 `Master Key`，攻击者仍将无法访问加密数据，除非他们还可以访问设备上用户的电子邮件，并使用 `Master Key` 重置密码。

为了增强对物理设备丢失情况的保护，MEGA 建议使用坚固的屏幕密码和设备级全盘加密（FDE），现在在新的 `Android/iOS` 上默认启用。
## 4 云盘加密
### 4.1 文件上传加密
每个数据（文件或文件夹）都有自己的加密密钥。文件夹未加密，因为它们不包含任何数据，仅包含文件夹属性（即文件夹名称、缩图、预览等）被加密。所有数据都存储在相同的平面数据库结构中，其中文件和文件夹具有父句柄，该父句柄引用它们所属的文件夹。根级别的文件夹/文件具有主云盘或垃圾箱作为其父句柄。

为了加密文件，将创建一个由 128 位随机数文件密钥和 64 位随机数 IV(nonce) 组成(随机数生成6组32位数字组成)的文件密钥对象 `File Key`。

将要明文文件分割为块，然后使用 `AES-CCM` 对每个文件块进行加密。

在所有块均已加密之后，从所有的块 MAC 计算出一个 `Condensed MAC`(压缩MAC)。

 `Condensed MAC` 流程

- 通过将一个 128 位数组初始化为0
- 然后按顺序使用第一个 MAC 进行异或，并使用 AES-ECB 加密
- 然后使用加密结果与第二个块进行，再加密，再循环
- 直到生成最终出来的 `Condensed MAC`

然后，对文件密钥( `File Key`)进行如下混淆：

	Obfuscated File Key = [
	 File Key[0] ⊕ IV[0],
	 File Key[1] ⊕ IV[1],
	 File Key[2] ⊕ Condensed MAC[0] ⊕ Condensed MAC[1],
	 File Key[3] ⊕ Condensed MAC[2] ⊕ Condensed MAC[3],
	 IV[0],
	 IV[1],
	 Condensed MAC[0] ⊕ Condensed MAC[1],
	 Condensed MAC[2] ⊕ Condensed MAC[3]
	];
然后，使用以下 `Master Key` 对混淆后文件密钥 ` Obfuscated File Key` 进行加密：
	
	Encrypted File Key = AES-ECB(Master Key, Obfuscated File Key)
然后将其上传到API。

### 4.2 文件属性，预览和缩略图加密
准备发送文件时，还需要将文件属性（例如文件名，缩略图，预览）设置为加密。 这些使用以下方法加密：

	AES-CBC(File Key, File Attribute Data)
## 5 安全的公共链接
### 5.1 公共文件链接
公开共享公共文件链接时，公共链接中将嵌入以下内容：

	https://mega.nz/file/Base64(File Handle)#!||Base64(Obfuscated File Key)
- 使用上面这些信息可以在服务器上找到由其文件句柄标识 `File Handle` 的文件
- 下载加密数据
- 验证整个文件的 `Condensed MAC`
- 取消混淆文件密钥 `File Key`
- 使用文件密钥对文件解密 `File Key` 和 `IV`。

请注意，URL中的锚点散列（＃）之后的所有内容都不会发送到 MEGA 服务器，而是保留在客户浏览器的本地
### 5.2 公用文件夹链接
- 用户创建共享文件夹
- 随机生成一个的共享密钥，共享密钥加密混淆密钥文件
	
		AES-ECB(Share Key, Obfuscated File Key)
- 在服务器上通过文件夹共享句柄 ` Folder Share Handle` 标识的共享文件夹中找到文件
- 下载其下的文件夹和文件数据
- 验证 `Condensed MAC` 
- 取消混淆文件密钥 ` File Keys`
- 使用文件密钥和解密文件 ` File Key` 和 `IV`

在一个公用文件夹链接被共享时，以下内容嵌入到公共链接中，注意这里共享密钥是明文的

	https://mega.nz/Base64(Folder Handle)#F!|| Base64( Share Key )

### 5.3 聊天链接
 当用户创建聊天链接时，统一聊天密钥 ` Unified Chat Key ` 会嵌入到公共链接中：

	[https://mega.nz/chat/ || Base64(Chat Handle) || # || Base64(Unified Chat Key)]
对于MEGA客户端来说，可以打开和解密所链接的特定聊天。 欲了解更多有关聊天链接的信息，请参阅第7.7节。
### 5.4 受密码保护的链接
此功能使用户可以使用密码对常规文件或文件夹链接密钥进行加密。后可以通过不安全的渠道（例如电子邮件或在公共网站) 上共享，而不会损害数据。但如果其他用户共享了数据密码，是不被管控的，行为取决于他们， 如果他们非常了解其他用户，他们也许可以根据他们共享的共同历史在他们之间构造一个共享的秘密。

该实现使用 `PBKDF2-HMAC-SHA512`，具有 100,000 轮运算和 一个 256 位随机( `slat` )盐以及用户的密码以获取一个 512 位的派生密钥(`Derived Key`)。

对于文件夹链接，密钥的长度为 128 位，对于文件链接，实际密钥的长度为 256 位。派生密钥(`Derived Key`)的前128或256位将用作加密密钥，使用一个简单的异或来加密实际的文件夹/文件密钥。

派生密钥(`Derived Key`)的最后256位将用作 MAC 密钥(`MAC Key`)。使用先加密后 MAC 的原理，MAC 将使用 `HMAC-SHA-256` 计算。

在构造受保护的链接时，格式如下

	Algorithm || Type || Public Handle || Salt || Encrypted Key || MAC Tag
- Algorithm = 1个字节-用来标识使用哪个算法（以备将来升级）的字节，最初设置为0
- Type = 1字节-标识链接是文件夹还是文件链接的字节（0 =文件夹，1 =文件）
- Public Handle = 6个字节-公用文件夹/文件句柄
- Salt = 32个字节-随机生成的 salt
- Encrypted Key = 16或32字节-加密的实际文件夹或文件文件密钥
- MAC Tag = 32字节-所有先前数据的 MAC，以确保链接的完整性，即计算为

		HMAC-SHA-256( MAC Key, ( Algorithm || Type || Public Handle || Salt || Encrypted Key ))
链接数据经过 Base64 编码，然后进行修改以替换不兼容的字符，例如

		https://mega.nz/#P!AAA5TWTcs7YZg_hVxF0JTKxOZQ_s2d…

在接收到受保护的链接时，程序将在 #P！之后解码URL的 Base64 部分标识符

- 获取第一个字节以检查使用哪种算法对数据进行加密（如果算法将来进行更改）
- 它将使用密码用相同的算法（提供了salt 和密码）导出相同的文件或者目录加密密钥
- 可以计算数据的 MAC。 如果匹配，则说明该链接未被篡改或损坏，可以解密真实的文件夹/文件密钥并重建原始链接。 如果不匹配，然后将显示一个错误，表明可能已篡改或更可能是用户输入了错误的密码。

### 5.5 公共链接的过期
如果用户希望文件夹/文件内容不可用，则可以在其公共链接上添加有效时间在某个日期之后。 到期时间过后，API 逻辑将禁止访问链接和文件内容通过了。
### 5.6 从公共链接导入文件	
从公共链接将文件导入用户的云盘时，仅通过用户的主钥匙 ` Master Key` 加密了混淆文件密钥 `Obfuscated File Key`

	Encrypted File Key = AES-ECB( Master Key, Obfuscated File Key )）
然后，该加密密钥将以相同的公共文件句柄存储在用户的 API 上。 这个文件虽然相同，但是一个新的copy，需要用新密钥重新加密并重新上传。 

因此，如果采用原始文件链接，导致违反第3类版权侵权或其他服务条款，已导入的用户来自公共链接的文件也将无法再访问原始文件。
## 6 协作和共享文件夹
### 6.1 建立联系关系
MEGA 允许用户通过向他们发送联系请求来与他们建立联系。 如果 MEGA 用户知道另一个用户的 MEGA 帐户的电子邮件地址，然后该用户可以向他们发送联系人请求。 通过电子邮件的联系请求需要用户的批准。

MEGA 用户还可以通过扫描 QR 共享他们的联系链接或建立联系关系码。 默认情况下，默认情况下会自动批准通过 QR 或联系人链接建立联系的机构，但这可以可以选择关闭。	
### 6.2密钥交换和验证
在应用程序启动期间，将从 API 中为每个用户的联系人获取以下内容：

- Ed25519 Public Key
- Ed25519 Public Key Fingerprint
- RSA Public Key
- RSA Public Key Signature
- Curve25519 Public Key
- Curve25519 Public Key Signature

当用户的其他设备之一添加了新联系人时，该信息由 API 操作更新本地设备的状态。 操作数据包是 long-running  运行的开放连接的API 响应。 任何时候需要将用户打开的设备都将更新为最新状态（即文件，联系人，权限等），API 将通过打开的连接进行响应。

`Ed25519 Public Key` 被视为其他密钥的信任根。 创建用户帐户后，每个用户都使用 `Ed25519 Private Key` 对 `RSA Public Key`和 `Curve25519 Public Key`上签名。 所有私钥首先由用户的 `Master Key` 加密，然后再上传到 API。 公钥和 Ed25519 签名按原样上传到 API。 当用户获取其联系人的关键信息，将验证其 RSA 和 Curve25519 签名。 如果签名计算不匹配，显示错误，并且不允许与该联系人共享文件或与该联系人通信，以防止中间人（MITM）攻击。

用户首次获取联系人的 Ed25519 公钥时，将使用以下方法计算其哈希摘要，256 位哈希摘要的仅前160位保留为指纹：

	Fingerprint = SHA-256( Ed25519 Public Key )
使用以下方法为用户加密，然后将指纹作为私有用户属性存储在 API 上，以便只有用户才能检索它

	Encrypted Fingerprint = AES-GCM( Master Key, Fingerprint || Verification Type )
初始验证类型 `Verification Type` 0x00（可见）表示默认情况下，联系人将接受第一个看到的公共密钥。如果此后更改，则用户界面（UI）将显示警告，指示密钥已更改并且需要进行验证，否则他们将无法与联系人互动以共享文件或聊天。在更新情况如用户将其帐户寄存并在同一电子邮件地址下启动一个新帐户，或者它也可能是 MITM 攻击。

MEGA 支持通过 UI 对联系人进行指纹验证。这提供了更强大的安全保证用户确实与预期的联系人进行通信。这排除了提供假冒 MEGA 服务人员的公开密钥并执行 MITM 攻击。用户可以亲自或通过指纹验证指纹通过任何现有的安全渠道，例如 PGP 电子邮件，安全聊天等。如果确认指纹，验证类型 `Verification Type` 已更新为0x01（已验证），并且 UI 在联系人上显示了特殊的绿色复选图标。 
### 6.3 文件夹共享
- 共享文件夹先将创建一个随机的 128 位共享密钥 ` Share Key`。 文件夹中的所有文件密钥均其加密：

		Encrypted File Key = AES-CBC( Share Key , Obfuscated File Key )
- 然后使用联系人的公钥进行加密共享密钥 ` Share Key`

		Encrypted Share Key = RSA( Public RSA Key, Share Key )
- 将加密文件密钥 ` Encrypted File Keys` 和加密共享密钥 ` Encrypted Share Key` 发送到 API。 
- 联系人将下载加密共享密钥，并使用其 RSA 密钥  `Private RSA Key` 解密。 
- 然后他们将能够下载并解密文件夹共享的文件密钥，可用于解密文件。

### 6.4 与非联系人和未注册用户共享
与非联系人共享时，共享处于挂起状态。 建立联系关系后，共享用户可以获取联系人的密钥信息，并为他们加密共享密钥 ` Share Key` 和文件密钥 ` File Keys`。这里要注意的是，用户需要在线才能加密联系人的密钥。 如果不在线时，共享将处于待处理状态，直到用户进入在线状态。

对于未注册的用户，将通过电子邮件向他们发送邀请链接。 他们注册后，登录并接受未决联络人要求时，系统会向他们发送加密的共享密钥和文件密钥，以便他们可以访问文件夹共享。
### 6.5 企业用户密钥交换
MEGA 上的企业账户由三种类型组成。

- 主账户

	具有企业账户的整体管理权；
- 子账户

	他们的 `Master Key` 已加密到企业帐户，因此，使主账户可以对所有子帐户进行加密访问。
- 未登陆账户

	从未登录的企业帐户但用于保留整个企业的键和属性；

企业流程
	
- 注册单个账户，并将该用户帐户（新的临时帐户或注册的临时账户）转换为主帐户来创建业务账户
- 主用户账户为企业创建一组业务帐户新的密钥（`Master Key`和 `RSA对`）
- 业务账户 `Master Key` 已使用主用户账户的 `Master Key` 加密，并由 API 存储-主用户数据中？

		Encrypted Business Master Key = AES-ECB( Master User Master Key, Business Master Key )
- 主用户账户通过发送带有唯一 URL 的邀请电子邮件来创建子用户。加载此 URL 表示 API 将新创建的用户链接到公司？
- 子用户创建过程与单个用户相同，额外的步骤是使用企业账户的 `RSA 公钥` 加密自己的 `Master Key`，并将其与其他密钥一起发送给 API。而不是直接加密 `Master Key`，以支持未来的可能性每个企业有多个主用户帐户

		Encrypted Sub-user Master Key = RSA( Business Public RSA Key, Sub-user Master Key )
- 由于 API 允许主用户账户请求子用户的文件树，因此主用户将始终有子用户上传的任何文件的访问权，即使这些文件离开了业务

## 7 MEGAchat 短信
MEGAchat 旨在保护交换内容的隐私和机密性。 MEGAchat 支持交换短信、文件和联系人。 MEGAchat 交换的所有消息和文档通过端到端（用户控制）加密进行保护，从而提供基本的安全保证：

- 保密性

	只有作者和预定的收件人才能解密和阅读内容；
- 真实性

	系统确保接收到的数据是从发送方发出，并且内容没有在传输过程中被篡改

### 7.1 密码原语
MEGA 提供了一个基于云的平台，享有很高的知名度。因此，服务器端的可伸缩性在消息传输和客户端实现的可行性至关重要。即使服务器可扩展，往往与消息传递加密协议正交，它们会大大增加服务器基础架构开销（由于“盲目blind”协议引导数消息数量和消息大小的增加），因此提供的服务器只能为更少的用户提供服务。

根据经验，大多数客户将通过 Web （例如，实现端到端加密的 JavaScript 中）或计算能力有限的移动客户端使用 MEGAchat。为了减少延迟(通过快速响应时间）和减少负载端点硬件负载（通常是移动设备）来优化用户体验，最好避免频繁的“沉重”计算操作（例如，大整数的频繁取幂）。通常选择了 128 位熵的一般安全级加密原语，以对称密码（例如AES）。这等效于椭圆曲线公钥密码上的 256 位密钥强度和基于离散对数问题的公钥密码（例如RSA，DSA） 3072 位密钥强度。但在许多情况下 3072 位密钥强度是在许多情况下被认为过于昂贵（从计算上对熵计算要求的资源）。出于安全原因，避免了 NIST 标准化 ECC 曲线。
### 7.2 消息加密
#### 7.2.1 加密钥匙
- 每个发件人都有责任生成自己的对称加密密钥(AES)，以确保任何加密内容的用户控制密钥。因此，每个发件人都会生成自己的对称加密密钥用于加密消息。
- 然后需要与聊天中的所有其他参与者（成对）交换这些加密密钥。
- 然后对加密密钥以及消息有效内容进行加密以进行消息传输和存储。

##### 加密密钥生成
- 随机生成唯一 128 位长的加密密钥，可在 `AES-CTR` 模式下使用。
- 生成共享的秘密(万能密钥)

	使用一个人自己的私钥（𝑆𝑜𝑤𝑛）和另一个参与者的公钥（𝑃other）通过 `Curve25519 Diffie-Hellman` 标量乘法（ECDH并随后应用密钥导出函数（KDF, specifically [HKDF]-SHA-256）可以导出密钥。它被修剪到所需的密钥大小（128个最高有效位）

		𝐾𝐷𝐻, 𝑑𝑒𝑠𝑡 = 𝐾𝐷𝐹(𝐸𝐶𝐷𝐻(𝑆𝑜𝑤𝑛 , 𝑃𝑜𝑡h𝑒𝑟))
- 加密密钥 ID 的长度为32位，因为每个聊天的每个发件人都必须是唯一的
- 生成收件人的 IV
	- 收件人的用户句柄被 base64 URL 解码，产生一个8字节（64位）的序列（𝑢）
	- 从这些字节中使用消息的主随机数 `master nonce (𝑛)` 作为密钥，来计算密钥键哈希消息验证码（HMAC-哈希消息认证码，HMAC-SHA-256=sha256）
	- 然后将其修整为所需的 IV 大小（128个最高有效位）
	
			𝐼𝑉𝑑𝑒𝑠𝑡 = 𝐻𝑀𝐴𝐶(𝑛𝑚𝑎𝑠𝑡𝑒𝑟 , 𝑢𝑜𝑡h𝑒𝑟)
- 加密万能密钥要使用 `AES-CBC` 模式进行加密，需要使用初始化向量（IV）和万能密钥(ECDH 与每个参与者共享秘密)
- 使用 `AES-CTR` 加密消息密钥			

#### 7.2.2 消息加密
信息数据(`payload`)在 AES 的 CTR 模式下加密，使用消息的主随机数 `master nonce (𝑛)` 作为密钥并以字节序列 `payload` 作为值来计算 HMAC 而得出发件人密钥和消息随机数。 消息随机数将被修剪为仅使用 96 个最高有效位（12个字节），给计数器保留32位。

		𝑛𝑚𝑒𝑠𝑠𝑎𝑔𝑒 = 𝐻𝑀𝐴𝐶(𝑛𝑚𝑎𝑠𝑡𝑒𝑟, ”payload”) 
#### 7.2.3 消息签名
对版本号、消息类型、128位加密密钥以及组合的消息内容进行签名，对以下所有的（编码的）二进制消息内容进行签名。 所有消息签名都是使用发件人的 `Ed25519` 身份密钥进行计算。

要签名的内容计算如下：

	(𝑚𝑎𝑔𝑖𝑐 𝑛𝑢𝑚𝑏𝑒𝑟||𝑐𝑜𝑛𝑡𝑒𝑛𝑡 𝑡𝑜 𝑠𝑖𝑔𝑛)
在这里， `magic number` 是一个固定的字符串，用于将身份验证器与其他任何内容区分开（目前，它是是字节序列 “strongvelopesig”）。
#### 7.2.4 信息编码方式 
交换的消息中的所有字段都编码为 TLV（类型，长度，值）记录。整个消息以单个字节开头,该字节指示协议版本（以备将来更改）。目前协议版本为 0x03。

TLV 记录不必按照 TLV 类型编号排序，只要确保 SIGNATURE 记录在所有其他记录之前。 个人记录可能会丢失或重复多次。
### 7.3 加密密钥更换
每当需要新的发件人密钥时，发件人都会生成一个密钥，并将其发送（加密给所有参与者）连同新的密钥 ID 一起发送给所有参与收件人。理想的是定期刷新发件人密钥（防止长时间使用），或群聊的组成发生变化时（添加和/或已删除的参与者）。当组组成发生变化时，客户端向该组发送的第一条消息 chat 必须是一条说明新加密密钥的消息。

为了方便起见（例如，当以相反顺序加载聊天记录时），先前使用的密钥及其密钥 ID 为重新发送给小组中的先前参与者。客户端不会将先前的密钥发送给新加入的用户参与者，并且不会将新密钥发送给已离开的参与者。

可以在开放模式下创建聊天室。与关闭模式相比，密钥永远不会更换，并且每条消息被相同的密钥加密，称为统一密钥(`unified key`)。无法更换统一密钥，并且当新用户加入或退出聊天时，它不会更改。

### 7.4 消息解密
消息解密执行与消息加密相反的过程。

- 接受数据

	接收方从服务器接收到组合的内容和加密密钥后，便会检查版本号和消息类型，然后解析组合的内容。
- 获取共享密钥

	在 Curve25519 上完成了一对 ECC 点乘法，得到共享密钥，并且派生密钥(万能密钥)为生成以解密加密的128位密钥。
- 验证签名

	接收者验证了签名，以确保接收到的内容没有受到破坏。
- 获取 salt

	通过应用 HMAC-SHA-256，从汇编内容中解析的随机数得出 96 位的随机数。
- 解压数据

	然后使用 AES-CTR 通过 128 位加密密钥和96位随机数解密消息数据

### 7.5 留言顺序安全(为什么不用区块链嵌套方法？)
即使保护了消息的内容不受任何中间人攻击，攻击者也可以通过操纵顺序来进行攻击损害聊天系统的对话。

MEGAchat 使用以下策略来检测对话中的消息顺序是否被篡改，检测到错误，则会向用户提出错误。

1. 从客户端生成消息时，它将为消息生成唯一的 ID。
2. 发出一条消息后，它会迭代先前收到的消息并随机选择一些。然后，将这些消息的消息 ID 附加为对该消息的引用。
3. 接收者收到消息后，将检查消息的所有引用是否出现在之前的消息中，如果不是，则表明消息顺序已被破坏，接收方将收到的消息报错误。

消息的引用是随机选择的，因此可以很好地覆盖会话和几乎不可能在不引起注意的情况下更改订单

### 7.6 MEGAchat 中的富链接( Rich links)
用户通过 MEGAchat 共享 URL 时，可以选择打开富链接支持。 富链接得到提高可用性，因为发件人和接收者都可以预览相关 URL 的元数据（例如标题，说明和缩图）。 但是，确实需要通过 MEGA 的 API 请求该元数据，这会网址以纯文本格式公开给 MEGA（因此，该功能需要用户的明确同意）。 URL 的发送者总是请求该元数据，随后在 MEGAchat 消息有效负载中进行加密。通过 API 请求此类元数据的 URL 在安全的数据库中最多缓存24个小时（避免给 MEGAchat 很高负载）。 此数据仅出于操作目的而存储，并且根据策略流程实施隐私，而不是按设计隐私。

### 7.7 MEGAchat 中的聊天链接
聊天链接使人们可以轻松预览并加入群组聊天室，而无需个别邀请每一个人。 拥有有效聊天链接的任何用户都可以预览聊天记录、参与者和标题，甚至尚未在 MEGA 上注册的用户也是如此。 但只有注册用户有权以标准的写/读权限加入聊天。 只要聊天链接有效，就可以允许公开聊天的预览模式。

只能为开放模式下的聊天创建聊天链接（加密密钥不会旋转），并且需要主持人权限。 生成的聊天链接包括作为链接一部分的加密密钥，以及为聊天室创建的公共句柄。 主持人可以根据需设置该公共句柄无效，这将使聊天链接无效。 请注意，当最后一位主持人离开会议室时，聊天链接也会无效。
#### 7.7.1 打开模式下的加密与关闭模式下的密钥旋转
- 开放模式

	可以直接在开放模式下创建聊天，在该模式下，所有消息均被相同的密钥加密。而不是旋转密钥的方案。没有办法旋转统一密钥，并且当用户加入或离开会议室时不会改变。
- 密钥滚转模式

	在打开模式下，群聊的任何主持人都可以切换关闭模式，以启用密钥旋转（相反的操作是不可能的）。默认情况下，一对一聊天始终启用了密钥旋转功能，因为这些聊天不需要静态密钥。 组聊天默认情况下处于关闭状态，因此操作员可以在创建群聊后链接到该群聊。当操作员创建指向封闭的群聊的链接时，将向所有人显示管理消息，同志他们此聊天已链接
	
#### 7.7.2 如何创建统一密钥并将其分发给参与者
对于加入小组的每个参与者，邀请用户需将加密的统一密钥提供给邀请用户的私人 Cu25519 密钥和被邀请者的公共 Cu25519 密钥。 因此，新参与者可以通过使用邀请者的公钥及其自己的私钥来生成统一密钥的解密密钥。

对于预览者，统一密钥作为聊天链接的一部分以纯文本格式（使用 B64Url 编码）包括在内。
#### 7.7.3 预览模式和自动加入选项
点击有效聊天链接的用户可以预览聊天记录（具有只读权限），包括当前的参与者列表，即使他们尚未登录MEGA。如果有人提供不再有效的聊天链接，即使具有正确的统一密钥，也无法获取预览。

预览聊天链接的用户将可以在聊天处于打开模式时访问整个消息历史记录。

拥有有效聊天链接的任何 MEGA 帐户都可以（自动）以标准权限加入聊天（读/写权限）。他们即可加入而无需额外批准，尽管任何主持人都可以随时将其从聊天中删除。如果操作员要永久性地将其拒之门外，以便为了防止用户发起新的自动加入，主持人将需要使该聊天链接无效。

曾经参加过公开聊天但已经离开会议室的用户（前参与者）将无法再进行预览，因此他们只有在离开的那一刻才有权访问历史记录。然而，如果用户具有有效的聊天链接，仍然可以使用标准的读/写方式重新加入聊天，并重新获得对整个历史记录的访问权限。

如果聊天链接无效，则使用该链接的所有预览器都将立即从聊天中删除。打开的预览不会保留，因此如果客户端关闭，聊天将从列表中消失（除非预览器自动加入成为参与者）。

当未注册的用户在预览聊天链接时尝试自动加入聊天时，该用户将要求先登录或创建帐户。登录后，用户将能够完成加入。
#### 7.7.4 标题加密
开放模式下的聊天标题被统一密钥加密，因为任何预览者和参与者都需要解密它。 因此，当用户加入或离开时，标题无需更新，因为统一密钥不会更改。

将开放模式中的聊天切换为封闭模式时，标题将被加密为新密钥，与统一密钥不同，参与者的加入或者离开都需要更新。
#### 7.7.5 切换至关闭模式
主持人可以随时将打开模式下的聊天切换为关闭模式。 如果存在聊天链接，它将变为无效，组中的参与者将开始轮换并分发新密钥。封闭模式下的聊天不可能转换回开放模式下的聊天。

在聊天进入关闭模式时，预览聊天的任何人将不再能够加入，因为聊天链接会自动失效。 结果，除了参与者之外没有其他人可以预览历史记录。

## 8 MEGAchat音频和视频通话
MEGA用户可以相互之间进行音频/视频通话。

建立呼叫涉及三个方面：信令，媒体传输和加密。
### 8.1 呼叫信令
呼叫信令是通过服务器组件、HTTPS 的 Websocket 链接进行客户端之间的消息交换，其目的是：

1. 通过在组呼叫过程中发信号通知呼叫请求，接听/挂断和随后的新客户加入来建立呼。
2. 通过 SDP 消息协商客户端的共同能力，在客户端之间建立 webRTC 媒体会话，并交换在它们之间建立媒体传输路径所需的信息。
3. 在通话过程中，传达有关参与客户状态的实时信息，并向其发出信号最终退出通话。 同样在 webRTC 媒体连接丢失的情况下，通过信令通道重新协商建立连接。
### 8.2 媒体运输
在 webRTC 会话设置期间，端点交换信息（ICE 候选者），使他们能够确定交换的媒体的传输路径。 端点尽可能直接协商它们之间的媒体流。
### 8.3 Encryption
呼叫媒体流在 SRTP 加密的媒体会话中的端点之间交换。 要发起会话，需要通过 DTLS（数据报传输层安全性）握手来协商 SRTP（安全实时传输协议）加密算法、密钥和参数。在握手过程中通过验证交换的 SDP（会话描述协议）的描述符来验证客户端的真实性，该描述符出了其他外，还包含发件人的 SRTP 加密密钥的指纹。 

通过将发送的 SDP 与它的 MAC 哈希绑定来完成 SDP 身份验证。 MAC 哈希使用对等提供的随机密钥加密，并使用密钥接收者的公共椭圆曲线（Cu25519）聊天密钥加密。
### 8.4 WebRTC
MEGAchat 完全符合 WebRTC 和现有的 IETF 标准。 MEGAchat 本机端点也可以与任何符合 WebRTC 的网络浏览器（例如Google Chrome或Mozilla Firefox）安全地交换媒体。
### 8.5 群组通话
组调用是通过网状拓扑实现的。 每个客户端都将其单独加密的媒体流发送给呼叫中的每个所有人。 一切都是在对等基础上协商和交换的，并且没有共享密钥或流。 唯一的公共信道是信令信道。

## 原文
[mega 白皮书](https://mega.nz/SecurityWhitepaper.pdf)
## 宣传材料
- [“2018年最好的云存储”Mega的评测报告](https://www.geekpark.net/news/233006)

## 密码撞库
- [新西兰云存储托管平台Mega上万登陆凭证遭泄露](https://cloud.tencent.com/developer/news/277117)
- [把资料放在网盘的风险有多大？MEGA网盘87GB数据遭泄露](https://defense.yunaq.com/news/5c416bc9796db4111cbc4aef/)
- [Method to Protect Passwords in Databases for Web Applications](https://eprint.iacr.org/2015/387.pdf)