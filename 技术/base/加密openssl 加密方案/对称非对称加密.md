## zxcvbn
zxcvbn 是一种替代密码强度估计器，它小巧，快速，并且最重要的是不比采用 LUDS 更难。使用泄露的密码，将其估计值与四种现代猜测攻击中的最佳值进行比较，并将其显示为低幅度的准确和保守，适用于缓解在线攻击。

### zxcvbn安装
	bower update zxcvbn
	or
	npm install zxcvbn

[zxcvbn-git](https://github.com/dropbox/zxcvbn)

## 密码学基础之PBKDF2算法
站点登录需要输入用户名和密码，而密码属于个人敏感数据，应当只保存密码的单向哈希值。简单的哈希值，无法防止彩虹表攻击，使用基于口令的密钥派生算法 PBKDF2 可以解决这种问题。

PBKDF2 需要以下输入：

- 哈希算法

	建议选择SHA256或更安全的算法
- 密码

	用户密码
- 盐值

	建议最少8个字节，应使用安全的随机数
- 迭代次数

	建议迭代10000次左右，对于性能有特殊要求的可迭代1000次
- 长度

	

PBKDF2还有dk_len参数，通常用不到，本文省略。

## ECC 椭圆加密逻辑
- 私钥	
	- 随机生成256位二进制数
	- 32 字节
	- 转换成16进制就是看到的私钥
	- 选择好一点的随机数生成器不用担心重复问题
- 公钥
	- 通过 ECDSA(椭圆曲线数字签名算法) 和私钥生成
	-  公钥 x轴32个字节 y轴32个字节，总65个字节，最后一个字节是标示位，说明是 16进制
- 公式
	- 私钥是随机生成 K
	- 公钥P=K*G
		- 特性
			- 如果知道公钥，G还是常数，私钥烨无法得出，因为是单向函数
			-  给定的k值，很好验证
- 得到两个应用
	- 加密
		- 用户a
			- 私钥 KA
			- 公钥 PA
		- 用户b
			- 私钥 KB
			- 公钥 PB
		- 公式如下
				
				KA*PB=KA*(KB*G)=X1
			      KB*PA=KB*(KA*G)=X1
			      
			      X1 就是万能密钥，也就是只有用户A和用户B知道的密钥
	- 签名
		- 发布数据 M
		- 发布的签名(N)
			
				M*K=N
		- 验证签名
			
				M*P=M*K*G
				
				去掉 G 这个常数，就等于 N

### 什么是 ECDH 加密（Encryption with ECDH）
ECDH 是 DH 算法的一个变体。本质上它是一个密钥协商协议，而不是一个加密算法。换句话说，对于通信的双方，ECDH 定义了密钥生成和交换的规则，至于怎么用密钥对数据进行加密，取决于其他的算法。

算法试图解决如下问题：

通信的双方（例如 Alice 和 Bob ）希望安全地交换信息，使得第三方（中间人）即使可以截取通信的报文，但是无法解码得到原文

事实上，椭圆曲线在ECDH中解决了对称加密时，密钥可能会泄露的问题。ECDH的解决方式是：不通过信道直接传输对称密钥，而是传输椭圆曲线生成的公钥，然后通过收到的公钥再结合自己的私钥各自计算共享的密钥，椭圆曲线保证了双方计算出的密钥一定是相同的，并且第三方在不知道通信双方私钥的前提下，无法通过从信道中截取到的信息反推出共享密钥。
### 什么是 secp256k1
文章作者提供了一个Python脚本用来生成一条特定椭圆曲线的公私钥和共享密钥。这个脚本中使用的椭圆曲线是标准的（能够支撑实际的加密算法），而不是那种简单的曲线。这条曲线被称为 secp256k1，取自SECG（Standards for Efficient Cryptography Group）。这条曲线也是比特币用来做数字签名的椭圆曲线。
### TLS 中的使用 Ephemeral ECDH
ECDHE中的E（Ephemeral）代表算法的密钥交换过程是临时的，而不是静态的。ECDHE在TLS协议中被使用，当建立连接的时候，客户端和服务端都会动态的生成各自的公钥-私钥对。公钥随后用TLS证书签名(用于认证)，并在双方之间交换。

### 什么是 ECDSA 签名（Signing with ECDSA）
场景：Alice想用她的私钥(K1 )对一条消息进行签名，Bob 想用 Alice的公钥(P1)验证签名。除了 Alice，没有人能生成有效的签名，每个拥有 Alice 公钥的人都应该能够验证这个签名的有效性。

ESCDA 处理的实际上是消息的哈希值，而不是消息本身。哈希函数是可选择的，但这个哈希函数必须是一个密码学安全的哈希函数。消息的哈希值需要截取一个固定的长度 [Ln] ，这个长度是 [n] （子群的阶）的二进制位数。截取后的哈希值是一个整数z
#### 签名流程
1.  获取一个随机整数 k
2. 计算点 P=kG
3. 计算 r = xp mod n
4. 如 r = 0 ,就重新选择一个 k 再跑流程
5. 计算 s = k-1(z+rda) mod n
6. 如 s = 0 ，就重新选择一个 k 再重新计算
7. 得到二元组(r,s)就是消息签名

#### 验证签名
- 需要数据
	- 签名者公钥
	- 截取后哈希值 z
	- 签名(r,s)
- 验证流程
	- 计算整数 u1 = s-1 z mod n 
	- 计算整数 u2 = s-1 r mod n
	- 计算点 P = u1G+u2Ha

只有当 r = xp mod n 时，签名才有效

## BTC 例子
比特币地址是公钥经过两次 SHA256 运算结果
## HASH(散列函数)
### 定义
hash 一般翻译成"散列"，也可以直接音译叫"哈希"，用途是将任意长度的输入通过散列算法变换成指定长度的输出，输出值就是散列值。

这种转换是一种压缩映射，也就是，散列值的空间通常远小于输入的空间，不同的输入可能会散列成相同的输出，所以不可能从散列值来确定唯一的输入，也就是不能反推。

简单的说就是一种将任意长度的消息压缩到某一固定长度的消息摘要的函数。
### 特点
- 正向计算快

	给定明文和 hash 算法，有限时间和资源能计算出 hash 值
- 逆向困难

	摘要基本上很难推出明文，注意这里有前提就是明文要比较多，简单的明文还是可以的
- 确定性

	可以通过hash得到数据是否被篡改
- 避免冲突

	可以用来生成私钥，方法:先生成大的随机数，然后生成 HASH 值。当然可能产生碰撞hash ,但是会微乎其微



生成地址

		地址=ripemd-160(sha256(公钥))
		地址=hash160(hash256(data))
	`ripemd-160`是另一个摘要生成函数，生成 160 位，20个字节

- Condensed MAC
- PBKDF2-HMAC-SHA512
-  HMAC-SHA-256( MAC Key, ( Algorithm || Type || Public Handle || Salt || Encrypted Key ))				
## 参考
- [椭圆曲线加密与哈希函数是什么？非对称加密是什么？比特币中的数学原理](https://www.bilibili.com/video/BV1TE411q7mW?from=search&seid=9660169197754433037)
- [椭圆曲线密码学介绍之三：ECDH和ECDSA](https://zhuanlan.zhihu.com/p/55911409)
- [密码学基础之PBKDF2算法](https://www.jianshu.com/p/06d7182e71ec)
				 		 
			  