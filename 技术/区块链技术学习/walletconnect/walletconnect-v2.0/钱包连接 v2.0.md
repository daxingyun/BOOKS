# 钱包连接 v2.0
## 简介
WalletConnect 是一个开放协议，用于在 Dapp 和钱包之间进行安全通信。该协议使用中继服务器在两个应用程序和或设备之间建立远程配对来中继有效负载。这些有效载荷通过两个对等方之间的共享密钥进行对称加密。配对由一个显示二维码或带有标准 WalletConnect URI 的深层链接的对等方发起，并在对方批准此配对请求时建立。
### 入门
目前，WalletConnect 协议具有用 Typescript 为客户端和中继服务器编写的参考实现。要快速设置您的 Dapp 或钱包，请转到快速入门部分以获取代码示例。

要详细了解 WalletConnect 协议，请转到[技术规范](https://docs.walletconnect.com/2.0/protocol/tech-spec)。此外，您还可以查阅[客户端](https://docs.walletconnect.com/2.0/api/client-api)和[中继服务器](https://docs.walletconnect.com/2.0/api/relay-server)的 API 参考。
### 新知识
WalletConnect v2 完全重写，并具有许多新功能和优势。以下是一些新增内容：

- 链无感知

	与任何区块链互操作。开箱即用地支持新的区块链和汇总。
- 多链支持

	同时连接一个或多个链的钱包，同时向不同的链发送交易。没有更多的链切换。
- 多会话

	根据需要管理尽可能多的会话。提供了一个灵活的 API 来构建所需的 UX。
- 一次性配对

	从单个配对建立多个会话。无限数量的会话只有一个连接。
- 减少带宽

	Websocket 管理有效地重用资源，通过单个套接字多路复用所有消息而不会中断。
- 去中心化消息

	消息中继现在使用 Waku 网络通过所有节点传递消息。不再依赖集中式服务器。
- 权限系统

	明确要求钱包与您的 dapp 所需的所有签名方法兼容。
- 保证通常 

	更智能的缓存机制可确保在更多样化的网络条件下传递消息。
- 平台无感知

	适用于桌面应用程序、浏览器应用程序、移动应用程序、游戏应用程序等等。

### 有用的
这里有一些演示，您可以使用这些演示自己尝试该协议

- 应用演示

	[https://react-app.walletconnect.com/](https://react-app.walletconnect.com/)
- 钱包演示

	[https://react-wallet.walletconnect.com/](https://react-wallet.walletconnect.com/)
	
## 协议	
### 客户端沟通
WalletConnect 2.0 客户端将通过专门用于在两个连接的客户端之间进行通信的 JSON-RPC 方法为带外序列（会话和配对）传达状态和事件。这些将在结算前后的相应主题下发布和订阅。这可以在包含两个序列的这两种状态的单个矩阵下进行描述。

x|结算前|结算后
---|---|---
配对|wc_pairingApprove|wc_pairingUpdate
||wc_pairingReject|wc_pairingUpgrade
|||wc_pairingDelete
|||wc_pairingPayload
|||wc_pairingPing
|||wc_pairingNotification
会话|wc_sessionApprove|wc_sessionUpdate
||wc_sessionReject|wc_sessionUpgrade
|||wc_sessionDelete
|||wc_sessionPayload
|||wc_sessionPing
|||wc_sessionNotification

然而，这个矩阵不包括在每个序列通信的带外发生的配对和会话建议

- 配对提议通过为两个客户端之间共享一个 URI 的 qrcode 或深层链接
- 会话提议通过 `wc_pairingPayload` 请求共享，该请求包括方法 `wc_sessionPropose` 和下面描述的相应参数

### 词汇表
- 外带数据(OOB-out of band)

	传输层协议使用带外数据（out-of-band，OOB）来发送一些重要的数据，如果通信一方有重要的数据需要通知对方时，协议能够将这些数据快速地发送到对方。

	为了发送这些数据，协议一般不使用与普通数据相同的通道，而是使用另外的通道。linux系统的套接字机制支持低层协议发送和接受带外数据。但是TCP协议没有真正意义上的带外数据。
- 序列(Sequence)

	序列是指从提案开始到结算的完整流程。提议者将创建一个序列提议，该提议将派生一个信号以与响应者共享带外，以便就序列的不同权限和条件达成一致。一个序列确定两个客户端如何相互中继消息，他们将使用哪些密钥来加密和验证消息，另外还有关于可以发出的 JSON-RPC 请求的权限、可以发出的通知以及将使用什么状态被分享。

	协议指定了两种类型的序列，称为配对和会话。
- 配对(Pairing)

	配对是一个专门的序列，它具有固定的权限，仅允许客户端通过它使用 `wc_sessionPropose` 将用作会话提议的带外信号的方法来提议会话
- 会话(Session)

	会话是一个通用序列，它具有关于 JSON-RPC 请求、发出的通知以及根据权限中确定的链集公开哪些帐户的可定制权限。
- 信号(Signal)

	信号是可以在序列之外（带外）共享的有效载荷，以将提案传达给另一个客户端。每个序列都有自己的信号类型。

	- 配对

		是一个具有固定权限的特殊序列，因此可以仅使用提议主题、提议者的公钥、中继协议选项和提议者的控制器标志将信号编码为 URI。这可以通过二维码或客户端之间的深度链接共享。
	- 会话

		是具有自定义权限的通用序列，因此信号是通过两个客户端之间已经建立的固定配对发送的建议。
- 结算(Settlement)

	结算是指两个客户端将根据序列提议的成功响应执行的内部事件。在响应者的情况下，解决发生在响应发布给提议者之前。

	如果是提议者，则在收到响应者发布的响应后进行结算。结算将使用参与者的密钥对生成一个共享密钥，并将通过散列共享密钥来确定主题，该共享密钥只有两个参与者都知道
- 控制器（Controller）

	客户端可以是控制器或非控制器。这意味着该客户端响应和/或建议的所有序列都将由它控制。

	控制器不受序列设置的权限的限制，这意味着它可以发送任何 JSON-RPC 请求，发出任何通知类型，并且是唯一升级权限或更新序列状态的参与者。

	控制器客户端始终是“钱包”，它将区块链帐户暴露给“dapp”，因此也负责签名。然而，断开连接并不是控制器客户端独有的，并且可以由任一参与者触发
- 过期(Expiry)

	Expiry 是指序列被删除时的时间戳。
	
	每当响应者解决序列时，它都会通过将 TTL 添加到当前时间戳来计算到期时间。然后，提议者将使用响应者计算的到期时间。到期时间始终以秒表示。
- 生存时间 (TTL)

	生存时间 (TTL) 是指序列生存的最大持续时间。TTL 加上当前时间戳用于计算到期时间戳。TTL 时间始终以秒表示。
- 共享密钥(Shared Key)

	共享密钥是使用椭圆曲线 Diffie-Hellman (ECDH) 密钥协议方案使用两个参与者密钥对派生的密钥。

	选择的椭圆曲线是 Curve25519，提供 128 位安全性（256 位密钥大小），专为 ECDH 设计，并在本机得到许多不同平台的广泛支持。其DH功能名称为X25519
- 认证加密(Authenticated Encryption)

	身份验证加密是指一种模拟的加密形式，以保证数据的机密性和真实性。
	
	选择的方法是先加密后的 MAC，它会根据生成的密文生成 MAC。加密使用带有随机初始化向量 (IV) 的 AES-256-CBC，身份验证使用 HMAC-SHA256。加密的有效载荷按以下顺序序列化：
	
	- iv //加密向量
	- publicKey //公钥
	- mac // 密文 mac
	- cipherText。// 密文
	
	为了派生加密和身份验证密钥，它使用共享密钥的 SHA512 散列，使用前 32 个字节进行加密，最后 32 个字节进行身份验证
- JSON-RPC

	JSON-RPC 是一种无状态、轻量级的远程过程调用 (RPC) 协议，它使用 JSON (RFC 4627) 作为数据格式。您可以在[此处](https://www.jsonrpc.org/specification)阅读有关 JSON-RPC 规范的更多信息
- 中继器(Relay)

	中继是指用于在两个客户端之间发送和接收消息的系统、网络和/或机制。

	默认情况下，客户端将使用连接到 Waku 网络的代理服务器，并将使用参考 [Relay API](https://docs.walletconnect.com/2.0/api/relay-server) 通过 WebSocket 连接到客户端
- 发布订阅(Publish-Subscribe)

	Publish-Subscribe（也称为 PubSub）是一种消息传递模式，其中消息的发送者（发布者）不直接向接收者发送消息，而是使用订阅者可以收听的主题标记消息。订阅者只接收与表达兴趣的主题匹配的消息。
- 主题(Topics)

	主题是 32 字节的十六进制字符串，用于标识两个客户端之间发送的关于建议序列或已解决序列的消息。提议的序列使用随机生成的主题，而已解决的序列使用 sharedKey 的 SHA256 哈希。

### 状态码
每当在两个客户端之间发出状态更改事件或错误时，它将包含一个带有消息的原因代码，该消息将包含在以下原因列表中：

	# 0 (Generic)
	code: 0
	message: message // 消息
	
	# 1000 (Internal)
	code: 1000
	message: "Missing or invalid ${name}" //丢失或内部错误
	
	code: 1001
	message: "Response is required for approved ${context} proposals" //已批准的 ${context} 提案需要回复
	
	code: 1002
	message: "Decrypt params required for ${context}" // 解密 ${context} 所需的参数
	
	code: 1003
	message: "Invalid ${context} update request" //${context} 更新请求无效
	
	code: 1004
	message: "Invalid ${context} upgrade request" //${context} 升级请求无效
	
	code: 1005
	message: "Invalid storage key name: ${name}" // 存储密钥名称无效：${name}
	
	code: 1100
	message: "Record already exists for ${context} matching id: ${id}" //${context} 匹配 id 的记录已存在：${id}
	
	code: 1200
	message: "Restore will override already set ${context}" //恢复将覆盖已设置的 ${context}
	
	code: 1300
	message: "No matching ${context} with id: ${id}" //没有匹配的 ${context} 与 id: ${id}
	
	code: 1301
	message: "No matching ${context} with topic: ${topic}" //没有与主题匹配的 ${context}：${topic}
	
	code: 1302
	message: "No response found in pending ${context} proposal" //在待处理的 ${context} 提案中未找到响应
	
	code: 1303
	message: "No matching key with tag: ${tag}" //没有与标签：${tag} 匹配的 key
	
	code: 1400
	message: "Unknown JSON-RPC Method Requested: ${method}" // 请求的未知 JSON-RPC 方法：${method}
	
	code: 1500
	message: "Mismatched topic for ${context} with id: ${id}" // id 为 ${context} 的主题不匹配：${id}
	
	code: 1501
	message: "Invalid accounts with mismatched chains: ${mismatched_array}" // 链不匹配的无效帐户：${mismatched_array}
	
	code: 1600
	message: "${context} settled" // ${context} 已解决
	
	code: 1601
	message: "${context} not approved" // ${context} 未获批准
	
	code: 1602
	message: "${context} proposal responded" // ${context} 提案得到响应
	
	code: 1603
	message: "${context} response acknowledge" // ${context} 响应确认
	
	code: 1604
	message: "${context} expired" // ${context} 已过期
	
	code: 1605
	message: "${context} deleted" // ${context} 已删除
	
	code: 1606
	message: "Subscription resubscribed with topic: ${topic}" // 重新订阅主题：${topic}
	
	# 2000 (Timeout)
	code: 2000
	message: "${context} failed to settle after ${timeout} seconds" // ${context} 在 ${timeout} 秒后未能解决
	
	code: 2001
	message: "JSON-RPC Request timeout after ${timeout} seconds: ${method}" // ${timeout} 秒后 JSON-RPC 请求超时：${method}
	
	# 3000 (Unauthorized)
	code: 3000
	message: "Unauthorized Target ChainId Requested: ${chainId}" // 请求未经授权的目标链 ID：${chainId}
	
	code: 3001
	message: "Unauthorized JSON-RPC Method Requested: ${method}" // 请求未经授权的 JSON-RPC 方法：${method}
	
	code: 3002
	message: "Unauthorized Notification Type Requested: ${type}" // 请求的未经授权的通知类型：${type}
	
	code: 3003
	message: "Unauthorized ${context} update request" // 未经授权的 ${context} 更新请求
	
	code: 3004
	message: "Unauthorized ${context} upgrade request" // 未经授权的 ${context} 升级请求
	
	code: 3005
	message: "Unauthorized: peer is also ${"" | "not"} controller" // 未授权：peer 也是 ${"" | “不是”} 控制器
	
	# 4000 (EIP-1193)
	code: 4001
	message: "User rejected the request." // 用户拒绝了请求
	
	code: 4100
	message: "The requested account and/or method has not been authorized by the user." // 请求的帐户和/或方法未经用户授权
	
	code: 4200
	message: "The requested method is not supported by this ${blockhain} provider." // 此 ${blockhain} 提供程序不支持请求的方法
	
	code: 4900
	message: "The provider is disconnected from all chains." // 提供者与所有链断开连接
	
	code: 4901
	message: "The provider is disconnected from the specified chain." // 提供者与指定链断开连接
	
	# 5000 (CAIP-25)
	code: 5000
	message: "User disapproved requested chains" // 用户拒绝了请求的链
	
	code: 5001
	message: "User disapproved requested json-rpc methods"  // 用户拒绝请求的 json-rpc 方法
	
	code: 5002
	message: "User disapproved requested notification types" // 用户拒绝请求的通知类型
	
	code: 5100
	message: "Requested chains are not supported: ${chains_array}" // 不支持请求的链：${chains_array}
	
	code: 5101
	message: "Requested json-rpc methods are not supported: ${methods_array}" // 不支持请求的 json-rpc 方法：${methods_array}
	
	code: 5102
	message: "Requested notification types are not supported: ${types_array}" // 不支持请求的通知类型：${types_array}
	
	code: 5103
	message: "Proposed ${context} signal is unsupported" // 不支持提议的 ${context} 信号
	
	code: 5900
	message: "User disconnected ${context}" // 用户断开连接 ${context}
	
	# 9000 (Unknown)
	code: 9000
	message: "Unknown error${"" || ": ${error_message}"}" //未知错误${"" || ": ${error_message}}
	
#### JSON-RPC  API
您可以在下面找到客户端之间用于传递状态和事件的所有 JSON-RPC 方法，以及请求和响应的相应接口。下面引用的任何接口（例如 `RelayProtocolOptions、PairingParticipant`等）指的是[技术规范](https://docs.walletconnect.com/2.0/protocol/tech-spec)中描述的相同接口

- 配对
	- `wc_pairingApprove` 配对提议响应
	
		此请求作为配对建议的响应发送，该配对建议使用客户端之间共享的 URI 从外部发出信号。
		
			// 请求
			interface WCPairingApproveRequest {
			  id: number;
			  jsonrpc: "2.0";
			  method: "wc_pairingApprove";
			  params: {
			    relay: RelayProtocolOptions;
			    responder: PairingParticipant;
			    expiry: number;
			    state: PairingState;
			  };
			}
			
			// 响应
			interface WCPairingApproveResponse {
			  id: number;
			  jsonrpc: "2.0";
			  result: true;
			}
		注意：此请求的响应将作为对提议者配对结算的确
	- `wc_pairingReject` 配对建议响应
	
		此请求作为配对建议的响应发送，该配对建议使用客户端之间共享的 URI 从外部发出信号。
		
			// 请求
			interface WCPairingRejectRequest {
			  id: number;
			  jsonrpc: "2.0";
			  method: "wc_pairingReject";
			  params: {
			    reason: string;
			  };
			}
			
			// 响应
			interface WCPairingRejectResponse {
			  id: number;
			  jsonrpc: "2.0";
			  result: true;
			}
		注意：此请求的响应将作为对提议者配对结算的确认
	- `wc_pairingUpdate` 更新配对
	
		此请求用于更新配对参与者的状态，控制器可选地提供该状态以在配对生命周期内共享应用程序元数据。
		
			// 请求
			interface WCPairingUpdateRequest {
			  id: number;
			  jsonrpc: "2.0";
			  method: "wc_pairingUpdate";
			  params: {
			    state: Partial<PairingState>;
			  };
			}
			
			// 响应
			interface WCPairingUpdateResponse {
			  id: number;
			  jsonrpc: "2.0";
			  result: true;
			}
	- `wc_pairingUpgrade` 配对生命周期升级
	
		此请求用于在控制器提供的配对生命周期内升级配对的权限
		
			// 请求
			interface WCPairingUpgradeRequest {
			  id: number;
			  jsonrpc: "2.0";
			  method: "wc_pairingUpgrade";
			  params: {
			    permissions: Partial<PairingPermissions>;
			  };
			}
			
			// 响应
			interface WCPairingUpgradeResponse {
			  id: number;
			  jsonrpc: "2.0";
			  result: true;
			}
	- `wc_pairingDelete ` 删除配对
	
		此请求用于删除配对并通知对等方它将不再接收与此主题中继的有效负载，并指定在过期之前删除的原因
		
			// 请求
			interface WCPairingDeleteRequest {
			  id: number;
			  jsonrpc: "2.0";
			  method: "wc_pairingDelete";
			  params: {
			    reason: string;
			  };
			}
			
			// 响应
			interface WCPairingDeleteResponse {
			  id: number;
			  jsonrpc: "2.0";
			  result: true;
			}
	- `wc_pairingPayload `配对匹配有效负载
	
		此请求用于中继与配对结算商定的方法列表匹配的有效负载。使用未经授权的方法发送的任何请求将立即被客户端拒绝。
		
			// 请求
			interface WCPairingPayloadRequest {
			  id: number;
			  jsonrpc: "2.0";
			  method: "wc_pairingPayload";
			  params: {
			    request: {
			      method: string;
			      params: any;
			    };
			  };
			}
			
			// 响应
			interface WCPairingPayloadResponse {
			  id: number;
			  jsonrpc: "2.0";
			  result: any;
			}
	- `wc_pairingPing ` ping 配对
	
		此请求用于在内部 ping 另一个客户端以验证其是否在线。Ping 由任一客户端在内部自动响应。默认情况下，如果 30 秒内没有响应 ping，客户端将引发超时。
		
			// 请求
			interface WCPairingPingRequest {
			  id: number;
			  jsonrpc: "2.0";
			  method: "wc_pairingPing";
			  params: {};
			}
			
			// 响应
			interface WCPairingPingResponse {
			  id: number;
			  jsonrpc: "2.0";
			  result: true;
			}
	- `wc_pairingNotification ` 配对消息
	
		此请求用于将事件作为通知发出，这些通知与配对结算商定的类型列表相匹配。任何使用未经授权类型发送的请求都将被控制器客户端立即拒绝。
	
			// 请求
			interface WCPairingNotificationRequest {
			  id: number;
			  jsonrpc: "2.0";
			  method: "wc_pairingNotification";
			  params: {
			    type: string;
			    data: any;
			  };
			}
			
			// 响应
			interface WCPairingNotificationResponse {
			  id: number;
			  jsonrpc: "2.0";
			  result: true;
			}
- 会话			
	- `wc_sessionPropose` 会话提议
	
		此请求用于向已确定配对的客户端发送会话建议，因此此方法仅存在于配对有效负载中，并且它是唯一允许通过配对中继的方法。
		
			// 请求
			interface WCSessionProposeRequest {
			  id: number;
			  jsonrpc: "2.0";
			  method: "wc_sessionPropose";
			  params: {
			    topic: string;
			    relay: RelayProtocolOptions;
			    proposer: SessionParticipant;
			    signal: SessionSignal;
			    permissions: SessionPermissions;
			    ttl: number;
			  };
			}
			
			// 响应
			interface WCSessionProposeResponse {
			  id: number;
			  jsonrpc: "2.0";
			  result: true;
			}
	- `wc_sessionApprove ` 会话提议响应
	
		该请求作为对会话提议的响应发送，该会话提议使用客户端之间共享的 URI 从外部发出信号。
		
			// 请求
			interface WCSessionApproveRequest {
			  id: number;
			  jsonrpc: "2.0";
			  method: "wc_sessionApprove";
			  params: {
			    relay: RelayProtocolOptions;
			    responder: SessionParticipant;
			    expiry: number;
			    state: SessionState;
			  };
			}
			
			// 响应
			interface WCSessionApproveResponse {
			  id: number;
			  jsonrpc: "2.0";
			  result: true;
			}
		注意：此请求的响应将作为对提议者会话结算的确认
	- `wc_sessionReject` 会话提议响应
	
		该请求作为对会话提议的响应发送，该会话提议使用客户端之间共享的 URI 从外部发出信号。
		
			// 请求
			interface WCSessionRejectRequest {
			  id: number;
			  jsonrpc: "2.0";
			  method: "wc_sessionReject";
			  params: {
			    reason: string;
			  };
			}
			
			// 响应
			interface WCSessionRejectResponse {
			  id: number;
			  jsonrpc: "2.0";
			  result: true;
			}
		注意：此请求的响应将作为对提议者会话结算的确认
	- `wc_sessionUpdate` 会话状态升级
	
		此请求用于更新会话参与者的状态，该状态由响应者额外帐户在会话生命周期内可选地提供；
		
			// 请求
			interface WCSessionUpdateRequest {
			  id: number;
			  jsonrpc: "2.0";
			  method: "wc_sessionUpdate";
			  params: {
			    state: Partial<SessionState>;
			  };
			}
			
			// 响应
			interface WCSessionUpdateResponse {
			  id: number;
			  jsonrpc: "2.0";
			  result: true;
			}
	- `wc_sessionUpgrade ` 会话生命周期升级
	
		此请求用于在控制器提供的会话生命周期内升级会话的权限
		
			// 请求
			interface WCSessionUpgradeRequest {
			  id: number;
			  jsonrpc: "2.0";
			  method: "wc_sessionUpgrade";
			  params: {
			    permissions: Partial<SessionPermmissions>;
			  };
			}
			
			// 响应
			interface WCSessionUpgradeResponse {
			  id: number;
			  jsonrpc: "2.0";
			  result: true;
			}			
	- `wc_sessionDelete ` 会话删除
	
		此请求用于删除会话并通知对等方它将不再接收与此主题中继的有效负载，并指定在过期之前删除的原因。
		
			// 请求
			interface WCSessionDeleteRequest {
			  id: number;
			  jsonrpc: "2.0";
			  method: "wc_sessionDelete";
			  params: {
			    reason: string;
			  };
			}
			
			// 响应
			interface WCSessionDeleteResponse {
			  id: number;
			  jsonrpc: "2.0";
			  result: true;
			}
	- `wc_sessionPayload ` 会话有效负载
	
		此请求用于中继与会话结算商定的方法列表匹配的有效负载。使用未经授权的方法发送的任何请求将立即被客户端拒绝。
		
			// 请求
			interface WCSessionPayloadRequest {
			  id: number;
			  jsonrpc: "2.0";
			  method: "wc_sessionPayload";
			  params: {
			    request: {
			      method: string;
			      params: any;
			    };
			    chainId?: string;
			  };
			}
			
			// 响应
			interface WCSessionPayloadResponse {
			  id: number;
			  jsonrpc: "2.0";
			  result: any;
			}		
	- `wc_sessionPing` 会话ping
	
		此请求用于在内部 ping 另一个客户端以验证其是否在线。Ping 由任一客户端在内部自动响应。默认情况下，如果 30 秒内没有响应 ping，客户端将引发超时。
		
			// 请求
			interface WCSessionPingRequest {
			  id: number;
			  jsonrpc: "2.0";
			  method: "wc_sessionPing";
			  params: {};
			}
			
			// 响应
			interface WCSessionPingResponse {
			  id: number;
			  jsonrpc: "2.0";
			  result: true;
			}	
	- `wc_sessionNotification` 会话消息
	
		此请求用于将事件作为通知发出，这些通知与会话结算商定的类型列表相匹配。任何使用未经授权类型发送的请求都将被控制器客户端立即拒绝
		
			// 请求
			interface WCSessionNotificationRequest {
			  id: number;
			  jsonrpc: "2.0";
			  method: "wc_sessionNotification";
			  params: {
			    type: string;
			    data: any;
			  };
			}
			
			// 响应
			interface WCSessionNotificationResponse {
			  id: number;
			  jsonrpc: "2.0";
			  result: true;
			}

### 会话管理
使用 WalletConnect v2.0 协议管理会话得到了显着改进。客户端将保持会话状态为最新并缓存在 key 值存储中。因此，您可以依靠客户端在您的应用程序上跟踪其状态并简单地使用事件来更新它。

无论您是将 WalletConnect 集成到应用程序还是钱包，您都可以按照以下说明改善 WalletConnect 用户体验。

- 初始化

	只有在客户端成功初始化后才能进行任何状态查询。

		import { Client } from "@walletconnect/client";
		
		const client = await Client.init({ ...clientOpts });
- 状态查询

	WalletConnect 基本上跟踪两个序列（配对(pairing)和会话(session)），您可以使用以下方法从客户端查询它们：values(值), topics(主题) 和 entries(条目)

		/* ----------- 配对 ----------- */
		
		// 获取所有活动的配对
		const pairings = client.pairing.values;
		
		// 获取所有配对活动的主题
		const topics = client.pairing.topics;
		
		/* ----------- 会话 ----------- */
		
		// 获取所有会话
		const sessions = client.session.values;
		
		// 获取所有会话的主题
		const topics = client.session.topics;
- 事件监听

	如果您在应用程序中跟踪上述任何状态变量，您还应该为使用同步事件名称所做的更改注册事件侦听器。
	
		import { CLIENT_EVENTS } from "@walletconnect/client";
		import { PairingTypes, SessioTypes } from "@walletconnect/types";
		
		/* ----------- 配对 ----------- */
		
		client.on(CLIENT_EVENTS.pairing.sync, () => {
		  pairings = client.pairing.values;
		});
		
		/* ----------- 会话 ----------- */
		
		client.on(CLIENT_EVENTS.session.sync, () => {
		  sessions = client.session.values;
		});
- `Pending ` 请求

	当您的应用重新加载时，您可能希望恢复一些尚未响应的挂起请求的 JSON-RPC 历史记录。
	
		// 获取待处理的请求事件（主题、请求）
		// （会议提案将包含在此处）
		const requests = client.pairing.history.pending;
		
		//获取待处理的请求事件（主题、请求、chainId）
		const requests = client.session.history.pending;

	

	

	
	
	

	
	

				
	
		

		
		
											
	
	
			

			