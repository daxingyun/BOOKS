# IPLD 模式和迁移
我们的模式方法的基础是理解：

- 数据永不改变
- 只是我们的解释不同。

数据可以在一种模式下创建，稍后在另一种模式下解释。数据可能早于或创建时根本没有任何类型的模式。所有这些都需要很好。

此外，在谈论迁移之前，重要的是要注意我们不允许令人欣慰的、简单的概念，即迁移是一个单向过程，或者可以在一个神奇的瞬间原子地执行。因为数据是不可变的，并且生成它的更新版本不会使旧版本的数据消失，所以迁移不是你要做的事情；更是一种心态。迁移必须在任何时候都是无缝的。

迁移分为两部分：

- 了解我们拥有哪些数据；
- 并有一个过程将其 map 为我们想要的数据格式。

我们将在第 1 部分花费几个部分，然后继续第 2 部分。

## 版本检测
我们不在 IPLD 架构中包含任何内置/受祝福的版本控制概念。这不是必需的：我们有丰富的原语，可用于构建显式版本控制或版本检测，由您选择。

由于检查模式是否适合一段数据很容易，因此很容易简单地探测一系列模式直到找到适合的模式。因此，模式所做的任何约束都有可能用于版本检测！

有一些经常使用的可识别模式：

- 使用虚拟 union 在文档根部获得主格类型。
	- 例如 `{"foo": {...}}` ，使用“foo”作为类型+版本提示。union 只有一个成员，我们将其与多个模式和探测一起使用：在不匹配的情况下它会快速返回。
	- 任何 union 代表都可以。
		- Keyed union：`{"foo-v2": {...}}`
		- Envelope union：`{"version": "2", "content":{...}}`
	- Inline unions ：`{"version": "2", ...}`
	- 单成员结构也适合该模式，在功能上等同于 keyed union。
	- 有关此示例，请参阅架构-架构！
- 使用“版本” union（具有多个成员）。
	- 例如{"version": "1.2.3", "data":{...}}
	- 任何 union 代表都可以。
	- 这可能不是最好的方法：在这种方法中，多个版本在一个模式中实现！通常，每个版本使用单独的模式被认为更易于使用且更易于维护。
- 使用带有“版本”字段的结构，然后进行第二次解包。
	- 匹配的两个阶段允许用户在中间指定决定：
		- 首先使用一个简单的模式，包含一些版本信息的结构字段，以及一些将包含更多内容的忽略字段。假设这个简单的模式完全匹配。
		- 其次，使用来自第一遍的信息，用户指定的逻辑选择一个完整的模式，然后使用它来处理完整的数据。

（目前，这种探测留给了图书馆用户。预计未来会有更多围绕此的内置功能。）

也可以组合这些方法中的任何一种。例如，您可能会选择在文档的根部使用虚拟 union 来完整性检查您正在处理的一般数据类型；并在其中使用 Inline unions 来进行更具体的版本匹配，等等。

（在未来，我们也许还能够构建一些专门的模式，建议具体和直接地跳转到另一个模式（而不是线性探测）；需要一些研究。（理想情况下，无论到达的字段顺序如何，这都将始终如一地工作数据，但它与性能之间存在一些紧张关系。）也可能已经将这些构建为用户！）

请注意，即使未使用 IPLD 模式实现的系统也很容易采用这些约定！如果您正在使用尚未开始使用 IPLD 模式的系统，并且您的目标是将来使用，现在就开始使用 基于这些设计的版本提示；这些好处可以在以后获得。

## 版本控制理论
有不同的版本控制哲学：

- 即显式版本控制标签
	- 带有标签的显式版本控制采用规范的方法，需要预先协调标签选择，因此往往很脆弱，并且不是特别适合分叉/社区/去中心化。
	- 显式版本标签倾向于将版本标签视为语义垃圾抽屉，我们可以在其上堆放无限量的不必要相关的语义。这是一种可以通过勤奋减轻的诱惑，但基本的动机始终存在：就像编程中的全局变量一样，文档全局显式版本允许懒惰编码并促进假设。
- 和版本检测；
	- 版本检测也称为它的通用表亲，特征检测——严格来说更强大，但也可能更复杂。如果没有计划，两者都无法可靠地部署。
	- 版本/功能检测有可能成为一个分形。因此，用好它也需要勤奋。但是没有内置的警笛诱惑以与显式版本控制相同的方式滥用它们；复杂性的权衡往往使自己相当明显，因此相对容易沟通。
	
使用哪个是一个选择。

简而言之，不可能对如何将版本信息与数据相关联做出一揽子规定。不同的选择有不同的权衡。IPLD 模式旨在使任何一种选择（或混合方法！）变得可行。

### 强链接模式
可以有一个直接链接到它自己的模式的文档！由于 IPLD 模式本身在 IPLD 中是可表示的，因此创建一个包含链接到模式的 CID 的对象是完全微不足道的。

这可能很有用——特别是，它确实解决了在使用显式版本控制时选择唯一版本字符串的任何问题！-- 但同样值得注意的是，这不是迁移的解决方案：虽然显式链接特定模式肯定是解决“了解我们拥有的数据”需求的一种方法，但请记住迁移的定义有第二个一半：“有一个将数据映射到我们想要的格式的过程”。

除非碰巧这个确切的模式是你想要的，并且已经构建了你的应用程序逻辑等等......一个显式链接的模式不一定比任何其他形式的迁移在迁移方面提供更多的价值版本控制；它与使用显式标签本质上是一样的。
### 实际迁移
IPLD 模式并不完全神奇。

迁移的某些部分不可避免地留给了应用程序逻辑。几乎根据定义，“将数据映射为我们想要的数据格式的过程”在其最普遍的情况下将是一个图灵完备的操作。

然而，IPLD 仍然可以提供帮助：数据模型与模式之间的关系为编写可维护的迁移提供了基础。

Node 任何迁移逻辑都可以表示为从 Node 到的函数。这些节点可能每个都在检查模式有效性——针对两个不同的模式！-- 但是将数据从一个节点转移到另一个节点的代码可以完全在数据模型中运行。结果是能够编写有效处理多个分离类型系统的代码……没有任何实际问题。

因此，长期应用程序设计的有效策略是通过复制/分叉当前模式来处理模式的每个主要更改；保留它以用作旧版本数据的识别器；并编写一个快速函数，可以将数据从旧模式格式转换为新模式格式。解析数据时，先尝试较新的模式；如果被拒绝，请尝试旧的，并在必要时使用迁移功能。

如果您使用的是基于架构的代码生成器，请注意您可能只需要对架构的最新/最喜欢的版本使用代码生成器。ipldcbor.Node（这是一件好事！我们不希望每个版本生成的大量代码开始堆积在我们的存储库中。）其他版本的数据解析可以由或其他为处理串行数据而优化的此类实现来处理；迁移函数是构建代码生成的本地类型化 Nodes 的自然场所，因此过程的每一半都可以轻松使用 Node 最适合的实现。