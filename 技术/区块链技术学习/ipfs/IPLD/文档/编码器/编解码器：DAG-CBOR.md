# 编解码器：DAG-CBOR
DAG-CBOR 是一种编解码器，它将 IPLD 数据模型实现为 CBOR 的子集，外加一些哈希一致表示的附加约束。DAG-CBOR 还使用 CBOR 标签添加了“链接”类型，使其与 IPLD [数据模型](https://ipld.io/glossary/#data-model) 保持一致。

DAG-CBOR 是我们推荐使用的编解码器。它具有非常完整的 IPLD 数据模型map；它是二进制的和长度分隔的（这意味着它通常解析起来非常有效）；它通过 IPLD 生态系统得到广泛支持。

有关详细信息，请参阅 [DAG-CBOR 规范](https://ipld.io/specs/codecs/dag-cbor/)。
## 快速比较
- 概论

	DAG-CBOR 支持完整的 IPLD [数据模型](https://ipld.io/glossary/#data-model)，完全无损。
- 互操作性

	DAG-CBOR 基于 CBOR，而 CBOR 库已经无处不在，可以在多种语言中找到。如果您使用的语言还没有 IPLD 库，您可以轻松地使用另一个 CBOR 库。
- 表现

	（标准性能警告：实现细节总是很重要；性能总是视情况而定；在假定序列化性能是关键瓶颈之前总是做基准测试；等等）

	  DAG-CBOR 通常被认为是快速的。它是一种二进制的、长度为前缀的格式。这些特征通常与良好的表现相关。
	
	（在长度前缀格式中，字符串可以在不转义的情况下快速扫描，在不转义的情况下进行编码；可以预先进行分配；等等；所有这些都有助于提高速度和效率。）
- 人性化

	DAG-CBOR 不是很人性化。它是一种二进制的、长度为前缀的格式。虽然这些特性有助于其性能，但它们并不容易编辑。

	您通常不能手动编写或编辑 DAG-CBOR。
- 密度

	理论上，DAG-CBOR 的密度与 JSON 大致相当，因为它们在结构上相似。例如，如果一系列 map 具有重复的相同键，那么这些键将以 DAG-CBOR 序列形式重复，就像它们在 JSON 编码中一样。

	在实践中，DAG-CBOR 通常可以比 JSON 紧凑得多，因为它采用密集的二进制编码。（数字通常更小；布尔值是单个字节而不是四个或五个；字符串在内容需要转义时不会增加字节；等等）请注意，这是高度依赖于数据的；你的旅费可能会改变。

	在二进制内容方面，DAG-CBOR 与 JSON 或 DAG-JSON 相比尤其有利。在 DAG-JSON 和典型的 JSON 系统中，二进制内容是 base64 编码的，这导致了 33% 的扩展。在 DAG-CBOR 中没有这样的扩展。
- 简单

	CBOR，以及 DAG-CBOR，实施起来相当简单，而且规范明确。

	应该注意 DAG-CBOR 的一些细节，它们是 CBOR 的子集。例如，规范的 DAG-CBOR 应始终使用长度前缀，即使 CBOR 支持 map 和列表的“无限长度”模式。

	CBOR 包括一些位争用来实现，因为当长度很小时，类型指示符和长度指示符被组合成一个字节。这种机制被很好地指定并且通常被认为易于实现。

	CBOR 不需要执行任何转义例程；长度前缀解析就足够了。这使得 CBOR 比确实需要转义机制的编码系统更容易实现（并且排除了由于不正确地实现转义而引起的安全问题的可能性）。