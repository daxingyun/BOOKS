# 面向工程师的简洁、快速的 IPLD 入门
## 前言
这是一本简洁的入门书——目的只是介绍基本术语和范围，并为进一步理解提供良好的基础。读者可能仍需要从其他文档中寻求更多信息，或在支持渠道中提问，以充分了解如何使用（或为）IPLD 做出贡献。入门书应该只是为整合更多信息提供一个良好的基础。

关键术语以粗体标题大小写突出显示。这些是您应该能够在页面中“ctrl-f”以查找其他提及的术语。

假定熟悉某些计算机科学概念。例如，如果读者不熟悉“AST”的概念，则有必要在其他来源中查找它。
## 关键概念
### 核心：数据模型、编解码器和链接
- 数据模型
	- IPLD 数据模型就像数据的 “AST” ——但没有“S”；数据模型独立于语法。
	- IPLD 数据模型看起来和感觉起来大致像 JSON

		有用于构建嵌套结构的map和列表，以及字符串和布尔值等等。我们还添加了
		
		- 一个字节序列的概念
		- 和一个Link的概念（我们稍后会回来定义 Linking 和 Link）。
	- 保存在数据模型中的 IPLD 数据可以通过 `Codec` 编组为串行形式——反之亦然：序列化数据可以通过 `Codec` 解组为数据模型形式。
- 编解码器(Codecs)

	是可插拔的。IPLD 支持许多编解码器。一些常见的包括 JSON 和 CBOR 格式，但还有更多。编解码器的唯一限制是它必须生成和使用数据模型并与编解码器的串行格式进行交换。

	如果您心想“哇，那里有很多细节需要规范”，那您肯定是对的！在 [另一份文件](https://gist.github.com/warpfork/28f93bee7184a708223274583109f31c) 中有一篇关于 “编解码器和完整性” 主题的完整文章。

	- 可以获取序列化数据（例如Block）并通过（加密的）散列函数传递它。（这不是一个新想法，但我们应用了一个—— IPLD 没有发明散列；我们只是在这里确定一个重要事实。）由此产生的“散列”值可用作完整数据的速记标识符。
- 链接(link)
	- IPLD 中的链接是使用数据散列来完成的。一个 Link 指向一个 Block。（稍后将在下一节中详细介绍 `Blocks`。）
	- 由于链接基于加密哈希，因此可以制作无限大小的数据图（更具体地说是 DAG）并轻松引用其他子图。与 URL 或其他形式的“链接”不同，这无需任何中央名称注册机构即可工作——这很有用，因为这意味着任何人都可以创建链接数据并使用和遍历链接数据，无需协调：它完全离线工作。
	- IPLD 中的链接是使用称为 CID（C=内容 ID=实体 的缩写）的规范实现的。CID 既包含目标数据的哈希值，也包含一些有关解析时使用何种编解码器的信息，这意味着目标数据可以直接转换为`数据模型`(!)。

现在我们准备好发表关于 IPLD 目的的论文陈述：

- 鉴于 IPLD 库和规范，应该有可能在比其他方式少一个数量级的时间内生成一个 “像 git” 的新系统（因为它是内容寻址的、分散的和优秀的）。
- IPLD 采用所有必须做出的附带选择（但本身并不“重要”），例如
	- 编解码器的选择
	- 散列函数的选择等

	并将它们变成可插入的组件......这样你就可以开始在数据模型级别（重要的语义所在！）进行开发，然后再选择其余部分。
- 此外：其他人应该能够开发自己的程序来轻松地与您的数据进行交互：他们应该能够以数据模型为目标并且只担心数据的语义。编解码器和其他细节应该已经为他们处理好了，这样他们就可以快速开展业务。

### 块与节点
- 序列化数据的一个单元在 IPLD 中称为块。Marshalling 将数据模型变成一个 Block；解组将 Block 变成数据模型。
- 一个 `Link` 以一个 `Block` 为目标。（这必然是正确的，因为块是我们散列的粒度单位。）
- 数据模型由节点组成
	- 每个 map 都是一个节点；
	- 每个列表都是一个节点；
	- 每个字符串都是一个节点；
	- 每个布尔值都是一个节点；
	- 每个链接都是一个节点；ETC。
- 一个 `Block` 可能包含一个节点或一棵树中的多个节点 。
	- 举个例子
		- {"foo":"bar","baz":1} 有五个节点：
			- 一个 map 节点
			- 三个字符串节点（两个是 map 中的 key；一个是 value）
			- 一个int节点。
		- 你可以把所有的都放在 `{"foo":"bar","baz":1}` 一个Block中。
		- 您同样可以放入 `"a single long string"` 一个Block。
		- 请注意，单个 Block 不能包含多于一棵未连接的节点树。
### 路径 Pathing
- 拥有标准化数据模型的一个关键好处是我们可以在其上定义路径——路径是一种简单的文本描述，说明如何从数据模型中的一个节点移动到另一个子节点（或孙节点，等）
- Path 由 `PathSegment` 组成。
- 每个 `PathSegment` 要么是遍历地图的键，要么是遍历列表的索引。
- Path 是 1->1 的东西

	它们从 DAG 中的一个位置开始，让你到达单一的目的地位置。如果你想要访问图中许多节点的东西，而不是只有一个目的地，你需要 `Selectors`。
- IPLD 中的路径也可以透明地跨越 `Link`

	这意味着 `Path` 可以让你在大数据图中的任何地方。
- IPLD 中的路径不包含 “ ..”（意思是“向上一个”）的概念，因为这并不总是 DAG 中定义的操作。（还因为“ ..” 是一个完全有效的地图键！）
	- 要理解这怎么可能是模棱两可的，请考虑一个场景，其中多个 Block 由 Links 连接：
		- 如果 “..” 段位于一个 Block 内，则足够清楚；
		- 但是如果它指向一个块之外……除了回头看看你所遵循的路径并砍掉一段之外，没有办法解释它。因此，不妨先相应地处理路径。
- CID 和 Path 的组合是一种上下文无关的方式，可以通过 IPLD 引用任何清晰的信息。（这有时被称为 “merklepath”。）

### 高级解释
由于它们的实用性，我们在 IPLD 中引入了两种更 “高级” 的解释信息的方法：

- Schemas
- 和ADLs（高级数据布局的缩写）。

这两个高级解释系统仍然将它们的数据呈现为数据模型——因此 `Pathing` 和所有其他核心 IPLD 概念仍然适用于它们！

### Schemas
- Schema 提供了对开发人员友好的方式来描述程序想要处理的数据结构的概要。
	- 这为 IPLD 提供了一种有用的“设计语言”！
	- 隐含地，它还描述了在尝试处理与此结构大纲不匹配的数据时可能生成的错误。
- 模式描述了两件事：1、类型信息与语义有关 2、和表示信息与信息在数据模型级别的表示方式有关。
	- 将这两件事分开意味着 Schema 可以用来描述 IPLD 中的任何东西，即使它是在没有使用 Schemas 的情况下创建的。
	- 事实上，Schema 甚至可以有效地描述完全没有 IPLD 创建的数据。
	- Schemas 层与 Codecs 干净利落。您可以描述数据的语义......并单独选择一个编解码器。
- Schema 支持的“类型”的种类与数据模型中的“种类”（map、列表、字符串等）相同......再加上一些：“struct”、“union”（也称为求和类型） )、“枚举”等
- Schema 支持每种类型的多种可能表示。
	- 例如，“结构”类型的默认表示只是一个“map”，其中键是结构字段的名称。
	- 但是相反，该“结构”的表示也可以是“元组”模式（意味着表示将是数据模型理解中的“列表”）。在这种情况下，结构字段名称根本不存在于表示中。
	- 一些表示策略包含更多冗余数据（这意味着它们更容易“眼球”并在没有模式的情况下理解！）；其他人则倾向于更高的熵（这意味着“目测”它可能变得不切实际，并且可能需要一个模式才能完全理解它们）。我们将 schemaless 和 schemafull 系统变成梯度：你可以选择你想要在梯度上的位置（并根据每种类型改变选择——例如，可以从无模式数据开始一个大数据图，然后使用越来越紧凑/图中更深层次数据的高熵/模式完整表示）。
- 每个Schema 类型也有一种被定义为数据模型的方式——因此，您始终可以像对原始数据一样对已解析的 Schema 数据应用 Pathing 等概念。只是会有点不同。
	- 例如：你可以有一个带有元组表示的结构，它会像一个“地图”一样......同时它的表示是一个“列表”。您可以根据自己的选择遍历任一数据视图并执行Pathing 。
- 重要的是要注意 Schema 不是图灵完备的。事实上，它们甚至并不接近。已经做出了相当大的努力来保持决定数据是否“匹配”模式所需的计算量最小，并且最多与模式的复杂性成比例（反过来可以通过其纯粹的松散近似文本大小）。
- 因为确定 Schema 是否“匹配”数据所需的计算量很小，所以可以通过简单地连续尝试多个 Schemas 来构建版本检测和功能检测。
- 由于上述原因，没有必要在文档中嵌入对架构的引用。事实上，最好不要：显式版本控制是脆弱的；特征检测允许平稳生长和自然进化。
- Schema 恰好为代码生成工具提供了一个非常有用的输入，它可以生成非常快速的代码来处理 Schema 描述的结构。

### ADLs
ADL 是 Advanced Data Layout 的缩写。

ADL 的目的是使数据作为数据模型节点清晰易读——而且，它与 Codec 不同，因为原始输入也是数据模型（尽管它可能是一个节点或多个节点；输入甚至可能跨越多个块）。

就我们用它们解决的一些问题而言，理解 ADL 可能是最容易的：

- 拥有大地图很重要。

	这方面的一个例子是类似文件系统的应用程序中的目录。当我们想要的地图可能比单个 Block 所能容纳的更大时，我们使用 ADL！特别是，“HAMT” 是我们为此目的制作和推荐的 ADL。HAMT 将地图数据拆分成许多块，有点像 B+ 树，但将整个事物呈现为单个地图，符合所有数据模型节点接口，因此您可以正常对其进行编程。
- 拥有大字节序列很重要。

	其中一个例子就是存储文件！当我们想要存储一个字节序列，该字节序列可能比可以合理地适合单个 Block 的字节序列大时，我们使用 ADL！特别是，“FBL”是我们为此目的制作和推荐的 ADL。FBL 可以将字节序列拆分成多个块，有点像 B+ 树，但将整个事物呈现为单个连续的字节序列，符合所有数据模型节点接口，因此您可以正常地对其进行编程。
- 加密数据很整洁。

	我们怀疑 ADL 适合描述这一点，并使加密在 IPLD 中顺利运行，而无需将任何特定算法或构造放入 IPLD（这会使它们更难创新和更改）。但是，我们还没有任何完整的例子。

与 `Schema` 相比，ADL 支持数据的拓扑转换。因为拓扑变换没有明显的方法来限制计算成本，所以我们放弃了使 ADL 小于图灵完备。

- 因此，我们选择将 ADL 作为“插件”系统来实现：它们通常是用宿主语言编写的，并且必须在每个 IPLD 库中重新实现。
- 将来，可能会引入某种 “字节码” 或 “IR”，允许对 ADL 进行更多可移植定义，但尚未指定此类系统。
- ADL 与 Schema 不同，
	- 因为 Schema 的有限计算成本使它们适合使用 “尝试堆栈” 进行 “特征检测”；
	- 使用 ADL 执行此操作将是不可预测的。
- 由于 ADL 将原始数据模型作为输入，这就提出了一个问题，即我们如何决定是否将 ADL 用于某些数据。我们称之为“信号问题”。
	- 信号问题的一种解决方案是 “使用模式提供信号”。
	- 可以使用其他信令机制。（但是目前还没有很多示例或完整的规范。）

### 还有更多的东西
- Selectors

	选择器是一种声明式格式，用于指定 DAG 遍历，既说明要遍历图形的哪些部分，又提供一种将某些节点标记为突出显示的方法。有一个用于表达选择器的标准化数据模型树结构（实际上，它由 Schema 指定），并且大多数 IPLD 库将提供一个本地函数来评估它们（通常这涉及访问 “突出显示” 节点的回调）。
- Graphsync

	是一种建立在 Selectors 之上的协议，旨在允许两个或多个通信代理有效地交换 Block 数据：通过描述他们对交换的图形的哪些部分感兴趣，通信组所需的往返次数相关 Block 的数量可以大大减少。
	
### 总结
现在应该清楚了：数据模型节点接口比数据模型本身的重量要大得多：

- 它还定义了模式系统和 ADL 的必要（并且在许多方面是可能的）行为; 
- Codec 完全是根据它来定义的；
- 它也是所有 Pathing 和其他形式的遍历（例如 Selectors ）的中心。

## 使用 IPLD 完成工作
（在文档的另一章中有[更完整的文档](https://ipld.io/docs/synthesis/gtd/)。）

长话短说：

- 首先尝试使用普通数据模型来做事。
- 如果您希望为您的数据结构提供更严格的辅助工具，请尝试 `Schema`。
- 如果您需要在将数据视为数据模型之前进行多块数据结构或其他一些有趣的数据解释，那么请使用ADL。（但要明智地这样做：对于没有您的 ADL 代码的客户来说，您的数据将变得难以理解。使用通用的 ADL 总是比发明一个新的更好。）
- 作为最后的手段

	你可以发明一个新的 `Codec`。如果您需要将二进制形式的数据处理成数据模型，而 IPLD 以前从未有过这种二进制格式的编解码器，那么这就是您所需要的。（但真正这样做只是作为最后的手段：理想情况下，这样做只是为了将其他遗留格式桥接到 IPLD 中；新项目应该能够首先通过数据模型表达它们的逻辑，然后选择一个适合的编解码器，关闭架子，无需额外的开发工作！）

## 更好的点
- 字符串实际上只是字节,它们可以包含相同范围的数据（任何数据）。然而，字符串暗示着它们是人类可读的。
	- 字符串往往被各种表示层和面向用户的工具以及调试表示以不同方式对待。
	- 字符串和字节在许多 Codec 中也被明确地序列化。
- map 有一个稳定的、定义好的迭代顺序。但这不一定是排序的顺序。
	- 这是必然的情况，因为某些 ADL（实际上，特别是 HAMT）具有自然的迭代顺序，并且实现任何其他迭代顺序都将非常昂贵，而且该顺序不是排序顺序。
	- 某些 Codec 指定排序顺序。如果他们这样做，请注意这是编解码器的选择；
		- 数据模型更具表现力，因为它可以保留任何顺序。
		- 列表并不稀疏。（尽管没有什么能阻止 ADL 做出这样的事情。）
- map 键是字符串。
	- 不是字节。（但请记住，字符串和字节之间的区别主要在于解释。从本质上讲，该语句意味着：map 键被视为可打印。）
	- 不是整数。（这会使库显着复杂化并且不受许多编解码器的支持，并且会给想要制作人类可读的数据表示的工具带来很大的歧义。）
- 无法区分 `PathSegment` 是字符串（用于 map 键）还是整数（用于列表索引）。它由应用它的数据决定。
- 某些 `PathSegment` 在连接到 `Path` 时确实需要转义。 
	- Path 通常使用 “/” 作为分隔符进行编码；
	- 但是，“/” 也是 map 中的有效键（毕竟它只是另一个常规字符串！）；因此，对于某些值可能需要转义。