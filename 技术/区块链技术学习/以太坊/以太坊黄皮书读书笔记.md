# 以太坊黄皮书读书笔记
- Address(地址)

	用于识别帐户的 160 位代码。
- Account(帐户)

	帐户具有作为以太坊状态的一部分维护的内在余额和交易计数。

	它们还有一些（可能是空的）EVM 代码和一个（可能是空的）与之相关的存储状态。虽然是同质的，但区分两种实际类型的账户是有意义的：
	
	- 那些关联 EVM 代码为空的账户（因此账户余额由某个外部实体控制，如果有的话）
	- 非空关联 EVM 代码的账户（因此帐户代表一个自治对象）。每个帐户都有一个标识它的地址。
- Transaction(交易)

	一条数据，由外部参与者签名。它代表一个消息或一个新的自治对象。交易记录在区块链的每个区块中。
- Autonomous Object(自治对象)

	仅存在于以太坊的假设状态中的概念对象。有一个固有地址，因此有一个关联的帐户；该帐户将具有非空的关联 EVM 代码。仅作为该帐户的存储状态合并。
- Storage State(存储状态)

	特定于给定账户的信息，在账户关联的 EVM 代码运行期间维护。
- Message(消息)

	通过自治对象的确定性操作或交易的加密安全签名在两个账户之间传递的数据（作为一组字节）和值（指定为以太）。
- Message Call(消息调用)

	将消息从一个帐户传递到另一个帐户的行为。如果目标帐户与非空 EVM 代码相关联，则 VM 将以所述对象的状态和所作用的消息启动。如果消息发送者是自治对象，则调用会传递从 VM 操作返回的任何数据。
- Gas(天然气)

	基本的网络成本单位。完全由 Ether 支付（从 PoC-4 开始），它可以根据需要自由转换为 Gas。 Gas 不存在于以太坊内部计算引擎之外；其价格由交易设定，矿工可以随意忽略 Gas 价格过低的交易。
	
	为了避免网络滥用及回避由于图灵完整性而带来的一些不可避免的问题，在以太坊中所有的程序执行都需要费用。 各种操作费用以 gas 为单位计算。消耗 Gas 包括

	- 合约创建
	- 消息调用
	- 分配资源
	- 访问账户 storage
	- 在虚拟机上执行操作等

	交易都要指定一个 gas 上限：`gasLimit`，这些 gas 会从发送者的账户的 `balance` 中扣除。Gas 的购买是通过同样在交易中指定的 `gasPrice` 来完成的。如果这个账户的 `balance` 不能支持这样的购买，交易会被视为无效交易。之所以将其命名为 `gasLimit`，是因为剩余的 gas 会在交易完成后被返还（与购买时同样价格）到发送者账户。Gas 不会在交易执行之外存在，因此对于可信任的账户，可以设置一个相对较高的 gas 上限。
	
	未返还的部分就会移交到 `beneficiary` 的地址（即一般由矿工所控制的一个账户地址）。交易者可以随意指定 `gasPrice`，然而矿工也可以任意地忽略某个交易。一个高 gas 价格的交易将花费发送者更多的以太币，也就将移交给矿工更多的以太币，因此这个交易自然会被更多的矿工选择打包进区块。通常来说，矿工会选择公告他们执行交易的最低 gas 价格，交易者们也就可以据此来提供一个具体的价格。因此，会有一个（加权的）最低的可接受 gas 价格分布，交易者们则需要在降低 gas 价格和使交易能最快地被矿工打包间进行权衡
	
	- Gas 扣费的3种情况
		- 计算操作费用
		- 执行一个低级别的消息调用或者合约创建，CREATE，CALL 和 CALLCODE
		- 存储
			- 内存
	
				内存使用的增加也会消耗一定的 Gas，对于一个账户的执行内存的总费用和其所有内存索引 （无论是读还是写）的范围成正比；这个内存范围是 32 字节的最小倍数。 这是实时（just-in-time）结算的；也就是说，任何对超出先前已索引的内存区域的访问，都会实时地结算为额外的内存使用费。由于这个费用，内存地址大概不会超过 32 位的界限，但 EVM 的实现必须能够管理这种可能性（就是说，虽然如果内存地址超过 32 位，即大于 2 <sup>32</sup> ， 会产生很高的内存使用费，但 EVM 的实现还是应该支持这种可能性；校订注）。 
			- 存储
	
				为了奖励存储最小化，清除一个存储中的记录项的执行费用不仅被免除，而且会返还 Gas

				存储费用则有一个细微差别的行为——激励存储的最小化使用（这直接反映在所有节点中更大的状态数据库里）。 清除一个存储中的记录项的执行费用不仅被免除了， 而且还会返还；实际上，这种费用返还（退款）是预先发生的， 因为首次使用存储位置的费用比正常使用高出很多。 EVM gas 消耗的严格定义

- Object(对象)

	自治对象的同义词。
- App(应用程序)

	托管在以太坊浏览器中的最终用户可见应用程序。
- Ethereum Browser(以太坊浏览器)

	（又名以太坊参考客户端）界面类似于简化浏览器（如 Chrome）的跨平台 GUI，能够托管后端完全基于以太坊协议的沙盒应用程序。
- Ethereum Virtual Machine(以太坊虚拟机)
	- 简介
	
		（又名 EVM）构成账户相关 EVM 代码执行模型关键部分的虚拟机。它实现了如何使用一系列的字节代码指令和一个环境数据的元组去更改系统状态。这是通过一个正规的虚拟状态机来实现的，也就是以太坊虚拟机（Ethereum Virtual Machine - EVM）。它是一个准图灵机，这个“准”的限定来源于其中的运算是通过参数 gas 来限制的，也就是限定了可以执行的运算总量。
		
		EVM 是一个简单的基于栈的架构。 其中
		
		- 字 （Word）的大小（也就是栈中数据项的大小）是 256 位。这是为了便于执行 Keccak-256 位哈希和椭圆曲线计算。
		- 内存（memory）模型是简单地基于字寻址（word-addressed） 的字节数组。
		- 栈的最大深度为 1024
		- EVM 也有一个独立的存储（storage）模型；它类似于内存的概念，但并不是一个字节数组，而是一个基于字寻址（word-addressable）的字数组（word array）。与不稳定的内存不同，存储是相对稳定的且作为系统状态的一部分被维护。 所有内存和存储中的数据都会初始化为 0。 
	
		EVM 不是标准的冯诺依曼结构。 程序代码被保存在一个独立的、仅能通过特定的指令进行交互的虚拟 ROM（即只读存储器，校订注）中，而不是保存在一般的可访问内存或存储中。 EVM 存在异常执行的情况，包括堆栈溢出和非法指令。 在发生像 `out-of-gas` 这样的异常时，EVM 并不会使状态保持原样，而是会立即停止执行，并告知执行代理（交易的处理程序或递归的执行环境），由代理来独立处理这些异常。

- Ethereum Runtime Environment(以太坊运行时环境)

	（又名 ERE）提供给在 EVM 中执行的自治对象的环境。包括 EVM，还包括 EVM 依赖于某些 I/O 指令（包括 CALL 和 CREATE）的世界状态的结构。执行环境需要重要的信息包括：
	
	- 拥有正在执行的代码的账户地址
	-  触发这次执行的初始交易的发送者地址
	-  触发这次执行的初始交易的 gas 价格
	-  这次执行的输入数据字节数组；如果执行代理是一个交易，这就是交易数据。
	-  触发这次执行的账户地址；如果执行代理是一个交易，则为交易发送者地址。
	-  作为这次执行的一部分传到当前账户的转账金额，以 Wei 为单位；如果执行代理是一个交易, 这就是交易的转账金额。
	-  所要执行的机器代码字节数组。
	-  当前区块的区块头。
	- 当前消息调用或合约创建的深度（也就是当前已经被执行的 CALL 或 CREATE 的数量）
	- 修改状态的许可

	EVM 执行模型执行模型定义了函数，可以用来计算范围包括

	- 结果状态 
	- 剩余的 gas
	- 累积的子状态
		- 自毁集合 
		- 日志集 
		- 接触过的账户 
		- 返还金额  
	- 结果输出
		- 异常
			- `out-of-gas，OOG`
	
				代码执行会消耗 gas， 且 gas 不能低于 0， 因此执行可能会在自然停止之前结束。在这个（以及其它几个）异常情况，我们称之为发生了 gas 不足（out-of-gas，OOG）异常： 计算后的状态将由空集合表示，整个创建操作将不会影响状态，就像刚开始尝试创建时那样。发生这样的异常后，剩余 gas 将变为 0。也就是说，如果合约创建是作为对交易的接受来处理的， 那么它就不会影响合约创建的固有费用的支付，就是肯定会支付。然而，当 gas 不足时，交易中附带的金额并不会转移到被取消的合约地址。
			- 堆栈溢出
			- 无效的跳转目标，指令 JUMP/JUMPI 的目标无效，所以跳转地址需要提前验证
				- 验证
	
					 我们先前使用 D 函数来判断正在运行的代码所给定的有效跳转地址集合。我们以 JUMPDEST 指令所使用的位置来定义它。所有这些跳转位置都必须在有效的指令块内，而不可以是 PUSH 操作的数据中的位置；并且这些跳转位置还必须在明确定义的代码中（而不是使用隐式定义的 STOP 指令所跟踪到的位置） 
			- 无效的指令	
			- 栈中的条目不足
			- 新栈的大小超过 1024 
			- 或者在一个静态调用中去尝试修改状态
	
			注意：没有任何一个指令可以通过它的执行直接触发异常停止
		- 正常
	
			如果没有出现这样的异常，那么剩余的 gas 会返还给最原始的交易发起人，对状态的改变也将永久保存。这样，我们可以指定结果状态、gas、子状态和状态代码
			
			- 停止

				会返回数据的停止操作 RETURN 和 REVERT 有一个特殊的函数 H <sub>RETURN</sub>
			- 循环

				栈中的条目是在序列的最左侧以低位索引的方式添加或移除的，所有其它条目都不会变动，其中，gas 会根据具体指令的 gas 消耗相应扣除，且除了下面的三个特例以外，对于大多数指令而言，每次循环， 程序计数器都会自动增加；

				在一般情况下，我们假定内存、自毁集合和系统状态不会改变。然而， 具体的指令通常会改变这些值中的一个或几个。附录 H 中列出了指令会更改的元素以及入栈数、出栈数和对 gas 需求的正式描述。
- EVM Code(EVM 代码)

	EVM 可以本地执行的字节码。用于正式指定消息到帐户的含义和后果。
- EVM Assembly(EVM 程序集)

	EVM 代码的人类可读形式。
- LLL

	类 Lisp 的低级语言，一种人类可写的语言，用于编写简单的合约和用于反编译的通用低级语言工具包。
- The Genesis Block(创世区块）

	区块链上第一个块，俗称创世区块，由开发者程序创建，写死
- Ether(以太)

	以太坊货币单位，1个以太等于10<sup>18</sup>  Wei，而 Wei 是以太坊最小的货币单位
- RLP 编码
- POW

	挖矿工作量证明（PoW）通过一个密码学安全的 nonce 来证明为了获得一些象征性的值 n，已经付出了一定量的计算。我们使用它并通过特定意义的难度（且可以扩展为总体难度）以及对难度的可信度认知来确保区块链的安全。然而，因为挖出新的区块会得到其附带的奖励， 所以工作量证明不仅是在未来使区块链的权威的获得保障的安全信任方法，同时也是一个利益分配机制。 出于以上原因，工作量证明函数有两个重要的目标：

	- 首先，它应该尽可能的被更多人去接受。

		对特别定制的硬件的需求或由这种硬件所提供的回报应该被减到最小。这使得分配模型尽可能开放， 从而使世界各地的人们都可以以大 致相同的比例，通过电力消耗获得以太币。 
	- 第二，应该不允许获得超线性的收益，尤其是在有一个很高的初始障碍条件下。

		否则，一个资金充足的恶意者可以获得引起麻烦的网络挖矿算力， 并允许他们获得超线性的回报（按他们的意愿改变收益分布），这也就会弱化网络的安全性。 
	
	比特币世界中一个灾难是 ASIC。 有一些计算硬件仅仅是为了做一个简单的任务而存在（Smith [1997]）。在比特币中， 这个任务就是 SHA256 哈希函数（Courtois et al.[2014]）。当 ASIC 们为了工作量证明函数而存在时，所有的目标都会变得危险。因此，一个可抵抗 ASIC 的工作量证明函数（也就是难以在专用硬件上执行或者在专用硬件执行时并不划算）就可以作为谚语中的银弹。
	
	ASIC 抗性的设计有两个方向：
	
	- 第一是去让它成为内存困难（memory-hard）的问题所产生结果

		即设计一个需要大量的内存和带宽，来使这些内存不能被用于并行地计算 nonce。 
	- 第二个方向是让计算变得更有通用目的（general-purpose）

		一个为通用目的“定制的硬件”的意思，就是使得类似于普通的桌面计算机这样的硬件可以适合这种计算。 
	
	在以太坊 1.0 中选择了第一个方向。PoW 是工作量证明函数，可以得到一个数组，其中
	
	- 第一个元素是 mixHash
	- 第二个元素是密码学依赖于 H 和 d 的伪随机数
- Ethash

	Ethash 是以太坊 1.0 的 PoW 算法。 它是 Dagger-Hashimoto 的最新版本，由 Buterin [2013b] 和 Dryja [2014] 提出。因为原始算法中的很多特性都在 2015 年 2 月到 5 月 4 日的研发（Jentzsch [2015]）中被修改了， 所以再这么称呼它其实已经不太合适。 这个算法的大体路线如下： 

	- 我们通过扫描区块头来为每个区块计算得到一个种子
	- 根据种子我们可以得到一个初始大小为 J <sub>cacheinit</sub>  字节的伪随机 cache 
		- 轻客户端可以保存这个 cache 
	- 根据 cacheinit 我们可以生成一个初始大小为 J <sub>datasetinit</sub> 字节的数据集， 数据集中的每个条目仅依赖于 cache 中的一小部分条目。
		- 全节点客户端和矿工保存整个数据集
		- 数据集会随时间线性增长 
	- 挖矿则是在数据集中选取随机的部分并将他们一起哈希
	
		可以根据 cache 仅生成验证所需的部分，这样就可以使用少量内存完整验证，所以对于验证来讲，仅需要保存 cache 即可。
	
	而大数据集则每 J <sub>epoch</sub> 个区块更新一次，所以大多数矿工的工作都只是读取这个数据集，而不是改变它。以上提及的参数和算法的详细解释参见附录 J。
- Ommers(叔区块)

	ommer 是一个区块，它的父区块相当于当前区块的父块的父块，由于以太坊的构建方式，出块时间比其他区块链更短，比如它约15秒/区块，而比特币的出块时间是10分钟/区块。这让它拥有更快的交易速度。然而，更短出块时间的一个不足之处是矿工会发现有更多的竞争区块。这些竞争区块也称为“孤块”（即所挖出的区块并没有进入主链）。
	
	ommers 的目的是帮助奖励矿工包括这些孤块。矿工包含的 ommers 必须是“有效”的，意味着当前区块的六代之内或更小范围内。在六代之后，老旧的孤块不再被引用，因为包括较老的交易会让事情变复杂。Ommer 区块获得的奖励比全区块要少。尽管如此，对矿工来说，这依然有激励，让他们把这些孤块包括进来，由此收获奖励。
	
	ommers 的主要目的就是为了将废掉的算力，但是合法算力利用起来，这样整体区块就更安全
- world-state(世界状态)
	- 世界状态是分两种映射
		- 地址（160 位的标识符）
		- 账户状态（序列化为 RLP 的数据结构，详见附录 B） 
	- 世界状态结构描述
		
		世界状态没有直接储存在区块链上，但会假定在实施过程中会将这个映射维护在一个修改过的 `Merkle Patricia` 树上，即 trie。这个 trie 需要一个简单的后端数据库去维护字节数组到字节数组的映射，我们称这个后端数据库为状态数据库。
		
		它包含2个好处
		
		- 第一，这个结构的根节点是基于密码学依赖于所有内部数据的,它的哈希可以作为整个系统状态的一个安全标识；
		- 第二，作为一个不变的数据结构，我们可以通过简单地改变根节点哈希来查找任何一个先前的状态（在根节点哈希已知的条件下）。
	
		因为在区块链中储存了所以这样的根节点哈希值，所以我们可以很容易地恢复到特定的历史状态
		
		- 阅读理解

			简单的理解以下几点
			
			- 所谓世界状态，其实就是一个索引库，数据本身没有上链，而由节点代码提供的数据库维护，称为状态数据库，提供2个好处，
				- 基于hash机制的安全标识
				- 提供不可变的数据结构，可以通过 hash 查询来得到以下结果 
	- 账户状态包含以下四个字段：
		- `nonce`
		
			这个值等于由此账户地址发出的交易数量或者由这个账户所创建的合约数量（当这个账户有关联代码时）。 
		- `balance`
		
			表示这个账户地址拥有多少 Wei（即账户余额，译者注）。 
		- `storageRoot` 
		
			保存了账户的存储内容的 Merkle Patricia 树的根节点的 256 位哈希值，这个树中保存的是 256 位整数键值的 Keccak 256 位哈希值到 256 位整数值的 RLP 编码的映射。
		- `codeHash`
		
			这个账户的 EVM 代码哈希值(智能合约 hash)，如果 `codeHash` 字段是一个空字符串的 `Keccak-256` 哈希，那么这个节点则表示一个简单账户，有时简称为“非合约”账户。
			
			当这个地址接收到一个消息调用时，这些代码会被执行； 它和其它字段不同，创建后不可更改。状态数据库中包含所有这样的代码片段哈希， 以便后续使用。  
		
		注意，如果一个账户没有代码，它将是 empty（空的），且 `nonce` 和 `balance` 均为 0。所谓的预编译合约也可能处于 empty 状态。这是因为它们的账户状态并不总是包含可以表述它们的行为的代码。 而当一个账户的状态不存在或为 empty 时，就表示它 dead （死了）
- machine-state(机器状态)

	机器状态是由一个元组所定义的，其中包括

	- 可用的 gas
	- 程序计数器
	- 内存的内容

		内存的内容是大小为 2 <sub>256</sub> 的全 0 序列。 为了提高可读性，应该使用大写字母简写（例如 ADD） 的指令助记符来推演数字等式。 完整的指令列表和它们的 定义参见附录 H。 
	- 内存中激活的字数（从 0 开始的连续计数）
	- 以及栈的内容

		我们也假定从栈中移除和添加的条目的固定数量为 δ 和 α， 它们都可以作为具体指令的下标；并且指令费用函数可以算出给定指令的全部费用（以 gas 为单位）。
- transaction(交易)	

	交易是个单一的加密学签名的指令。

	通常由以太坊系统之外的操作者创建。 假设外部的操作者是人(当然也可能是合约)，而软件工具的作用则于构建和散播这个签名 。
	
	- 交易有两种类型：
		- 一种表现为消息调用
		- 另一种则通过代码创建新的账户（称为“合约创建”）
	- 两种交易类型一些共同的字段
		- `nonce`
		
			由交易发送者发出的的交易的数量？？
		- `gasPrice`
		
			为执行这个交易所需要进行的计算步骤消耗的每单位 gas 的价格，以 Wei 为单位 
		- `gasLimit` 
		
			用于执行这个交易的最大 gas 数量。这个值须在交易开始前设置，且设定后不能再增加，如果超过交易所需，则会退还
		- `to`
		
			160 位的消息调用接收者地址；对与合约创建交易，标识唯一成员
		- `value`
		
			转移到接收者账户的 Wei 的数量；对于合约创建， 则代表给新建合约地址的初始捐款。 
		- `v, r, s`
		
			与交易签名相符的若干数值，用于确定交易的发送者
	- 合约创建类型还包含额外字段
		- `init`
		
			一个不限制大小的字节数组， 用来指定账户"初始化程序"的 EVM 代码，就是合约初始化代码。 
			
			- `init` 执行后的返回结果 body，就是合约代码，这是这个账户每次接收到"消息"调用时会执行的代码（通过一个交易或者代码的内部执行）。
			- `init` 代码仅会在合约创建时被执行一次，然后就会被丢弃。 
	- 消息调用交易包含的额外字段
		- `data` 

			一个不限制大小的字节数组，用来指定消息调用的输入数据
	
	交易到发送者的映射通过 `SECP-256k1` 曲线的 ECDSA 算法实现，使用交易哈希（除去后 3 个签名字段）作为数据来进行签名。假设除了任意长度的字节数组以外，所有变量都是作为整数来进行 RLP 编码的。
	
	地址哈希稍微有些不同：它是一个 20 字节的地址哈希值或者当创建合约时是 RLP 空字节序列
	
	- 交易前的检查包括
		- (1) 交易是 RLP 格式数据，没有多余的后缀字节；
		- (2) 交易的签名是有效的；
		- (3) 交易的 nonce 是有效的（等于发送者账户当前的 nonce）；
		- (4) gas 上限不小于交易所要使用的 gas;
		- (5) 发送者账户的 balance 应该不少于实际费用 v 0 ，且需要提前支付。
	- 检查状态

		计算依赖于交易的类型。不管它是合约创建还是消息调用，我们都可以定义这样的元组，包含
		
		- 执行后的临时状态
		- 剩余的 gas

			是扣除掉合约存在所需要的基本 gas 数量之后的剩余 gas 数量
		- 子状态
		- 状态代码 
	- 执行
		- 定义固有的 gas 消耗并在交易执行前支付
		- 交易附带的关联数据的字节序列和 EVM 初始化代码的字节序列，取决于交易是合约创建还是消息调用
		- 预支付的费用计算
		- 检查有效性
	- 交易过程
		- 在消息调用或合约创建被处理之后，在此过程中自毁的账户的返还余额计数也已经增加完成了
		- 然后，就可以用剩余的 gas 加上基于返还计数的补贴来按照原始比率确定返还给发送者的 gas
		- 交易花费的 gas 所对应的以太币会支付给矿工,它们的地址是由当前区块 B 的 beneficiary 所指定
		- 在删除了所有出现在自毁列表中的账户或被接触过的空账户之后，即可达到最终状态
	- 交易后的状态

		这些用来帮助我们定义交易收据， 并且也将用在后续的状态和 nonce 校验中
		
		- 交易执行所消耗的 gas 数量；
		- 交易过程中累积产生的日志项；
		- 交易结果的状态代码
	- 其他 
		- 子状态
	
			交易的执行过程中会累积产生一些特定的信息，我们称为交易子状态，它是个元组
			
			元组内容包括 
	
			- 自毁集合
	
				一组应该在交易完成后被删除的账户。
			-  一系列的日志
	
				这是一些列针对 VM 代码执行的归档的、可索引的‘检查点’，允许以太坊世界的外部旁观者（例如去中心化应用的前端）来简单地跟踪合约调用。 
			-  交易所接触过的账户集合，其中的空账户可以在交易结束时删除。
			-  应该返还的余额；
	
				当使用 SSTORE 指令将非 0 的合约 storage 重置为 0 时，这个余额会增加。虽然不是立即返还的余额，但可以部分抵消整体执行费用。
			
			空的子状态的定义是，它没有自毁、没有日志、没有接触过的账户且返还余额为 0
		- 交易 gas 上限
			
			交易的 gas 上限所给定的这个区块先前已经使用的 gas 数量之和，但不可以超过当前区块的 gasLimit
		- 有效交易
	
			有效交易的执行起始于一个对状态不能撤回的改变
			
			- 发送者账户的 `nonce` 会加 1	
			- 并且从账户余额扣减预付费用
	
			无论是合约创建还是消息调用，计算都会产生一个最终状态（可能等于当前的状态），这种改变是确定的且从来不会无效：这样来看，其实并不存在无效的交易。
		- 交易原始发起人 
		
			当一个消息调用或合约创建不是由交易所触发，而是来自于 EVM 代码的运行所触发时，这个原始发起人会与发送者不同
- 消息调用

	当执行消息调用时需要多个参数：
	
	- 发送者
	- 交易发起人
	- 接收者
	- 执行代码的账户（通常与接收者相同）
	- gas limit
	- 转账金额
	- gas 价格
	- 函数调用的输入数据（一个任意长度的字节数组 ）
	- 消息调用/合约创建的当前栈深度（高度）
	- 对状态修改的许可
	
	除了可以获得新的状态和交易子状态以外，消息调用还有一个额外的元素——由字节数组表示的输出数据。执行交易时的输出数据是被忽略的，但消息调用可以由 VM 代码执行所产生，在这种情况下就将使用这些信息。

	在消息调用的通用执行框架 `Ξ` 中有 8 个特例：这是 8 个所谓的‘预编译’合约，它们作为最初架构中的一部分，后续可能会变成原生扩展
	
	- 椭圆曲线公钥恢复函数
	- SHA2 256 位哈希方案
	- RIPEMD 160 位哈希方案
	- 标识函数
	- 任意精度的模幂运算
	- 椭圆曲线加法
	- 椭圆曲线纯量乘法
	- 椭圆曲线配对检查
- Contract(合约)

	非正式术语，用于表示可能与帐户或自治对象相关联的一段 EVM 代码。
	
	- 合约创建

		创建一个合约账户需要很多固有参数：

		- 发送者
		- 原始交易人
		- 可用的 gas
		- gas 价格
		- endowment（即初始捐款）
		- 任意长度的字节数组(int)，即 EVM 初始化代码,注意不是合约运行代码，它运行的结果才是合约运行代码
		-  消息调用/合约创建的当前栈深度
		-  对状态进行修改的许可

		我们定义创建函数，它将使用上述参数和状态一起来计算出一个新的元组。这个新的元组包含
		
		- 新的状态
		- 剩余的 gas
		- 交易子状态
		- 以及一个错误消息

		如果这个初始化代码成功地执行完，那么对应的合约创建费用也会支付。这个代码保存费用与创建出来的合约代码大小成正比
		
		对于确定 `σ ′` 的例外， 由初始化代码的执行结果字节序列 o 所决定，它就是新创建账户的最终代码。 注意， 这是意图达到这样的结果：

		- 要么带着初始捐款 （endowment）成功创建合约；
		- 要么不会创建任何合约且不会进行转账。

		注意: 在初始化代码执行过程中，一个新创建的地址会出现，但还没有内部的代码。因此在这段时间内，任何消息调用都不会引发代码执行。如果这个初始化执行结束于一个自毁指令，那么这个账户会在交易完成前被删除，这种情况是否合理已在讨论中。对于一个正常的 STOP 指令代码或者返回的代码是空的，这时候会出现一个僵尸账户， 而且账户中剩余的余额将被永远地锁定在这个僵尸账户中
	- 合约地址
	
		新账户的地址是一个哈希值的最右边 160 位，这个哈希值是由一个仅包含发送者地址和其账户 nonce 的结构进行 RLP 编码之后再进行 Keccak 哈希计算所得到的。
	
		我们使用的是一个比发送者 nonce 要小的值（减了 1）；因为我们认定已经在这个调用之前对发送者的 nonce 加了 1，因此所用的值是发送者在该交易或 VM 操作开始时的 nonce。

		- 合约账户的 nonce 被初始定义为 1
		- balance 为交易传入的值
		- storage 为空
		- codeHash 为空字符串的 Keccak 256 位哈希值
		- 发送者的 balance 会减去转账值
	
		合约账户是根据执行模型（参见第 9 章）通过执行合约账户初始化的 EVM 代码初始化的。代码的执行可以产生一些内部执行状态以外的事件，包括：

		- 更改账户的 storage
		- 创建更多的账户
		- 以及进行更多的消息调用

		用代码执行函数 `Ξ` 可以得到一个元组，包括
		
		- 结果状态
		- 可用的剩余 gas
		- 累积的子状态
		- 账户的代码			 
- block(区块)

	在以太坊中，区块是由以下部分组成的
	
	- 一些相关信息片段组成的集合（称为 block header， 即区块头）； 
		
		区块头包含的的信息如下：
		
		- `parentHash`
		
			父区块头的 Keccak 256 位哈希
		- `ommersHash`
		
			当前区块的叔区块列表的 Keccak 256 位哈希 
		- `beneficiary`
		
			成功挖到这个区块所得到的所有交易费的 160 位接收地址 
		- `stateRoot`
		
			所有交易被执行完且区块定稿后的状态树（state trie），状态 trie 存储于区块头并且更方便于轻客户端验证状态的任何信息 
		- `transactionsRoot`
		
			由当前区块中所包含的所有交易所组成的树结构（transaction trie）
		- `receiptsRoot`
		
			由当前区块中所有交易的收据所组成的树结构（receipt trie） 
		- `logsBloom`
		
			由当前区块中所有交易的收据数据(日志信息)中的可索引信息（产生日志的地址和日志主题）组成的 Bloom 过滤器 
		- `difficulty`
		
			当前区块难度水平值，它可以根据前一个区块的难度水平和时间戳计算得到
		- `number`
		
			当前区块的祖先的数量（区块高度）。创世区块的这个数量为 0。 
		- `gasLimit`
		
			目前每个区块的 gas 开支上限 
		- `gasUsed`
		
			当前区块的所有交易所用掉的 gas 之和
		- `timestamp`
		
			当前区块初始化时的 Unix 时间戳 
		- `extraData`
		
			与当前区块相关的任意额外是关于数据，但必须在 32 字节以内。 
		- `mixHash`
		
			一个 256 位的哈希值，用来与 `nonce` 一起证明当前区块已经承载了足够的计算量 
		- `nonce`
			
			一个 64 位的值，用来与 `mixHash` 一起于证明当前区块已经承载了足够的计算量
	- 组成区块的交易 `T` 和 其它一些区块头` U` （这是一些父区块与当前区块的爷爷辈区块相同的区块(叔区块)， 这样的区块称为 ommers <sup>2</sup> ）。
	
		区块的另两个组成部分就是
		
		-  `ommer` 区块头（与以上格式相 同）列表 B <sub>U</sub> 
		- 本区块所有交易信息 B <sub>T</sub> 
	- 老版本可能会少一些数据 
		- 创世区块
		
				{
				  difficulty: 17179869184,
				  extraData: "0x11bbe8db4e347b4e8c937c1c8370e4b5ed33adb3db69cbdb7a38e1e50b1b82fa",
				  gasLimit: 5000,
				  gasUsed: 0,
				  hash: "0xd4e56740f876aef8c010b86a40d5f56745a118d0906a34e69aec8c0db1cb8fa3",
				  logsBloom: "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
				  miner: "0x0000000000000000000000000000000000000000",
				  mixHash: "0x0000000000000000000000000000000000000000000000000000000000000000",
				  nonce: "0x0000000000000042",
				  number: 0,
				  parentHash: "0x0000000000000000000000000000000000000000000000000000000000000000",
				  receiptsRoot: "0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421",
				  sha3Uncles: "0x1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347",
				  size: 540,
				  stateRoot: "0xd7f8974fb5ac78d9ac099b9ad5018bedc2ce0a72dad1827a1709da30580f0544",
				  timestamp: 0,
				  totalDifficulty: 17179869184,
				  transactions: [],
				  transactionsRoot: "0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421",
				  uncles: []
				}
		- 以太坊主网第410000的区块
		
				{
				  difficulty: 1390302857940436,
				  extraData: "0x7563776f6e67",
				  gasLimit: 6708771,
				  gasUsed: 105000,
				  hash: "0xa108580144142887e58cf074d4ea0be93b00c13ed1992d3897edb078fabe7118",
				  logsBloom: "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
				  miner: "0x9435d50503aee35c8757ae4933f7a0ab56597805",
				  mixHash: "0xfe8975ce7e272e88243ce9ec91d1a826fa5fe930d9e18de6a72ef57b4f9aa954",
				  nonce: "0xf0d4aef0039682a8",
				  number: 4100000,
				  parentHash: "0xd060e9516fc2a26aab3728d7fad2f2301d9822e6b2100eff58a16abd185881a1",
				  receiptsRoot: "0xa36be6a4f6a8e9a63a6b90dfa174d5cc6e7662f0d05007f39ef8a14aab54da95",
				  sha3Uncles: "0x1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347",
				  size: 1095,
				  stateRoot: "0xf49e0946c05d675cafd607613b009a3121a7e9ed6ed1f614a0c05e3bf6bebea1",
				  timestamp: 1501511212,
				  totalDifficulty: 595854527970155343606,
				  transactions: ["0x5728a5597f1dd7bb3e8843bfd6a8fe4156ae4605408d990c54dced5945e4a7af", "0x902aa2582c63328fcca071296a389b55a1c84983f1a3553ef05b1a14b16bd913", "0x452169cbce264f8d30074d2ddcb8caca2ba7e7b4effdca26301696c6a242ea5f", "0x9dee172d17a82354010ad18c9a7d32e49141b406d4802a6b0d5b25359809a1b3", "0xaa1b5f94f285a344d3e99f85529343daa3f72741752cad946a995e6544bd14ab"],
				  transactionsRoot: "0xe3eec697b2dcc74678edff5b022e65263c8428e47f11c25b9d4ba9d518632269",
				  uncles: []
				}
	当且仅当一个区块同时满足以下几个条件，我们才认为它是有效的：

	- 它必须由内部一致的 ommer(叔区块) 
	- 交易区块哈希值所组成,且基于起始状态（由父区块的最终状态继承而来）
	- 按顺序执行完成所有的给定交易 				 	
	区块结构是一个严格的构造。RLP 函数提供了权威的方法来把这个结构转换为一个可以通过网络传输或在本地存储的字节序列。		
- event log(交易收据)

	为了能使交易信息对零知识证明、索引和搜索都是有用的， 我们将每个交易执行过程中的一些特定信息编码为交易收据。把收据信息保存在一个以索引为键的树（index-keyed trie）中,树根就是 `receiptsRoot` 保存到区块头中.
	
	每条交易收据是一个包含四个条目的元组：

	- 包含交易收据的区块中当交易发生后的累积 gas 使用量；
	- 交易过程中创建的日志集合；
	- 由这些日志信息所构成的 Bloom 过滤器
	- 交易的状态代码

			

	 	

## 问题	
1. 什么是区块定稿(挖矿确认和奖励)

	区块定稿的过程包含 4 个步骤：

	- 验证（或在挖矿中，确定）ommer 叔区块；
		- 验证 ommer 头也就是验证每个 ommer 头即是有效的区块头。
		- 另一个关联条件是它必须是当前区块 N 代以内的 ommer，N ≤ 6，也就是最近6个高度范围内，超过作废。
		- 一个区块最多有两 个 ommer 头
	- (2) 验证（或在挖矿中，确定）交易；

		给定的 `gasUsed` 必须与列入的交易如实地相符：
		
		- 区块中的 gas 总使用量必须与区块中最后一个交易执行后的累积 gas 使用量相等
	- (3) 发放奖励；

		区块奖励的发放，包含了
		
		- 对当前区块

			我们给当前区块的 beneficiary 账户增加；
		- 和每 个 ommer 区块的 beneficiary 地址(矿工挖矿地址)中账户 balance 的增加。 

			对于每个 ommer 区块，我们额外给出 32分之1 的区块奖励，每个被当前区块确认的 ommer 会根据区块号会给对用 ommer 矿工的 beneficiary 奖励。
			
		如果 ommer 和当前区块的 beneficiary 地址有重合（即： 两个 ommer 有相同的 beneficiary 地址或者某一个 ommer 的 beneficiary 地址与当前区块相同），额外奖励将会累积发放。		
	- (4) 校验（或在挖矿中，计算有效的）状态和区块 nonce

		它区块 B 映射到其初始状态：

		- 这里 TRIE 指由状态所构成的 trie 的根节点哈希；我们假定客户端实现会把这个数据保存在状态数据库中，因为这个 trie 是个不可变的数据结构，所以这是简单有效。
		- 最后我们定义区块变换函数，它将一个不完整的区块 B 映射到一个完整区块 B ′ ：
		- 像先前详细介绍过的那样，第 n 个交易的状态代码、日志和累积 gas 消耗。我们也定义 第 n 个状态， 我们可以简单地把它定义为基于先前的交易结果状态（或者对于区块中的第一个交易来说，就是区块的初始状态）来执行当前交易所产生的结果状态：
		- 我们使用类似的方法来定义每个交易中加算了前一个交易的 gas 用量（当它是区块中的第一个交 易时，则为 0）后的累积用量：
			- 使用先前在交易执行函数中定义的 Υ<sup>1</sup>。
			- 用类似的方式定义 R[n] <sub>z</sub>
		- 最后，我们定义 Π 为将给定的区块奖励 Ω 发放到最后一个交易的结果状态 ℓ(σ) 之上的新状态：

		至此，完整的区块转换机制就定义好了。除了工作量证 明（Proof-of-Work）函数 PoW 以外。

2. 状态中包含的信息？在哪？
	- 账户余额
	- 名誉度
	- 信誉度
	- 现实世界的附属数据等；

3. 区块中记录着交易信息；
	- 区块之间通过密码学哈希 （hash）以引用的方式链接起来。 
	- 区块以流水账的方式组织起来，
		- 每个区块保留若干交易数据
		- 和前一个区块的引用， 
		- 加上一个最终状态的标识符（最终状态本身不会保存到区块中——否则区块就太大了）。 
4. 状态转换过程
5. 世界状态
	- 如何记录状态树？
	- 如何查询状态树？
6. 合约包含多成员？
7. 孤块合并机制和奖励机制 
8. 三个状态结构
	- `stateRoot`
	- `transactionsRoot`
	- `receiptsRoot`
9. 区块头验证

	验证区块 B 
	
	- 获取区块B 的父区块高度
	- 加1就是本区块高度
10. 以太坊挖矿难度(EIP-2)
	- 动态平衡；
		- 如果最近的两个区块间隔较短，则会导致难度值增加，因此需要额外的计算量，大概率会延长下个区块的出块时间。
		- 相反，如果最近的两个区块间隔过长， 难度值和下一个区块的预期出块时间也会减少。 

	
11. “难度炸弹”（“difficulty bomb”）或“冰河时期”（“ice age”）EIP-649
12. EIP-100 包含叔区块（uncle blocks）在内的平均出块时间的调整效果
13. EIP-649 伪造一个区块号 H <sub>i</sub> 来延迟冰河时期的来临 
14. 什么是合约创建深度


## 参考
- [以太坊是如何运作的？（六）](https://www.tuoluocaijing.cn/article/detail-31913.html)

					