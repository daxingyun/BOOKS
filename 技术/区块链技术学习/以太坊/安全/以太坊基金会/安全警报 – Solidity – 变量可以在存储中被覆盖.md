# 安全警报 – Solidity – 变量可以在存储中被覆盖
- 摘要：在某些情况下，变量可以覆盖存储中的其他变量。
- 受影响的 Solidity 编译器版本： 0.1.6 到 0.4.3（包括 0.4.4 预发布版本）
- 详细说明：

	小于 256 位的存储变量会一起打包到同一个 256 位插槽中（如果它们可以容纳的话）。如果将大于类型允许的值分配给第一个变量，则该值将覆盖第二个变量。

	这意味着如果攻击者可以导致第一个变量的值溢出，则可以修改第二个变量。可以使用算术或直接从调用数据中传入一个值来在第一个变量中创建溢出（调用数据中的值与 32 字节对齐，并且既不验证也不强制执行填充）。

	仅使用下面列出的类型作为状态变量的合约不受影响。数组、映射和结构（基于以下类型）也不受影响：

	- 有符号整数，包括小于 256 位的大小
	- bytesNN 类型，包括小于 256 位的大小
	- 256 位的无符号整数 (uint)

	类型小于 256 位且从不相邻的合约（请注意，基础合约的状态变量被“拉入”）不受影响。

以太坊多重签名钱包合约不受影响。请注意，地址占用 160 位，因此仅使用地址和 256 位类型的合约是安全的。此外，地址和布尔值在实践中几乎从不通过算术运算进行操作，因此仅使用地址、布尔值和 256 位类型的合约也应该是安全的。

- 以下合约可能会受到影响： 

	包含两个或多个连续状态变量的合约，其中它们的大小之和小于 256 位，并且第一个状态变量不是有符号整数且不是 bytesNN 类型。

小于 256 位的类型包括：bool, enums, uint8, ..., uint248, int8, ..., int248, address, 任何合约类型

- 推荐办法：
	- 至少使用 Solidity 版本 0.4.4（不是预发布或夜间版本）重新编译尚未部署的合约。
	- 停用、移除资金或升级已部署的合约。
	- 此漏洞由 github.com/catageek 发现：https ://github.com/ethereum/solidity/issues/1306