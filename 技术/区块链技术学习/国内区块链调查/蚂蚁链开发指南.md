# 蚂蚁链开发指南
## 合约平台技术介绍
蚂蚁链通过引入 P2P 网络、共识算法、虚拟机、智能合约、密码学、数据存储等技术特性，构建一个稳定、高效、安全的图灵完备智能合约执行环境，提供账户的基本操作以及面向智能合约的功能调用。基于蚂蚁链提供的能力和功能特性，应用开发者能够完成基本的账户创建、合约调用、结果查询、事件监听等。

- 逻辑架构

	![](./pic/antchain11.png)
- 合约平台系统架构

	![](./pic/antchain13.jpeg)	
- 核心逻辑

	![](./pic/antchain12.jpeg)
	
## 合约平台功能特性	
按照不同访问对象，可以将合约平台的基本功能划分为 

- 账户操作
- 合约访问
- 区块查询
- 交易查询
- 事件监听

等多种类型。除此之外，合约平台还具备

- 数据隔离
- 隐私保护
- SPV 验证

等功能特性，以满足各种业务场景的需求。

### 用户账户体系
合约平台所有交易操作均是围绕账户体系来进行，因此在发送执行交易之前需确保您已在合约平台创建对应的账户，然后可使用创建好的账户提交交易，还可以基于该账户结构完成相关账户配置的修改。

具体的账户数据结构模型字段和说明如下：

![](./pic/antchain27.png)

其中，账户包含三种类型的密钥：

- 权限密钥（auth_map）

	用于账户发送正常交易时使用的签名密钥，支持多个密钥，按权重分配实现多签名，是区块链节点判断交易是否有效授权的依据。
- 恢复密钥（recover_key）

	重置账户权限密钥时使用的签名密钥，对于已经存在的账户，合约平台提供重置、更新账户授权密钥以及重置账户恢复的能力。
- 加密密钥（encryption_key）

	用于隐私保护场景下的数据加密密钥，可被交易参与方获取并用于隐私数据的加密
	
合约平台采用将账户与密钥解耦的方式来实现，从一定程度上防止因为密钥丢失带来的链上数据丢失等安全隐患。合约平台支持的主要账户操作包括：

- 创建账户：在区块链平台上创建一个唯一的账户数据结构，主要用于记录链上账户的公钥。
- 更新密钥：修改区块链平台上特定账户下的注册公钥，主要应用于交易签名密钥的更改和权重变更。
- 重置密钥：基于账户的重置密钥来重置区块链平台上特定账户下的注册公钥。
- 账户冻结：冻结区块链平台上的特定账户，阻止该账户后续继续发送交易。
- 账户解冻：解冻区块链平台上已经处于冻结状态的账户，恢复其发送交易的能力。

### 合约帐户体系
合约平台内置了 EVM（Ethereum Virtual Machine）和 WASM（WebAssembly）两种智能合约执行引擎，支持多种合约编程语言，如Solidity 和 C++。您可以在合约平台上部署编写的智能合约并进行业务逻辑的调用。

合约平台上的合约数据结构模型如下：

![](./pic/antchain28.png)

相比于账户结构，合约中有额外的代码和存储相关的字段。

合约平台提供合约部署、升级、调用、冻结、解冻等生命周期的管理，这些操作均通过交易来实现。

- 合约部署

	在区块链平台上创建一个智能合约账户，并在该账户下绑定特定的智能合约编译字节码。
- 合约升级

	升级区块链平台上的一个智能合约账户代码，主要应用于合约代码功能的迭代和缺陷的修复后升级（需要满足一定的升级约束）。
- 合约调用

	基本的合约方法调用能力，通过交易调用智能合约的特定功能入口，修改或者检索智能合约中的存储数据。
- 合约冻结

	冻结区块链平台上的特定智能合约账户，被冻结的智能合约代码不能被用户调用，主要应用于智能合约发现缺陷后的紧急处理以防止缺陷的扩散。
- 合约解冻

	解冻区块链平台上的特定智能合约账户，主要应用于被冻结的缺陷代码修复后的恢复操作。

### 区块查询
合约平台以区块的形式组织交易历史和管理世界状态，系统根据给定的参数配置按照一定的规则执行交易并打包生成区块。在合约平台上，一个区块包含区块头和区块体两个部分。

- 区块头数据结构模型如下

	![](./pic/antchain29.png)
- 区块体数据结构模型如下

	![](./pic/antchain30.png)

系统提供一系列的功能完成对已经生成的区块数据的查询需求，具体功能如下：

- 区块头查询

	基于给定的区块号或哈希，返回该特定区块头数据结构，包括
	
	- 区块哈希
	- 区块版本
	- 块号
	- 父区块哈希
	- 交易列表根哈希
	- 收据列表根哈希
	- 世界状态根哈希
	- 燃料消耗值
	- 时间戳信息
	- 共识证明等
- 区块体查询

	基于给定的区块号或哈希，返回该特定区块体的详细信息，包括
	
	- 交易列表
	- 收据列表
	- 共识证明

### 交易查询
合约平台的所有数据变更均是基于交易形式来完成的。合约平台的交易根据类型的不同可以分为

- 创建账户
- 余额转账
- 部署合约
- 更新合约
- 调用合约
- 设置恢复密钥
- 预重置权限密钥
- 重置权限密钥
- 更新权限密钥
- 冻结账户
- 解冻账户
- 隐私交易等

#### 交易数据结构模型如下		
交易收据是合约平台中交易打包执行后的结果数据，用以标识交易的执行成功与否，执行后的返回数据以及产生的相关事件等。
![](./pic/antchain31.png)
#### 交易收据数据结构模型如下
![](./pic/antchain32.png)

通过 SDK 可以对某一个具体交易的信息进行查询，从而可以检索已经存在于块链结构中的任意交易信息。在系统中发生的每一笔交易都会对应一笔交易收据，交易收据也可以通过 SDK 查询。

- 交易查询

	基于给定的交易哈希，返回该特定交易的详细信息，包括
	
	- 所在块号
	- 交易号索引
	- 交易哈希
	- 交易类型
	- 交易时间戳
	- 交易 nonce
	- 发起方
	- 接收方
	- 交易值
	- 交易燃料消耗上限
	- 交易输入数据
	- 交易签名信息等。
- 交易收据查询

	基于给定的交易哈希，返回该特定交易的收据详细信息，包括
	
	- 所在块号
	- 交易号索引
	- 交易结果
	- 实际燃料消耗
	- 交易执行输出
	- 日志记录（发起方、接收方、交易类型、日志数据元信息）等

#### 事件监听
合约平台在执行交易和打包生成区块时会产生一系列的业务日志事件和系统日志事件，这些事件代表合约平台的一些运行状态。合约平台提供了一套基于事件订阅发布的机制来实时推送平台的日志事件给感兴趣的客户端。合约平台支持

- 订阅账户事件
- 合约账户事件
- 特定主题事件
- 区块事件

事件数据结构模型如下

![](./pic/antchain33.png)

您可通过 SDK 订阅感兴趣的事件，使用地址标识或者主题标识来请求合约平台相关事件推送。

- 事件订阅：给定事件过滤器来订阅合约平台的事件通知
- 取消事件订阅：取消已经完成的事件订阅，告知合约平台不再推送事件通知

#### 隐私保护
合约平台通过引入密码学的一些特性来支持账户信息敏感数据的隐私保护能力，通过在智能合约层面扩展相关的指令函数来实现智能合约中金额的加密存储以及加减操作。只有获得有效密钥的个体才能解密智能合约中的敏感数据，查看原始金额信息。

目前，合约平台引入的密码学特性包括零知识证明，即通过引入零知识证明来实现加密密文条件下转账金额的合法性证明。
#### 数据隔离
为能够满足更多的隐私保护诉求，合约平台引入数据隔离来实现业务敏感数据的交易的可见性。借助合约平台数据隔离的能力，可以实现交易请求仅仅在有限的区块链节点之间得以查看和被执行，同时敏感隐私数据也仅仅在有限的节点内被存储。

根据不同的环境依赖和信任基础，数据隔离功能包含以下两种操作：

- ENCRYPTION_ENVELOPE

	加密信封交易，通过信封加密技术将原始交易加密并在合约平台的公开账本上进行传播，掌握解密密钥的节点解开信封获取原始交易在本地执行。这样的操作对节点网络的依赖度相对较低，信任的基础是密码学技术。
- DEPOSIT_ENVELOPE

	存证信封交易，通过信封加密技术点对点传播，并将原始交易的哈希存储在公开账本上，用以实现对存证信封交易的共识。这样的操作对节点的网络依赖度相对较高，信任的基础是控制数据的有限范围传播。

#### SPV 验证
简单支付验证（Simplified Payment Verification，SPV）验证是合约平台提供的一种数据验证能力，能够在付出很小的存储代价和数据同步代价情况下完成对合约平台上存储数据的合法性校验。基于这种能力，您可以快速实现一个合约平台的轻客户端，完成与其他区块链平台的数据同步和访问。

SPV 的验证能力能够对合约平台上的以下数据给出有效性的证明：

- 区块证明

	用于证明一个指定的区块是否在合约平台的账本数据中存在。主要利用区块的链式结构和平台的共识证明来实现证明。
- 交易证明

	用于证明一个指定的交易或者交易执行结果是否在合约平台的账本数据中存在。主要利用交易默克尔证明结合区块证明来实现。
- 账户证明

	用于证明一个指定的账户数据是否在合约平台的指定区块的账本数据中存在。主要利用存储默克尔证明结合区块证明来实现。
- 存储证明

	用于证明一个指定的存储数据是否在合约平台的指定区块下账户中存在。主要利用存储默克尔证明结合区块证明来实现。

## 应用开发
### 简介
- 开发框架图
	
	![](./pic/antchain15.png)
- 基于蚂蚁区块链开发应用时，您可以有以下 3 种选择：
	- 选项 1：通过 SDK 在命令行与蚂蚁区块链交互。
	- 选项 2：通过 Web 应用（Client）集成 SDK 直接与蚂蚁区块链交互。该方式让客户端直接访问区块链平台，去掉了中间的后端服务，更加透明，比较适合轻量级的合约调用、查询等操作。
	- 选项 3：与传统 Web 应用开发相似，访问后端服务（Service），后端服务集成 SDK 后与蚂蚁区块链交互。该方式适合与传统的业务系统相结合，在后端服务层实现一些比较重要的业务逻辑和计算任务。

	在实际操作中，选项 2 和 3 比较常用，您可以根据具体应用场景进行选择

### 开发流程
在实际业务实现中，基于合约平台的应用开发并不约束于具体的开发流程。在联盟链多方参与的场景中，建议按照以下过程梳理业务场景，按步骤实现：

- 定义多方协作中，智能合约需要实现的逻辑和功能，实现智能合约。
- 定义各参与方客户端或后端服务的业务逻辑，以及与智能合约交互的接口逻辑，集成 SDK 实现。
- 集成 SDK 的业务逻辑与智能合约交互，测试功能。
- 多方参与的功能性集成测试。

### 合约开发
#### Cloud IDE 合约开发环境
Cloud IDE 是一个在线的合约开发环境，此工具提供以下功能

- 合约编辑与编译，展示编译结果字节码和接口说明（ABI）。
- 合约的部署和调用
	- 提供默认体验链环境和测试账户，用来部署和调用合约。
- 解析合约方法的返回值、事件日志等，辅助调试合约；保存合约到 BaaS 合约管理。

#### SDK 支持
目前，合约平台支持 Java SDK，覆盖合约平台的所有功能。更多信息，参见 Java SDK 说明 。

#### Cloud IDE 说明
Cloud IDE 合约开发环境（以下简称“IDE”）是 BaaS 合约平台提供的在线合约开发工具。

- 核心功能

	IDE 为智能合约开发提供简单、高效的集成环境，并提供以下核心功能：

	- 合约工程管理：管理工程目录和文件，提供文件编辑自动保存功能，保存合约到 BaaS 合约管理。
	- 合约编辑与编译：展示编译结果字节码和接口说明（ABI）。
	- 合约的部署和调用：提供默认合约体验链环境和测试账户，用来部署和调用合约。
	- 自动编解码：解析合约方法的返回值、事件日志等，辅助合约测试。
	- 合约单步调试：当前支持 Solidity 合约的单步调试功能，可单步执行，查看临时变量、合约存储、堆栈、内存等信息来深度调试合约。
	- 合约单元测试：当前支持 Solidity 合约的单元测试，可直接使用 Solidity 语言编写单元测试用例，一键执行所有测试用例。
	- 合约分析：在编译合约的同时对 Solidity 合约进行静态扫描分析，给出分析结果参考
- 基本框架

	IDE 是一个典型的去中心化应用（Dapp），可通过 JavaScript SDK 直接与区块链平台通信，进行合约部署和调用。这样设计的优势在于，通过 IDE 您可以连接任何目标的蚂蚁区块链平台环境。				 	 
	![](./pic/antchain19.jpeg)

#### 使用 Cloud IDE
- Cloud IDE 入口

	在开放联盟链的 合约管理 页面，您可以通过创建合约或编辑已有的合约，进入 Cloud IDE 合约开发环境。如下图所示：

	![](./pic/antchain34.png)
- 合约工程管理

	在 Cloud IDE 的左侧导航栏中，第一个功能模块就是 合约工程管理。该模块主要提供以下核心功能：

	- 添加文件夹。
	- 添加文件，如果是 Solidity 合约文件，需要以 .sol 为扩展名。
	- 拖拽、移动文件或文件夹。
	- 删除文件或文件夹。
	
	注意：Solidity 合约编译时会过滤以.sol 为扩展名的文件进行编译，非 .sol 扩展名文件不会参与编译。

#### 合约 Cloud IDE 开发流程
使用 Cloud IDE 开发合约的过程主要分为以下 6 步

- 环境配置
	- 在 Cloud IDE 中，点击 环境配置
	
		![](./pic/antchain35.png)
	- 在 环境配置 中，你可以选择账户管理下的任一账户进行联调，同时需要输入该账户对应的私钥信息及私钥密码进行验证。

		![](./pic/antchain36.png)		
- 编译

	开发合约过程中，可以随时对已完成的代码进行编译。

	- 在 Cloud IDE 中，点击 编译，开始编译代码
	
		![](./pic/antchain37.png)
		
		- 字节码

			字节码即合约代码的编译结果，也是合约部署时使用的关键数据，通过 SDK 可以将合约字节码部署到目标的生产链上使用。
		- 合约接口说明（ABI）

			应用程序二进制接口（Application Binary Interface，ABI）可以理解为合约的接口说明。当合约被编译后，其对应的 ABI 也会一起生成。

			ABI 类似于程序中的接口说明文档，描述了属性和方法签名相关信息，包括
			
			- 字段名称
			- 字段类型
			- 方法名称
			- 参数名称

				![](./pic/antchain38.png)
			- 参数类型
			- 方法返回值类型等
- 部署

	在合约编译通过，得到字节码和 ABI 后，在 Cloud IDE 中点击 部署合约 将合约部署到目标体验链进行测试。

	部署合约时，您可以预估 Gas 并设置 Gas 限额。在 部署合约 窗口中，点击 Gas预估 按钮，可自动估算此次交易所需的燃料，然后可根据 Gas 预估值，输入Gas 限额。Gas 限额设置后，若交易燃料超过此限额，则自动终止交易，避免浪费燃料。
	
	![](./pic/antchain39.png)
	
	在部署定义了 constructor 方法的合约时，需要给定 constructor 方法的参数。Cloud IDE 支持合约方法参数类型的提示和一些基本数据类型的初始化赋值，您可根据自身实际情况初始化合约。

	部署成功后，可以看到合约的所有方法列表
	
	![](./pic/antchain40.png)
- 调用

	合约部署成功后，IDE 会列出合约中所有的 public 方法以及 public 类型的状态变量。点击目标方法右侧的 调用合约 进行调用。

	在合约调用过程中，也可以进行 Gas 预估并设置 Gas 限额，具体操作同 部署合约。

	其中，状态变量对应的调用可以直接返回当前状态变量的值。合约方法的调用可以返回如下几个字段：
	
	![](./pic/antchain41.png)
	![](./pic/antchain42.png)
	![](./pic/antchain43.png)
- 调试
	- 错误说明

		在使用 Cloud IDE 过程中，可能遇到一些错误提示。在调用合约时，如果合约执行过程中出错，可能有多种原因，Cloud IDE 会将合约调用失败的错误码信息返回，便于您分析原因。Cloud IDE 使用的错误码信息与 SDK 使用的错误码保持一致，您可以查看 错误码列表 找到对应的错误码说明。
	- 错误码调试演示
		
		下面通过一个错误码示例来说明如何通过错误说明的提示分析合约内部错误的原因，您也可以通过添加 Event 事件的方式来调试合约。
		
		![](./pic/antchain44.png)
		
		- 在上图的错误码示例中，系统调用了 Cloud IDE 示例合约的 voteForCandidate 方法，给定的候选人为Demi，返回的错误码为10201，其含义为：
		
			![](./pic/antchain45.png)
		- 根据错误码提示，可以判断调用合约失败是因为触发了 revert 语句，含义为某个 require() 方法判断失败。查看合约代码，即可发现 voteForCandidate 方法中的相关条件检查：

				require(validCandidate(candidate));
		
			由此，可推断出输入的候选人 Demi 不合法，并不在实际投票的候选人列表 candidateList 中。事实也确实如此，合约部署过程中，constructor 参数仅指定了 Nick 和 Rose 两个候选人参与竞选。
	- 日志调试

		您可以通过添加 Event 事件触发日志的方式实现逻辑分支的判断和分析，进而对合约内部逻辑进行调试。

		这里选择调用合约方法 validCandidate						
 		![](./pic/antchain46.png)
 		
			 // This function will help to check whether target candidate is in the candidateList.
			    function validCandidate(bytes32 candidate) view public returns (bool) {
			        for (uint i = 0; i < candidateList.length; i++) {
			            if (candidateList[i] == candidate) {
			            emit VALID(true);
			            return true;
			            }
			        }
			        emit VALID(false);
			        return false;
			    }
		在 validCandidate 方法的实现中，不同的执行逻辑会根据情况触发不同的 Event 事件，通过查看调用结果日志信息，即可分析出合约的执行路径。在以上示例中，执行逻辑相对简单。在复杂的逻辑控制方法中，通过添加 Event 事件的方式可以很好的追踪合约执行路径，达到调试合约的目的。			    
- 升级

	合约部署之后，可以通过升级的方式对合约进行问题修复、业务逻辑变更或优化。升级合约相当于部署一个新版本的合约。

		说明：仅支持对已部署完成的合约进行升级。

	在 Cloud IDE 中，点击 部署记录，选择要升级的合约，然后点击 升级 进行合约升级。升级合约时，也可以进行 Gas 预估并设置 Gas 限额，具体操作同 部署合约。	

	![](./pic/antchain47.png)
	![](./pic/antchain48.png)
	
	对于升级前已被调用的合约，合约升级后，再次调用该合约将执行新的方法和业务逻辑。
- 单元测试

	Cloud IDE 支持编写单元测试用例，所有的测试用例文件规定存放在 test 目录下，便于管理。

	当前，IDE 支持使用 Solidity 语言编写单元测试。IDE 提供了便于编写测试用例的 Asset 库方法和测试账户。

	为方便使用，在 IDE 单元测试模块中点击 添加测试文件 可以快速生成一个单元测试用例，并且生成后的测试用例可以直接运行：
	
	![](./pic/antchain49.png)	
	
	创建合约工程时，默认添加了一个 demo 合约，针对这个 demo 合约的单元测试用例如下

		pragma solidity ^0.4.20;
		import "ide_tests.sol"; // the import is automatically injected by IDE.
		import "../demo.sol"; // the path of target contract to test.
		 
		contract test_vote {
		 
		    Voting voteToTest; // the target testing contract
		 
		    function beforeAll () public {
		        bytes32[] params;
		        params.push(bytes32(1));
		        voteToTest = new Voting(params);
		        Assert.equal(voteToTest.totalVotes(), uint(0), "0 should be the total votes");
		    }
		 
		    function checkTotalVotes () public {
		        Assert.equal(voteToTest.validCandidate(bytes32(1)), true, "should be a valid candidate");
		        voteToTest.voteForCandidate(bytes32(1));
		        Assert.equal(voteToTest.totalVotes(), uint(1), "1 should be the total votes");
		    }
		}
	运行此单元测试的结果为
	
	![](./pic/antchain50.png)
	
	- 引入目标测试合约

		单元测试的核心目标是测试一个目标合约，因此在单元测试中要引入需要测试的合约（import "../demo.sol";），然后创建并初始化此目标合约（voteToTest = new Voting(params);），进而调用此目标合约的方法进行测试。
	- Asset 库支持

		其中 import "ide_tests.sol" 是 Cloud IDE 提供的 Asset 库，核心提供了不同合约数据类型的 equal、notEqual、greaterThan、lesserThan、ok 等方法。如果代码中没有显式的引入 ide_tests.sol 文件，Cloud IDE 也会自动注入此依赖库，方便您使用。 在使用 Asset 的比较方法时，有以下注意事项：
		
		- 类型 identity 的对比要使用 equalID 和 notEqualID 方法。
		- Asset 库中没有提供 uint8 ~ uint128 以及 int8 ~ int128 的对比方法，这些数据类型的比较都可以通过转换为 uint 和 int 进行，例如Assert.equal(uint(2), uint(1), "error message defined by case");。 除此之外，Asset 库还提供一些单元测试执行前后的处理方法：beforeAll、beforeEach、afterAll、afterEach，可以根据具体需求或场景使用。
	- TestsAccounts 测试账户

		在某些特殊场景下，需要指定合约的调用方（sender），比如测试角色权限控制，特定的角色才能调用某些合约方法。 在测试用例运行前，IDE 会默认随机创建 3 个测试账户以供使用，这 3 个账户的 ID 随机生成，并不固定。在编写测试用例方法时，可以通过写注释的方式指定账户，这样调用此用例方法时就会使用指定的账户来签名交易。例如以下使用方式：
  
			  /// sender: account-0
			  function checkSenderIsAccount0 () public { // the commits 'sender: account-0' says to use 'TestsAccounts.getAccount(0)' as sender.
			      Assert.equalID(msg.sender, TestsAccounts.getAccount(0), "wrong sender in checkSenderIsAccount0");
			  }
		其中 /// sender: account-0 注释非常关键，指定了使用 IDE 生成的 3 个账户中的第一个 account-0 来调用方法 checkSenderIsAccount0 进行测试。在代码中对应获取 account-0 的方式是：TestsAccounts.getAccount(0)。 同样，如果需要使用其它两个账户，只需指定为 /// sender: account-1 或 /// sender: account-2 即可。
		
			注意：需要引入 import "ide_accounts.sol";。

### 应用工程开发
#### [Java SDK 开发指南](https://antchain.antgroup.com/docs/11/146924)(暂不考虑)
#### Go SDK 开发
##### 接入 Go SDK
- 引入依赖
	- 下载
	
		将 SDK（点击下载 [restclient-go-sdk.zip](https://docs-aliyun.cn-hangzhou.oss.aliyun-inc.com/assets/attach/160376/AntCloud_zh/1586762765430/restclient-go-sdk.zip)）下载至 $GOPATH/src/gitlab.alipay-inc.com/antchain/restclient-go-sdk。
	- go mod
	
		如果使用 go mod，则将依赖路径指定为本地 restclient-go-sdk 所在路径即可。执行语句如下：
	
			require (
			    gitlab.alipay-inc.com/antchain/restclient-go-sdk v1.0.0
			)
 
			replace gitlab.alipay-inc.com/antchain/restclient-go-sdk => 本地 restclient-go-sdk 路径
- 初始化客户端
	- 在要使用的项目代码中引入依赖包。执行 import "gitlab.alipay-inc.com/antchain/restclient-go-sdk/client" 语句导入。
	- 指定 REST 的配置文件路径，例如：/tmp/rest-config.json。文件格式参考下面代码段中的注释说明。

	restClient 初始化的代码示例如下。可在项目里通过 NewRestClient 初始化客户端 restClient，建议仅初始化一次作为全局变量使用。 

		import "gitlab.alipay-inc.com/antchain/restclient-go-sdk/client"
		 
		var restClient *client.RestClient
		 
		func init() {
		    var err error
		    // configFilePath 是 SDK 初始化的配置文件，格式为 JSON 串，具体配置信息见后面
		    configFilePath := "/tmp/rest-config.json"
		    restClient, err = client.NewRestClient(configFilePath) // 初始化客户端
		    if err != nil {
		        panic(fmt.Errorf("failed to NewRestClient err:%+v", err))
		    }
		}
		 
		/** 以下是 configFilePath 的示例文件
		BizId：链的 ID
		RestUrl：rest 的服务地址
		AccessId：分配给用户用于访问 rest 的账户名（可通过开放联盟链控制台获得）
		AccessSecret：分配给用于用户访问rest的密钥的路径（可通过开放联盟链控制台获得）
		MaxIdleConns：最大空闲连接数
		IdleConnTimeout：空闲连接超时时间，单位为秒
		RetryMaxAttempts：请求重试最大次数
		BackOffPeriod：重试时间间隔，单位为毫秒
		**/
		/**
		{
		  "RestUrl": "https://rest.baas.alipay.com",
		  "AccessId": "baas_admin",
		  "AccessSecret": "/Users/Documents/go_workspace/src/gitlab.alipay-inc.com/antchain/restclient-go-sdk/test/access.key",
		  "MaxIdleConns": 10,
		  "IdleConnTimeout": 30,
		  "RetryMaxAttempts": 5,
		  "BackOffPeriod": 500
		}
		**/
		
##### 接口说明
注意：Go SDK 暂不支持创建链账户、查询链账户，可前往控制台链账户管理页面进行相关操作，详见 [链账户管理](https://antchain.antgroup.com/docs/11/146707#) 文档。

- 存证接口
	- 异步存证
		- 请求参数
	
			 ![](./pic/antchain51.png)
		- 调用示例
	
				    // 异步存证接口
				  u := uuid.New()
				  bizid := "9b0c522d873a4bf7ac80efdbe27c808c"
				    orderId = fmt.Sprintf("order_%v", u.String())
				  account := "test_account" // 与前面创建账户相同
				  tenantId := "mytenant" // 租户 ID，与前面创建账户所使用的 tenantId 相同
				    content := "我是中国人" // 存证内容
				  kmsId := "mykmsid" // 与前面创建账户所使用的 kmsId 相同
				    var gas int64 = 50000 // 调用花费的最大 Gas（开放联盟链必须指定 Gas，且大于 0，其他链可以默认填 0 表示不受限）
				    baseResp, err = restClient.Deposit(bizid, orderId, account, tenantId, content, kmsId, gas)
				    if !(err == nil && baseResp.Code == "200") {
				        panic(fmt.Errorf("no succ deposit resp,resp:%+v err:%+v", baseResp, err))
				    }
				    hash := baseResp.Data
				    time.Sleep(2 * time.Second) // wait for some time
				    baseResp, err = restClient.QueryTransaction(bizid, hash) // 查询交易详情，详见查询交易接口
				    if !(err == nil && baseResp.Code == "200") {
				        panic(fmt.Errorf("no succ transaction baseResp:%+v err:%+v", baseResp, err))
				    }
				    jsonObject = make(map[string]interface{})
				    err = json.Unmarshal([]byte(baseResp.Data), &jsonObject)
				    if err != nil {
				        panic(err)
				    }
				    innerObject := jsonObject["transactionDO"].(map[string]interface{})
				    encodedData := innerObject["data"].(string)
				    bytes, err := base64.StdEncoding.DecodeString(encodedData)
				    if err != nil {
				        panic(err)
				    }
				    data := string(bytes) // 获取原来存证内容
				    if data != content {
				        panic(fmt.Errorf("origin isn't the same with content,origin:%+v content:%+v", data, content))
				    }
					    
		 - 返回参数
	
			![](./pic/antchain52.png)
		- 返回示例
	
				BaseResp(Success=true, Code=200, Data=86c3651edf6756dbd7e2b4e20c2f0a214734a0849f6d1fb3edd1583bc9367ee9)
	- 同步存证
		- 请求参数
	
			 ![](./pic/antchain53.png)
		- 调用示例
	
				    // 下面是同步存证的使用方式
				  u := uuid.New()
				  bizid := "9b0c522d873a4bf7ac80efdbe27c808c"
				    orderId = fmt.Sprintf("order_%v", u.String())
				  account := "test_account" // 与前面创建账户相同
				  tenantId := "mytenant" // 租户 ID，与前面创建账户所使用的 tenantId 相同
				    content := "我是中国人" // 存证内容
				  kmsId := "mykmsid" // 与前面创建账户所使用的 kmsId 相同
				    var gas int64 = 50000 // 调用花费的最大的 Gas（开放联盟链必须指定 Gas，且大于 0，其他链可以默认填 0 表示不受限）
				    baseResp, err := restClient.DepositSyncWithTransaction(bizid, orderId, account, tenantId, content, kmsId, gas)
				    if !(err == nil && baseResp.Code == "200") {
				        panic(fmt.Errorf("no succ resp baseResp:%+v err:%+v", baseResp, err))
				    }
				  /** baseResp.Data示例
				  {
				        "blockNumber": 4342894,
				        "transactionDO": {
				            "data": "5oiR5piv5Lit5Zu95Lq6",
				            "timestamp": 1586404579074
				        }
				    }
				  **/
				    jsonObject := make(map[string]interface{})
				    err = json.Unmarshal([]byte(baseResp.Data), &jsonObject) // 反序列化
				    if err != nil {
				        panic(err)
				    }
				    innerObject := jsonObject["transactionDO"].(map[string]interface{})
				    encodedData := innerObject["data"].(string)
				    bytes, err := base64.StdEncoding.DecodeString(encodedData)
				    if err != nil {
				        panic(err)
				    }
				    data := string(bytes)
				    if data != content {
				        panic(fmt.Errorf("origin isn't the same with content,origin:%+v content:%+v", data, content))
				    }
		- 返回参数
	
			![](./pic/antchain54.png)
		- 返回示例
	
				BaseResp(Success=true, Code=200, Data={"blockNumber":4342894,"transactionDO":{"data":"5oiR5piv5Lit5Zu95Lq6","timestamp":1586404579074}})
- 合约接口
	- 部署合约(该接口目前仅支持 Solidity 合约部署)
		-  请求参数

			![](./pic/antchain55.png)
		- 调用示例
	
				    //deploy contract
				  u := uuid.New()
				  bizid := "9b0c522d873a4bf7ac80efdbe27c808c"
				    orderId = fmt.Sprintf("order_%v", u.String())
				  account := "test_account" // 与创建的账户相同
				  tenantId := "mytenant" // 租户 ID，与前面创建账户时所使用的 tenantId 相同
				  kmsId := "mykmsid" // 与前面创建账户所使用的 kmsId 相同
				  contractName := "mycontract" // 合约名，后续调用合约使用
				  var gas int64 = 50000
				    baseResp, err := restClient.DeployContract(bizid, orderId, account, tenantId, kmsId, contractName, "608060405234801561001057600080fd5b506040516102ef3803806102ef833981018060405281019080805190602001909291908051820192919050505081600081905550600060018190555050506102928061005d6000396000f300608060405260043610610057576000357c0100000000000000000000000000000000000000000000000000000000900463ffffffff1680631002aecd1461005c57806338af3eed146101f0578063954ab4b21461021b575b600080fd5b34801561006857600080fd5b50610109600480360381019080803590602001908201803590602001908080601f0160208091040260200160405190810160405280939291908181526020018383808284378201915050505050509192919290803590602001908201803590602001908080601f0160208091040260200160405190810160405280939291908181526020018383808284378201915050505050509192919290505050610246565b604051808060200180602001838103835285818151815260200191508051906020019080838360005b8381101561014d578082015181840152602081019050610132565b50505050905090810190601f16801561017a5780820380516001836020036101000a031916815260200191505b50838103825284818151815260200191508051906020019080838360005b838110156101b3578082015181840152602081019050610198565b50505050905090810190601f1680156101e05780820380516001836020036101000a031916815260200191505b5094505050505060405180910390f35b3480156101fc57600080fd5b50610205610256565b6040518082815260200191505060405180910390f35b34801561022757600080fd5b5061023061025c565b6040518082815260200191505060405180910390f35b6060808383915091509250929050565b60015481565b60006001549050905600a165627a7a72305820ac9ff0ce4f83f475e39f7a8ecdfeb0b16673a328ca1af858b2ce81ccbe75837c0029",gas)
				    if !(err == nil && baseResp.Code == "0") {
				        panic(fmt.Errorf("no succ resp baseResp:%+v err:%+v", baseResp, err))
				    }
		- 返回参数
		
			![](./pic/antchain56.png)
		- 返回示例

				BaseResp(Success=true, Code=200, Data={"txData":{"data":{"success":true,"transactionReceipt":{"output":"AWCAYEBSYAQ2EGEAV1dgADV8AQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACQBGP/////FoBjEAKuzRRhAFxXgGM4rz7tFGEB8FeAY5VKtLIUYQIbV1tgAID9WzSAFWEAaFdgAID9W1BhAQlgBIA2A4EBkICANZBgIAGQggGANZBgIAGQgIBgHwFgIICRBAJgIAFgQFGQgQFgQFKAk5KRkIGBUmAgAYODgIKEN4IBkVBQUFBQUJGSkZKQgDWQYCABkIIBgDWQYCABkICAYB8BYCCAkQQCYCABYEBRkIEBYEBSgJOSkZCBgVJgIAGDg4CChDeCAZFQUFBQUFCRkpGSkFBQUGECRlZbYEBRgIBgIAGAYCABg4EDg1KFgYFRgVJgIAGRUIBRkGAgAZCAg4NgAFuDgRAVYQFNV4CCAVGBhAFSYCCBAZBQYQEyVltQUFBQkFCQgQGQYB8WgBVhAXpXgIIDgFFgAYNgIANhAQAKAxkWgVJgIAGRUFtQg4EDglKEgYFRgVJgIAGRUIBRkGAgAZCAg4NgAFuDgRAVYQGzV4CCAVGBhAFSYCCBAZBQYQGYVltQUFBQkFCQgQGQYB8WgBVhAeBXgIIDgFFgAYNgIANhAQAKAxkWgVJgIAGRUFtQlFBQUFBQYEBRgJEDkPNbNIAVYQH8V2AAgP1bUGECBWECVlZbYEBRgIKBUmAgAZFQUGBAUYCRA5DzWzSAFWECJ1dgAID9W1BhAjBhAlxWW2BAUYCCgVJgIAGRUFBgQFGAkQOQ81tgYICDg5FQkVCSUJKQUFZbYAFUgVZbYABgAVSQUJBWAKFlYnp6cjBYIKyf8M5Pg/R14596js3+sLFmc6Moyhr4WLLOgcy+dYN8ACk=","result":0}},"success":true,"txHash":"ea86f91dd925647cbeb21fd9116f6863967ffb933dfcb2da828a82ae157518a3"}})
	- 调用合约(该接口目前仅支持 Solidity 合约部署)
		-  请求参数
	
			![](./pic/antchain57.png)
		- 调用示例
	
				    //call contract
				    arg1 := make([]byte, 13)
				    for i := 0; i < 13; i++ {
				        arg1[i] = byte(i)
				    }
				    arg2 := "hello"
				    jsonArr := make([]interface{}, 0)
				    jsonArr = append(jsonArr, arg1)
				    jsonArr = append(jsonArr, arg2)
				    inputParamListBytes, err := json.Marshal(&jsonArr)
				    if err != nil {
				        panic(err)
				    }
				    u = uuid.New()
				  bizid := "9b0c522d873a4bf7ac80efdbe27c808c"
				    orderId = fmt.Sprintf("order_%v", u.String())
				  account := "test_account" // 与前面创建账户相同
				  tenantId := "mytenant" // 租户 ID，与前面创建账户时所使用的 tenantId 相同
				  kmsId := "mykmsid" // 与前面创建账户所使用的 kmsId 相同
				  contractName := "mycontract" // 合约名，后续调用合约使用
				  var gas int64 = 50000
				    baseResp, err = restClient.CallContract(bizid, orderId, account, tenantId, contractName, "SayHello(bytes,string)", string(inputParamListBytes), `["bytes","string"]`, kmsId, false, gas)
				    if !(err == nil && baseResp.Success && baseResp.Code == "0") {
				        panic(fmt.Errorf("no succ resp baseResp:%+v err:%+v", baseResp, err))
				    }
				    type Output struct {
				        OutRes []interface{} `json:"outRes"`
				    }
				    outputs := Output{}
				    err = json.Unmarshal([]byte(baseResp.Data), &outputs)
				    if err != nil {
				        panic(err)
				    }
				    output1, err := base64.StdEncoding.DecodeString(outputs.OutRes[0].(string))
				    if err != nil {
				        panic(err)
				    }
				    output2 := outputs.OutRes[1].(string)
				    if !isBytesSame(arg1, output1) {
				        panic(fmt.Errorf("intput arg1:%+v is not same with output1:%+v", arg1, output1))
				    }
				    if arg2 != output2 {
				        panic(fmt.Errorf("input arg2:%s is not same with output2:%s", arg2, output2))
				    }
				    //local call
				    u = uuid.New()
				    orderId = fmt.Sprintf("order_%v", u.String())
				    baseResp, err = restClient.CallContract(RestBizTestBizID, orderId, RestBizTestAccount, RestBizTestTenantID, contractName, "SayHello(bytes,string)", string(inputParamListBytes), `["bytes","string"]`, RestBizTestKmsID, true)
				    if !(err == nil && baseResp.Success && baseResp.Code == "0") {
				        panic(fmt.Errorf("no succ resp baseResp:%+v err:%+v", baseResp, err))
				    }
				    err = json.Unmarshal([]byte(baseResp.Data), &outputs)
				    if err != nil {
				        panic(err)
				    }
				    output1, err = base64.StdEncoding.DecodeString(outputs.OutRes[0].(string))
				    if err != nil {
				        panic(err)
				    }
				    output2 = outputs.OutRes[1].(string)
				    if !isBytesSame(arg1, output1) {
				        panic(fmt.Errorf("intput arg1:%+v is not same with output1:%+v", arg1, output1))
				    }
				    if arg2 != output2 {
				        panic(fmt.Errorf("input arg2:%s is not same with output2:%s", arg2, output2))
				    }
		- 返回参数
		
			![](./pic/antchain58.png)
		- 返回示例

				BaseResp(Success=true, Code=200, Data={"outRes":["AAECAwQFBgcICQoLDA==","hello"],"transaction":{"data":{"success":true,"transactionReceipt":{"output":"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAANAAECAwQFBgcICQoLDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABWhlbGxvAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA","result":0}},"success":true,"txHash":"d4a1c79be59cb703171479b570023ae2fb354666523e94e2df4e93ae20e4c138"}})
	- 查询交易
		- 请求参数

			![](./pic/antchain59.png)
		- 调用示例

				    bizid := "9b0c522d873a4bf7ac80efdbe27c808c"
				  hash := "b457afacb11dff49020f70ea1a80059b2d98466a58399d36e5b71389827216b2"
				    baseResp, err := restClient.QueryTransaction(bizid, hash)
				    if !(err == nil && baseResp.Code == "200") {
				        panic(fmt.Errorf("no succ resp baseResp:%+v err:%+v", baseResp, err))
				    }
				  fmt.Printf("baseResp:%+v\n", baseResp)
		- 返回参数

			![](./pic/antchain60.png)
		- 返回示例

				BaseResp(Success=true, Code=200, Data={"blockNumber":3865995,"transactionDO":{"data":"5oiR5piv5Lit5Zu95Lq6","timestamp":1585225989483}})
	- 查询回执
		- 请求参数

			![](./pic/antchain61.png)
		- 调用示例

			    hash := "b457afacb11dff49020f70ea1a80059b2d98466a58399d36e5b71389827216b2"
			    baseResp, err := restClient.QueryReceipt(RestBizTestBizID, hash)
			    if !(err == nil && baseResp.Code == "200") {
			        panic(fmt.Errorf("no succ resp baseResp:%+v err:%+v", baseResp, err))
			    }
			    fmt.Printf("baseResp:%+v\n", baseResp)
		- 返回参数

			![](./pic/antchain62.png)
		- 返回示例

				BaseResp(Success=true, Code=200, Data={"blockNumber":3865995,"gasUsed":20150,"logs":[{"from":{"data":"USC/ncA1684nf8DtlNOwrz3BR+frJxjE0rqCNM2IS3U=","empty":false,"value":"USC/ncA1684nf8DtlNOwrz3BR+frJxjE0rqCNM2IS3U="},"logData":"","to":{"data":"USC/ncA1684nf8DtlNOwrz3BR+frJxjE0rqCNM2IS3U=","empty":false,"value":"USC/ncA1684nf8DtlNOwrz3BR+frJxjE0rqCNM2IS3U="},"topics":["deposit_data"]}],"output":"","result":0})
				
##### 结果码
![](./pic/antchain63.png)					

##### 完整 Demo
此处提供 Go SDK 源码文件和完整 Demo 文件供您下载体验。有关 SDK 的接入方式以及各个接口的使用方法，请查看上述章节内容。

- [下载 restclient-go-sdk.zip](https://docs-aliyun.cn-hangzhou.oss.aliyun-inc.com/assets/attach/160376/AntCloud_zh/1587366703978/restclient-go-sdk%20%283%29.zip)
- [下载 GoProject.zip（SDK Demo	)](https://docs-aliyun.cn-hangzhou.oss.aliyun-inc.com/assets/attach/160376/AntCloud_zh/1587366772894/GoProject.zip)

##### 注意事项
- rest-config.json文件中，除了必填信息，不要添加多余注解信息，否则会出现错误。确保文件中的内容是合法的 JSON 串，以上示例中的注释仅供解释说明。
- 针对access.key 文件，生产环境下载的标签开头结尾需要采用如下样式

		  -----BEGIN PRIVATE KEY-----
		  ENCODED DATA
		  -----END PRIVATE KEY-----
					  
#### HTTP 方式接入
本文介绍各种开发语言（Java/C++）以 HTTP 方式接入开放联盟链时客户端与服务端的交互过程，并对开放联盟链涉及的接口进行说明。

	说明：目前Http方式仅支持密钥托管账户进行调用，需要在控制台进行创建
##### 握手机制
客户端与服务端的握手机制如下图所示。

- 用 AccessKey（AK）来代表用户，用户握有一个私钥，在握手时，用户会用私钥对一段消息进行签名。
- 服务端根据 secret 和 AK 查询出来对应的公钥，对消息进行验证。
- 如果验证通过，服务端会返回一个 token（所有相同的 AK 使用同一个 token）。
- 用户的后续消息都需要携带 token，从而可以避免验证。	
![](./pic/antchain64.png)

- AccessId/公私钥对和签名生成逻辑

	在开放联盟链平台上会保存您的 AccessId 以及对应的公钥。

	您需要将公钥上传到开放联盟链平台，公私钥对可以在本地生成或从平台下载。私钥在客户端用来签名，公钥保存在开放联盟链平台上用来验证签名。

	您需要用私钥对一段消息进行签名，消息生成规则如下：
	
		message:=AccessId+now
		//注意：+是字符串连接符（操作符），不是分隔符
		//AccessId需要在开放联盟链控制台申请分配
		//time为当前13位的毫秒时间戳，形如：1562659860790
		//即一条message可能=openchain-account1562659860790
	消息直接由 AccessId 和时间戳拼接而成，签名后的内容用 secret 来表示
	
		secret:=sign(message)
	其中，签名的过程（Hex.encode(RSAWithSHA256(message))）如下：

	- 用 SHA256 提取消息摘要。
	- 然后用 RSA 算法对摘要进行签名。
	- 对签名后的消息进行 Hex 编码（例如：2e8a899…)
- 发送握手请求
	- 向开放联盟链发送一个请求 HTTP 请求，请求的 URL 如下
	
			https://rest.baas.alipay.com/api/contract/shakeHand
		- 请求 body 是上面内容的包装，如下所示
	
				{"accessId":"xxx","time":"xxxx","secret":"xxxx"}
		- secret参数加密demo。调用如下方法sign(accessId + 时间戳，access.key) 如
	
				sign("rSEJ8AAFJDIZBQWE" + 1594092405000，access.key)
			代码 
			
				public class CertUtil {
				    private static final Logger LOGGER = LoggerFactory.getLogger(CertUtil.class);
				    private static final int MAX_ENCRYPT_BLOCK = 117;
				    private static final int MAX_DECRYPT_BLOCK = 128;
				 
				    public CertUtil() {
				    }
				 
				    public static String sign(String plain, String priKey) throws Exception {
				        PrivateKey privateKey = getPrivateKey(priKey);
				        Signature signature = Signature.getInstance("Sha256WithRSA");
				        signature.initSign(privateKey);
				        signature.update(plain.getBytes("UTF-8"));
				        byte[] signed = signature.sign();
				        return new String(Hex.encode(signed));
				    }
				    public static PrivateKey getPrivateKey(String priKey) throws Exception {
				        byte[] bytesPrivateBase64 = readKeyDatas(priKey);
				        byte[] bytesPrivate = Base64.decode(bytesPrivateBase64);
				        PKCS8EncodedKeySpec keySpec = new PKCS8EncodedKeySpec(bytesPrivate);
				        KeyFactory keyFactory = null;
				        keyFactory = KeyFactory.getInstance("RSA");
				        PrivateKey privateKey = keyFactory.generatePrivate(keySpec);
				        return privateKey;
				    }
				    private static byte[] readKeyDatas(String key) throws Exception {
				        BufferedReader bufferedReader = new BufferedReader(new StringReader(key));
				        String str = null;
				        StringBuilder stringBuilder = new StringBuilder();
				 
				        while((str = bufferedReader.readLine()) != null) {
				            if (!str.contains("---")) {
				                stringBuilder.append(str);
				            }
				        }
				        return stringBuilder.toString().getBytes();
				    }
				 
				}
- 提取服务端返回的 Token

	如果服务端验证通过，则返回来的内容如下
	
		{"success":true,"code":"200","data":"xxx"}
	其中，data 就是 token 的内容，token 的有效期是30分钟，超过30分钟需要重新请求生成新的 token。
	
	注意：下面所有的请求都需要携带 AccessId 和 Token

##### [C++ 握手 Demo](https://antchain.antgroup.com/docs/11/146925)
##### 接口说明
- 交易消息类

	所有交易类型的统一访问 URL 都是
	
		https://rest.baas.alipay.com/api/contract/chainCallForBiz
	使用 Method 来区分以下不同的交易类型
	- 存证
		- 请求地址
	
				/api/contract/chainCallForBiz
		- 请求参数						
	
			![](./pic/antchain65.png)
		- 请求示例
	
				$curl -d '{"orderId":"order1","bizid":"123","account":"myaccount","content":"hello","tenantid":"mytenant","mykmsKeyId":"keyid","method":"DEPOSIT","accessId":"baas_admin","token":"qwei10whe-waesc","gas":10000}' -H "Content-Type: application/json;charset=utf-8" -XPOST https://rest.baas.alipay.com/api/contract/chainCallForBiz 
				 
				e.g java rest-client 返回示例
				 
				String orderId = "order_" + System.currentTimeMillis();
				        CallRestBizParam callRestBizParam=CallRestBizParam.builder()
				            .orderId(orderId)
				            .bizid(restClientProperties.getBizid())
				            .account(account)
				            .tenantid("mytenant")
				            .gas(50000L)
				            .content("test123")
				            .accessId(baas_admin)
				            .token("qwei10whe-waesc")
				            .mykmsKeyId(mykmsId)
				            .method(Method.DEPOSIT).build();
				        BaseResp baseResp=restClient.chainCallForBiz(callRestBizParam);
		- 返回参数
	
			![](./pic/antchain66.png)
		- 返回示例
	
				${"success":false,"code":"202","data":"input token is not correct"}
				 
				e.g java rest-client 返回示例
				 
				BaseResp(success=true, code=200, data=0a60fd52fd9d72cb02a8b970a96bd3050b610175296eae75557bd9b3a0b5e48e)
	- [部署 WASM 合约](https://antchain.antgroup.com/docs/11/146925)(暂时不考虑)
	- [调用 WASM 合约](https://antchain.antgroup.com/docs/11/146925)(暂时不考虑)
	- 部署 Solidity 合约
		-  请求地址
		
				/api/contract/chainCallForBiz
		-  请求参数						
	
			![](./pic/antchain67.png)
		- 请求示例
	
				$curl -d '{"orderId":"order1","bizid":"123","account":"myaccount","contractName":"mycontract","contractCode":"XN09XIO78BNMM","tenantid":"mytenant","mykmsKeyId":"keyid","method":"DEPLOYCONTRACTFORBIZ","accessId":"baas_admin","token":"qwei10whe-waesc","gas":10000}' -H "Content-Type: application/json;charset=utf-8" -XPOST https://rest.baas.alipay.com/api/contract/chainCallForBiz
				 
				String orderId = "order_" + System.currentTimeMillis();
				        CallRestBizParam callRestBizParam=CallRestBizParam.builder()
				            .orderId(orderId)
				            .bizid(restClientProperties.getBizid())
				            .account(account)
				            .contractName("test_biz_deploy_contract")
				            .contractCode("608060405234801561001057600080fd5b5060df8061001f6000396000f3006080604052600436106049576000357c0100000000000000000000000000000000000000000000000000000000900463ffffffff16806360fe47b114604e5780636d4ce63c146078575b600080fd5b348015605957600080fd5b5060766004803603810190808035906020019092919050505060a0565b005b348015608357600080fd5b50608a60aa565b6040518082815260200191505060405180910390f35b8060008190555050565b600080549050905600a165627a7a72305820a254750a8c7dbd3a15120b489c010dee696498d84e7e33a1980c4d490f8c85d80029")
				            .mykmsKeyId(mykmsId)
				            .gas(50000L)
				            .accessId(baas_admin)
				            .token("qwei10whe-waesc")
				            .tenantid("mytenant")
				            .method(Method.DEPLOYCONTRACTFORBIZ).build();
				        BaseResp baseResp=restClient.chainCallForBiz(callRestBizParam);
		- 返回参数
	
			![](./pic/antchain68.png)
		- 返回示例
	
				BaseResp(success=true, code=200, data={"txData":{"data":{"success":true,"transactionReceipt":{"output":...})
	- 异步调用 Solidity 合约
		-  请求地址
		
				/api/contract/chainCallForBiz
		-  请求参数						
	
			![](./pic/antchain69.png)
		- 请求示例
	
				$curl -d '{"orderId":"order1","bizid":"123","account":"myaccount","contractName":"mycontract","methodSignature":"get()","inputParamListStr":"[uint256,uint16]","outTypes":"[uint256]","tenantid":"mytenant","mykmsKeyId":"keyid","method":"CALLCONTRACTBIZASYNC","accessId":"baas_admin","token":"qwei10whe-waesc","gas":10000}' -H "Content-Type: application/json;charset=utf-8" -XPOST https://rest.baas.alipay.com/api/contract/chainCallForBiz
				 
				String orderId = "order_" + System.currentTimeMillis();
				        CallRestBizParam callRestBizParam=CallRestBizParam.builder()
				            .orderId(orderId)
				            .bizid(restClientProperties.getBizid())
				            .account(account)
				            .contractName("test_biz_deploy_contract")
				            .methodSignature("get()")
				            .inputParamListStr("[uint256,uint16]")
				            .outTypes("[\"uint256\"]")
				            .mykmsKeyId(mykmsId)
				            .gas(50000L)
				            .accessId(baas_admin)
				            .token("qwei10whe-waesc")
				            .tenantid("mytenant")
				            .method(Method.CALLCONTRACTBIZASYNC).build();
				        BaseResp baseResp=restClient.chainCallForBiz(callRestBizParam);
		- 返回参数
	
			![](./pic/antchain70.png)
		- 返回示例
	
				BaseResp(success=true, code=200, data=df316046e205b2e13668092c9b3b2801827669931136046426c861f1d0ddad8d)
	- 创建账户（密钥托管）
	
		传入 kmsid，返回公钥。
		
		-  请求地址
		
				/api/contract/chainCallForBiz
		-  请求参数						
	
			![](./pic/antchain71.png)
		- 请求示例
	
				$curl -d '{"orderId":"order1","bizid":"123","account":"myaccount","tenantid":"mytenant","mykmsKeyId":"keyid","method":"CREATEACCOUNT","accessId":"baas_admin","token":"qwei10whe-waesc"}' -H "Content-Type: application/json;charset=utf-8" -XPOST https://rest.baas.alipay.com/api/contract/chainCallForBiz
				 
				String orderId = "order_" + System.currentTimeMillis();
				        String baccount = "haoran_" + System.currentTimeMillis();
				        String kmsId=restClientProperties.getTenantid()+":"+uid+"1234";
				        CallRestBizParam callRestBizParam=CallRestBizParam.builder()
				            .orderId(orderId)
				            .bizid(restClientProperties.getBizid())
				            .account(baccount)
				            .mykmsKeyId(kmsId)
				            .accessId(baas_admin)
				            .token("qwei10whe-waesc")
				            .tenantid("mytenant")
				            .gas(50000L)
				            .method(Method.TENANTCREATEACCUNT).build();
				        BaseResp baseResp=restClient.chainCallForBiz(callRestBizParam);
	
		- 返回参数
	
			![](./pic/antchain72.png)
		- 返回示例
	
				BaseResp(success=true, code=200, data=05a9ab4ceca010501b6e0fe0f4ac2ad88d1c3d8e67a62578e084a9e76cea28e9c4392f9e1709b519f01b19ae85f7edc88c91949151a886ba6919e78fd14db395)
	- 解析合约返回值
		-  请求地址
		
				/api/contract/chainCallForBiz
		-  请求参数						
	
			![](./pic/antchain73.png)
		- 请求示例
			
			无
		- 返回参数
	
			![](./pic/antchain74.png)
		- 返回示例
	
			无
- 查询消息类

	所有查询消息的 URL 统一为：
	
		https://rest.baas.alipay.com/api/contract/chainCall
	使用 Method 来区分不同的接口调用。	
		
	- 查询交易
		-  请求地址
		
				/api/contract/chainCall
		-  请求参数						
	
			![](./pic/antchain75.png)
		- 请求示例
		
				{
				  "accessId":"baas_admin",
				  "bizid":"12eba21a66ed4d2795b833ce7ebd750c",
				  "hash":"cd3b5e4db44d121024a645c93b27ba3e49ca87d6dcc94ffb35e96faf1c1840a8",
				  "method":"QUERYTRANSACTION",
				  "token":"951610a3-1058-4487-acd0-97756ec67e2c"
				}
		- 返回参数
	
			![](./pic/antchain76.png)
		- 返回示例
	
				{
				 "code":"200",
				  "data":"{\"blockNumber\":4868192,\"transactionDO\":{\"data\":\"aGVsbG8gd29ybGQ=\",\"timestamp\":1592397562669}}",
				  "success":true
				}
- 查询交易回执
	-  请求地址
	
			/api/contract/chainCall
	-  请求参数						

		![](./pic/antchain77.png)
	- 请求示例

			{
			   "accessId":"baas_admin",
			  "bizid":"12eba21a66ed4d2795b833ce7ebd750c",
			  "method":"QUERYRECEIPT",
			  "token":"d211cb86-c155-4e11-b073-f406a27b7619"
			}
	- 返回参数

		![](./pic/antchain78.png)
	- 返回示例

			{
			  "code":"200",
			  "data":"{\"blockNumber\":4868192,\"gasUsed\":20110,\"logs\":[{\"from\":{\"data\":\"59PnafP1k9rcuGNMxbCfyQ3TphxKBqecsJI2Yv5vrms=\",\"empty\":false,\"value\":\"59PnafP1k9rcuGNMxbCfyQ3TphxKBqecsJI2Yv5vrms=\"},\"logData\":\"\",\"to\":{\"data\":\"59PnafP1k9rcuGNMxbCfyQ3TphxKBqecsJI2Yv5vrms=\",\"empty\":false,\"value\":\"59PnafP1k9rcuGNMxbCfyQ3TphxKBqecsJI2Yv5vrms=\"},\"topics\":[\"deposit_data\"]},{\"from\":{\"data\":\"59PnafP1k9rcuGNMxbCfyQ3TphxKBqecsJI2Yv5vrms=\",\"empty\":false,\"value\":\"59PnafP1k9rcuGNMxbCfyQ3TphxKBqecsJI2Yv5vrms=\"},\"logData\":\"+En4R/hFoA3l/fGCnZQW/UZYzw9XdgxuMPVh94ukkrUEQbY2lcvqggPtoENmIIeHq808jzjJd6rX8B/NR4CPcO19ZtCeFqx2hous\",\"to\":{\"data\":\"59PnafP1k9rcuGNMxbCfyQ3TphxKBqecsJI2Yv5vrms=\",\"empty\":false,\"value\":\"59PnafP1k9rcuGNMxbCfyQ3TphxKBqecsJI2Yv5vrms=\"},\"topics\":[\"gas_divided\"]}],\"output\":\"\",\"result\":0}",
			  "success":true
			}
			返回内容中59PnafP1k9rcuGNMxbCfyQ3TphxKBqecsJI2Yv5vrms=等需要将该内容进行base64解码为byte[]，再将byte[]通过Hex.toHexString转化为identity
- 查询块头（BlockHeader）
	-  请求地址
	
			/api/contract/chainCall
	-  请求参数						

		![](./pic/antchain79.png)
	- 请求示例

			{
			  "accessId":"baas_admin",
			  "bizid":"12eba21a66ed4d2795b833ce7ebd750c",
			  "method":"QUERYBLOCK",
			  "requestStr":"100",
			  "token":"6e13e618-a9f4-4dc4-8fab-cf9698351fc7"
			}
	- 返回参数

		![](./pic/antchain80.png)
	- 返回示例

			{
			  "code":"200",
			  "data":"{\"block\":{\"blockHeader\":{\"gasUsed\":0,\"hash\":\"ce7e5f668da457f89de2cde06f280562ceb6cd7f77dc9b9940564e235deeb9e4\",\"logBloom\":\"00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\",\"number\":100,\"parentHash\":\"02c6a1a7d2d9bac81a02d8f10b7a231506c430a6061938171551988f67f5067a\",\"receiptRoot\":\"0000000000000000000000000000000000000000000000000000000000000000\",\"stateRoot\":\"0b0199634c9e96b96d4323e65fbb7a7fa17c9a59d3d24762f85104fd9dbd49e5\",\"timestamp\":1583490750594,\"transactionRoot\":\"0000000000000000000000000000000000000000000000000000000000000000\",\"version\":16777986}}}",
			  "success":true
			}
- 查询块体（BlockBody）
	-  请求地址
	
			/api/contract/chainCall
	-  请求参数						

		![](./pic/antchain81.png)
	- 请求示例

			{
			  "accessId":"baas_admin",
			  "bizid":"12eba21a66ed4d2795b833ce7ebd750c",
			  "method":"QUERYBLOCKBODY",
			  "requestStr":"100",
			  "token":"56780675-b52a-43b4-a52d-e134e12dec97"
			}
	- 返回参数

		![](./pic/antchain82.png)
	- 返回示例

			{
			  "code":"200",
			  "data":"{\"header\":{\"number\":100,\"transaction_root\":\"0000000000000000000000000000000000000000000000000000000000000000\",\"gas_used\":0,\"version\":2814762668786434,\"receipt_root\":\"0000000000000000000000000000000000000000000000000000000000000000\",\"hash\":\"ce7e5f668da457f89de2cde06f280562ceb6cd7f77dc9b9940564e235deeb9e4\",\"parent_hash\":\"02c6a1a7d2d9bac81a02d8f10b7a231506c430a6061938171551988f67f5067a\",\"state_root\":\"0b0199634c9e96b96d4323e65fbb7a7fa17c9a59d3d24762f85104fd9dbd49e5\",\"timestamp\":1583490750594,\"log_bloom\":\"00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\"},\"body\":{\"receipt_list\":[],\"consensus_proof\":\"f8eff8c9b841e2267ca2b9c81fc1d42461b09b87806b410021f5e529e922bd8d71688b6bf90d5d3ee9910da95c463de1e2118c424585ca3224826c6b7ba78b0ca0a5bd016e1501b8411e886b1aac98ebcc435bfd7c3ca40c9f1d592511ac428079da122d2dbeaef87723ee6af2b609cca3ae0aa95995c8e3ee1765b25af015ae3c63f1ad1a370de1d501b841f666fe94eb0d304b0607a3fbb0957ba982cefdae925d89f8363ff02ce4730570474331deda6aaf931da654e0c9feb5fb5577c992e08e51be331ed6720612c7a900e38064a0e574e588bd609162cc3d32fc9774fbf86fd8a82a8fd8d633a2096e65dcc73f42\",\"transaction_list\":[]}}",
			  "success":true
			}

- 查询最新块高
	-  请求地址
	
			/api/contract/chainCall
	-  请求参数						

		![](./pic/antchain83.png)
	- 请求示例

			{
			  "accessId":"baas_admin",
			  "bizid":"12eba21a66ed4d2795b833ce7ebd750c",
			  "method":"QUERYLASTBLOCK",
			  "token":"9445dfbf-51a5-406e-8561-6c4b2aed9802"
			}
	- 返回参数

		![](./pic/antchain84.png)
	- 返回示例

			{
			    "code":"200",
			  "data":"{\"block\":{\"blockHeader\":{\"gasUsed\":0,\"hash\":\"25c1f670e2892acc15bee3f7e86dd7f6ad8c66022a4eaf54a546e3f1b08df34f\",\"logBloom\":\"00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\",\"number\":4893889,\"parentHash\":\"92f6ee29cb46577874142c7109502a01b73860fb080db65dbc06b26576d51a14\",\"receiptRoot\":\"0000000000000000000000000000000000000000000000000000000000000000\",\"stateRoot\":\"b12d1648339dc9873e4809eeae6e3c8fd6038f6dd5e3f5111ee18c4ce0658d47\",\"timestamp\":1592474603478,\"transactionRoot\":\"0000000000000000000000000000000000000000000000000000000000000000\",\"version\":33555458}}}",
			  "success":true
			}
- 查询账户
	-  请求地址
	
			/api/contract/chainCall
	-  请求参数						

		![](./pic/antchain85.png)
	- 请求示例

			{
			 "accessId":"baas_admin",
			  "bizid":"12eba21a66ed4d2795b833ce7ebd750c",
			  "method":"QUERYACCOUNT",
			  "requestStr":"{\"queryAccount\":\"ff89d3d4569342028b4767e779e55994\"}",
			  "token":"4d7c9e42-ff8f-4f38-8fe7-a4efbdba72ec"
			}
	- 返回参数

		![](./pic/antchain86.png)
	- 返回示例

			{
			    "code":"200",
			  "data":"{\"recovery_key\":\"eb716ed3d6755bb9a6cc9b44a5d5c18194ce5243648eb858953504d27e4bb07eb71ee4ff66410f32ff2bb704c4b6e94c8afabce21e36cbf5e59975d87457f0ae\",\"balance\":0,\"auth_map\":[{\"value\":100,\"key\":\"eb716ed3d6755bb9a6cc9b44a5d5c18194ce5243648eb858953504d27e4bb07eb71ee4ff66410f32ff2bb704c4b6e94c8afabce21e36cbf5e59975d87457f0ae\"}],\"encryption_key\":\"\",\"id\":\"3360513e31c13c319a708376f6b3a6dc68f0b655c9cf9545c811c1da63f602cd\",\"recovery_time\":0,\"version\":2,\"status\":0}",
			  "success":true
			}
### Solidity 合约开发
#### 说明
蚂蚁链平台支持的 solidity 语法基本与官方solidity基本一致，目前支持0.4.24和0.6.4版本，所以可以参考官方文档：

蚂蚁链会对提交的每一笔交易收取一定的燃料（gas），目的在于限制单笔交易使用的计算资源，防止计算资源浪费及收取计算资源的使用费。虚拟机在执行交易时，燃料将按特定规则逐渐耗尽。

交易发起账户发送交易时会消耗燃料，因此用户需要设置 setTxGas 作为本次交易的 gaslimit。如果实际交易执行后还有剩余燃料，则剩余燃料会原路返还到账户余额中；如果实际交易所需燃料超过预设的 gaslimit，无论交易执行到什么位置，都将会触发异常。当前交易所做的所有状态修改都将被回滚，且被消耗的燃料不会返还。

	gaslimit 不能超过 1 亿，否则交易执行会失败。如果实际业务中，1 亿的 gaslimit 无法满足需求，可 提交工单 进行反馈。
#### 蚂蚁链 Solidity vs. 以太坊 Solidity
- 蚂蚁链平台中，solidity 合约使用 identity 替代官方 solidity 的 address 关键字。identity 表示的合约地址或账户地址，均为为32字节，而官方 solidity 中 address 表示的地址是20字节。
- 蚂蚁链合约不支持 suicide，也不支持 selfdestruct。
- 蚂蚁链合约不支持在合约内创建合约，因此不要在合约内使用 new 来创建合约。
- 在蚂蚁链平台上，如果尝试在合约内向一个不存在的地址转账，合约会异常终止，并返回错误码 10303；而在以太坊官方 Solidity 合约内向不存在的地址转账时，系统会自动以该地址创建账户。
- 对于 `<identity>.balance (uint256)` 语句，如果 identity 代表的账户不存在，则在蚂蚁链平台中该语句会造成合约异常终止，并返回错误码 10300；而在以太坊官方 Solidity 合约中，该语句会返回 0，不会造成合约异常终止。
- 在蚂蚁链平台中，合约内的 block.number、block.timestamp 分别指最新已形成的区块（即本交易所在区块的上一个区块）的高度和时间戳（毫秒）；而在官方 Solidity 合约中，这两个参数分别指的是本交易所在区块的高度和时间戳。
- 蚂蚁链平台不提供 ripemd160 这个散列算法。
- 蚂蚁链平台中，solidity 合约内不支持 CHAINID 指令
- 蚂蚁链平台中，如果 solidity 合约执行过程中异常终止，终止之前产生的 Event Log 依然会出现在交易回执中。

#### 开发参考手册
- [指令集](https://antchain.antgroup.com/docs/11/143752) 指令集与Gas公式
- VERIFY_SIG_ECC

	验证一个ECC签名是否正确。
	
	- VERIFY_SIG_RSA

		验证一个RSA签名是否正确，以源消息、公钥、签名三元组作为入参。
	- VERIFY_SIG_RSA_DIGEST

		验证一个RSA签名是否正确，以源消息、公钥、签名三元组作为入参。
- [预编译合约](https://antchain.antgroup.com/docs/11/143752) 

	预编译合约地址前31个字节均为0，我们只写出最后一个字节。
	
#### Solidity 积分 demo
蚂蚁链合约平台对积分管理方案的简单实现，主要实现了积分的发放、转账和查询三个方法

	pragma solidity ^0.4.0;
	 
	contract CreditManager {
	    int256 creditLimit = 1000000000;   // the issue limit
	    int256 issueAmount = 0;           // the issue total amount
	    identity admin;                    // the administrator in contract
	 
	    mapping(identity=>int256) credit;
	 
	    event IssueEvent(identity indexed to, int256 indexed value);
	    event TransferEvent(identity indexed from, identity indexed to, int256 indexed value);
	 
	    function CreditManager() {
	        admin = msg.sender;
	    }
	 
	    // modifier
	    modifier onlyAdmin() {
	        require(msg.sender == admin,"Permission denied");
	        _;
	    }
	 
	    // issue credit and only admin can 
	    function Issue(identity account, int256 value) public onlyAdmin returns(bool) {
	        // the value should bigger than 0, and issueAmount add value should small than issueAmount
	        require(issueAmount + value <= creditLimit && issueAmount + value > issueAmount && value > 0, "Invalid value!");
	        credit[account] += value;
	        issueAmount += value;
	        IssueEvent(account,value);
	        return true;
	    }
	 
	    function Transfer(identity account,int256 value) public returns(bool) {
	        require(credit[msg.sender] >= value, "balance not enough!");
	        require(value > 0 && value <= creditLimit, "Invalid value!");
	        credit[msg.sender] -= value;
	        credit[account] += value;
	        TransferEvent(msg.sender,account,value);
	        return true;
	    }
	 
	    function Query(identity account) public returns(int256) {
	        return credit[account];
	    }
	}
- 代码分析
	- 声明合约版本

		首先，合约需要声明其版本，合约具体实现以 contract 关键字声明开始。

		如下代码所示（截取自上述代码示例，下同），蚂蚁链合约平台基于 Solidity 的 0.4.24 版本进行了修改与设计，支持 0.4.24 版本之前的各种特性。
	
			pragma solidity ^0.4.0;
			contract CreditManager {
	- 声明变量

		本合约示例中，定义了两个变量来保存积分的总量（creditLimit）和目前发放的数量（issueAmount），并使用 identity 类型来标注每一个用户的身份，如合约的管理员（admin）账户，identity 的长度为 32 字节，每个 identity 在蚂蚁链上具有唯一性，所以合约通过 identity 来标注用户的积分。
		
			int256 creditLimit = 1000000000;   // the isuue limit
			int256 issueAmount = 0;           // the issue total amount
			identity admin;                   // the administrator in contract
			mapping(identity=>int256) credit;
	- 声明事件

		本合约示例中，声明了两个事件来记录对应的方法执行的情况，一个是积分发放的事件记录（IssueEvent），另一个则是积分转账的事件记录（TransferEvent），具体日志使用参见 事件和日志。

			event IssueEvent(identity indexed to, int256 indexed value);
			event TransferEvent(identity indexed from, identity indexed to, int256 indexed value);
	- 构造函数

		在构造函数中，设置合约管理员（admin）账户 ID，再使用关键字 modifier 设置管理员权限。关键字的具体说明参见 [合约关键字](https://antchain.antgroup.com/docs/11/143751#)。

			function CreditManager() {
			    admin = msg.sender;
			}
			 
			// modifier，when mas.sender != admin, the contract will show "Permission denied" in output
			modifier onlyAdmin() {
			    require(msg.sender == admin,"Permission denied");
			    _;
			}
	- 定义实现方法

		本示例中，合约实现了积分的发放、转账和查询方法。
		
		如下代码所示，在调用积分发放方法中，通过 onlyAdmin 来保证发放操作只能通过管理员来进行，然后向用户传入的账户中增加相应的积分，发放过程中需要注意积分的溢出问题，发放完毕后，可以触发积分发放事件，用户可以在调用合约发放方法结果的日志中看到该事件记录。

			// issue credit and only admin can 
			    function Issue(identity account, int256 value) public onlyAdmin returns(bool) {
			        // the value should bigger than 0, and issueAmount add value should small than issueAmount
			        require(issueAmount + value <= creditLimit && issueAmount + value > issueAmount && value > 0, "Invalid value!");
			        credit[account] += value;
			        issueAmount += value;
			        IssueEvent(account,value);
			        return true;
			    }
		合约的转账与发放类似，但是转账不需要有管理员权限即可执行，查询积分也是一样。

#### 合约编译工具
蚂蚁链合约平台支持 Solidity 智能合约，针对合约源代码的编译，可以直接通过蚂蚁链 Cloud IDE 合约开发环境进行合约编译、部署、测试和调试。

本文除介绍由蚂蚁链平台提供的 Solidity 编译工具 solc-js 的下载、安装和使用方式外，还对二进制 solc 编译工具进行简要说明。

- 下载 solc-js

	蚂蚁链对 Solidity 语言的支持与原生的 Solidity 语言不同，因此不能使用外部社区的 solc-js 编译工具。
	开放联盟链提供的 solc-js：alipay-solc-0.1.12.tgz 可兼容 Solidity 语言 0.4.24 版本之前的语法（不包含 0.4.24）。

	- 点击[此处](https://docs-aliyun.cn-hangzhou.oss.aliyun-inc.com/assets/attach/101793/AntCloud_zh/1552962327948/alipay-solc-0.1.12.tgz)下载0.4.24版本 获取合约编译工具 solc-js 安装包：alipay-solc-0.1.12.tgz（约 1.76M）。
		- [官方手册](https://solidity.readthedocs.io/en/v0.4.24/) 
	- 点击[此处](http://docs-aliyun.cn-hangzhou.oss.aliyun-inc.com/assets/attach/143755/AntCloud_zh/1619614806150/alipay-solc-0.6.4.tgz)下载0.6.4版本获取合约编译工具 solc-js 安装包：alipay-solc-0.6.4.tgz（约 2.3M）
		- [官方手册](https://solidity.readthedocs.io/en/v0.6.4/) 
- 安装 solc-js
	- 安装

		solc-js 工具依赖 Node.js 环境，因此需要先安装 Node.js，然后安装 solc-js。具体步骤如下：

		- 下载并安装 [Node.js](https://nodejs.org/en/)（推荐版本：v10.11.0）。
		- 全局安装 solc-js。在下载的 alipay-solc-0.1.12.tgz 所在目录执行以下命令：

				npm i alipay-solc-0.1.12.tgz -g
			或	 
			
				npm i alipay-solc-0.6.4.tgz -g
	- 使用 solc-js 

		全局安装 solc-js 工具后，即可在命令行中直接使用此工具，可以通过 solcjs --help 来查看此工具支持的参数说明。

		命令行语法：
		
			Usage: /usr/local/bin/solcjs [options] <FILE_NAME>
		- --version
			- 说明：显示版本号
			- 类型：布尔
		- --optimize
			- 说明：启用字节码优化器
			- 类型：布尔
		- --bin
			- 说明：十六进制合约的二进制
			- 类型：布尔
		- --abi
			- 说明：合约接口说明
			- 类型：布尔
		- --standard-json
			- 说明：打开标准 JSON 输入或输出模式
			- 类型：布尔
		- --output-dir，-o
			- 说明：合约输出的目录
			- 类型：字符串
		- --help
			- 说明：显示帮助信息
	- 编译示例
	
		创建名为 hello.sol 的 Solidity 合约示例

			pragma solidity <=0.6.4;
			 
			contract Hello {
			 
			    string name;
			    identity id; //identity 类似于原生 Solidity 语言的 address
			 
			    constructor() public {
			        name = 'Hello world!';
			    }
			 
			    function hello() view public returns (identity, string memory) {
			        return (msg.sender, name);
			    }
			}
		- 命令行编译合约(二进制 solc 编译工具)

			solc-js 编译工具能支持多系统平台运行，并且可以结合 JS SDK 自动化部署、调用合约，使用方便。solc-js 在命令行支持 --bin参数，但是不支持通过 --bin-runtime 参数来编译升级合约接口所需要的字节码。

			solc-js 工具在 JS 代码中默认也使用 --bin 参数编译合约得到字节码，此字节码不能直接用于合约升级，但是通过一次“本地合约部署”之后即可得到 runtime 字节码，用于合约升级使用。详情可参考 JS SDK 使用说明。

			二进制 solc 编译工具同时支持 --bin-runtime 和 --bin 参数，这两个参数在编译结果上的主要差异在于，针对相同的目标Solidity 合约，使用 --bin-runtime 参数的编译字节码是 --bin 参数编译字节码的一部分。--bin 参数编译字节码除了包含--bin-runtime 参数的编译字节码结果之外，还包含合约初始化方法 constructor 的相关字节码等内容。

			因此，如果需要使用 SDK 的升级合约接口，建议使用二进制 solc 编译工具，通过 --bin-runtime 参数来直接编译得到升级合约的字节码：
			
			- 下载
				- [solc-mac-0.1.12.zip](https://docs-aliyun.cn-hangzhou.oss.aliyun-inc.com/assets/attach/101793/AntCloud_zh/1552962788165/solc-mac-0.1.12.zip)
				- [solc-centos7.2-0.1.12.zip](https://docs-aliyun.cn-hangzhou.oss.aliyun-inc.com/assets/attach/101793/AntCloud_zh/1552963406464/solc-centos7.2-0.1.12.zip)
				- [solc-centos7.2-0.6.4.zip](https://docs-aliyun.cn-hangzhou.oss.aliyun-inc.com/assets/attach/143755/AntCloud_zh/1597995439039/solc-centos7.2-0.6.4.zip)
				- [solc-mac-0.6.4.zip](https://docs-aliyun.cn-hangzhou.oss.aliyun-inc.com/assets/attach/143755/AntCloud_zh/1598342597226/solc-mac-0.6.4.zip)
			
			- 运行以下命令行，编译 hello.sol 合约并得到编译字节码结果
			
					solcjs --bin hello.sol
				如果编译通过，此目录会得到包含字节码的结果文件 hello_sol_Hello.bin，如果编译失败则提示错误信息。
			- 运行以下命令行，编译 hello.sol 合约并得得到合约接口说明（ABI）

					  solcjs --abi hello.sol
				如果编译通过，此目录会得到包含合约接口说明（ABI）的结果文件 hello_sol_Hello.abi
		- JS 代码中编译合约
			- 创建目录 solcjs-test，执行 npm init，将 alipay-solc-0.1.12.tgz 文件放到 solcjs-test 目录。
			- 运行以下命令行，在 solcjs-test 目录中安装 solc-js：

					npm i alipay-solc-0.1.12.tgz --save
			- 代码中编译合约，创建 index.js 文件内容如下：
 
					 var solc = require('@alipay/solc')
					 var input = 'contract test { function g(identity a) {} }'
					 // Setting 1 as second paramateractivates the optimiser
					 var output = solc.compile(input, 1)
					 for (var contractName in output.contracts) {
					   // code and ABI
					   console.log(contractName + ': ' + output.contracts[contractName].bytecode)
					   console.log(contractName + ': ' + output.contracts[contractName].interface)
					 }
			- 运行 index.js
			
					node index.js
			- 运行的输出供参考(使用上面两个不同的编译器会得到不同的字节码，但是其功能是一样的)，已包含编译字节码和合约接口说明（ABI）：

					 :test: 6080604052348015600f57600080fd5b5060898061001e6000396000f300608060405260043610603e5763ffffffff7c010000000000000000000000000000000000000000000000000000000060003504166338a1231d81146043575b600080fd5b348015604e57600080fd5b506058600435605a565b005b505600a165627a7a7230582008d3450904d4f09535ba76326aae5ecd2f61113b791d633dbb3c0799ff75b3ad0029
					 :test: [{"constant":false,"inputs":[{"name":"a","type":"identity"}],"name":"g","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"}]
		- solc-js 与 JS SDK 结合使用

			在 JS 代码中编译 Solidity 合约后，得到编译字节码和合约接口说明（ABI），进而可直接使用 JS SDK 来部署、调用合约。详情可参考 JS SDK 使用说明。 
			  				
#### 合约数据类型
- 基本数据类型

	蚂蚁链合约平台基本支持 Solidity 所有的数据类型，但是对于一些用户编写的合约的输入参数类型并没有完全的支持，比如参数输入中二维数组的输入。同时，蚂蚁链合约平台提供了 identity 类型来标注每一个用户的身份，不支持原生 Solidity 中的 address 类型，identity 的长度为 32 字节。

	建议使用数据类型示例如下	

	![](./pic/antchain87.png)
	
	说明：

	- 合约内部使用：指在合约内部的使用
	- 输入参数：指在客户端调用函数方法时传入参数的类型

	比如在前述的 积分管理合约 的发放方法中，identity 类型和 int256 类型属于输入参数的类型，在合约内部和输入参数都支持。
	
		function Issue(identity account, int256 value)
	但是，对于用户积分和账户 ID 对应的声明类型 mapping，在合约内部使用时是可以的，但是无法作为函数的传入类型，如下所示
	
		function example(mapping(identity=>int256) map)  // 错误，不支持 mapping 作为输入参数类型
- 其他类型

	除了上述数据类型外，Solidity 还支持其他类型，比如：

	- 映射、字典（mapping）
	- 结构体（struct）
	- 时间单位（seconds，minutes，hours，days，weeks，years）
	
	更多信息，可查看 Solidity [文档](https://solidity.readthedocs.io/en/v0.4.24/types.html)。

#### 合约关键字
蚂蚁链合约平台支持的 Solidity 语法基本与官方文档基本一致

- 函数类型的构造方式

		function (<parameter types>) {public | private | internal | external} [modifier] [pure|constant|view|payable] [returns (<return types>)]
- 函数权限关键字
	- public：只有 public 类型的函数才可以供外部访问，当一个状态变量的权限为 public 类型时，它就会自动生成一个可供外部调用的 get 函数。当函数声明时，它默认为是 public 类型，而状态变量声明时，默认为 internal 类型。
	- private：只能在当前类中进行访问，子类无法继承，也无法调用或访问。
	- internal：子类继承父类，子类可以访问父类的 internal 函数，同时，使用 using for 关键字后，本类可以使用被调用类的 internal 函数。
	- external：被声明的函数只能在合约外部调用
- 函数修饰关键字
	- modifier：被 modifier 关键字声明的关键字所修饰的函数只能在满足 modifier 关键字声明的关键字的要求后才会被执行，比如声明某函数只有管理员有权限，则可以参考以下实现

			  modifier onlyAdmin() {
			      require(msg.sender == admin, "Permission denied");
			      _;
			  }
			  function set(uint a) public onlyAdmin returns(uint) {
			      .....
			  }
	- constant：被声明为 constant 的状态变量只能使用那些在编译时有确定值的表达式来给它们赋值。任何通过访问 内存、链数据（例如 now，this.balance 或 block.number）或执行数据（msg.gas）或对外部合约的调用来给它们赋值都是不允许的。不是所有类型的状态变量都支持用 constant 来修饰，当前支持的仅有值类型和字符串。
	- view：被该关键字修饰的状态变量只能读取其值，不能对该状态变量的值进行修改。
	- pure：被该关键字修饰的状态变量既不能读取变量，也不能修改该变量。
	- Storage：Storage 变量是指永久存储在链中的变量。
	- Memory：Memory 变量则是临时的，当外部函数对某合约调用完成时，内存型变量即被移除
- 函数参考
	
	蚂蚁链合约平台在 Solidity 的基础上，添加了部分函数库的支持，包括对 JSON/XML 数据格式的构造和解析，采用预编译合约的方式加入到蚂蚁链合约平台中，其使用方式如下所示：
	
		pragma solidity ^0.4.23;
		 
		contract test_parse {
		    // test json interface
		    function test_property_parse_json() public returns (uint)
		    {
		        string memory property_value;
		        int property_type;
		        property_value = "{\"node_config\" : {\"identity\" : \"true\",\"key_path\" : \"../../user\",\"user_keys\" : [{\"key_name\" : \"Tester001.key\",\"key_passwd\" : \"123456a\"},{\"key_name\" : \"Tester002.key\",\"key_passwd\" : \"123456a\"}],\"node\" : {\"ip\" : \"127.0.0.1\",\"port\" : 18130}}}";
		        property_type = 0;
		 
		        // 第一步调用 property_parse
		        uint handler = property_parse(property_value, property_type);
		        // 然后获取 JSON 属性值；
		        test_property_get_bool(handler);
		        test_property_get_int(handler);
		        test_property_get_uint(handler);
		        test_property_get_string(handler);
		        test_property_get_array(handler);
		        test_property_get_list_count(handler);
		        // 最后释放资源
		        test_property_destroy(handler);
		        return handler;
		    }
		 
		    // test xml interface
		    function test_property_parse_xml() public returns (uint)
		    {
		        string memory property_value;
		        int property_type;
		        property_value = "<?xml version=\"1.0\" encoding=\"utf-8\"?><node_config  key_path=\"../../user\"> <![CDATA[cdata]]><identity>true</identity><user_keys> <key_name>Tester001.key</key_name>  <key_passwd>123456a</key_passwd> </user_keys>  <user_keys> <key_name>Tester002.key</key_name>  <key_passwd>123456a</key_passwd> </user_keys>  <node> <ip>127.0.0.1</ip>  <port>18130</port> </node> </node_config>";
		        property_type = 1;
		 
		        // 第一步调用 property_parse
		        uint handler = property_parse(property_value, property_type);
		        // 然后获取 XML 属性值；
		        test_property_get_bool(handler);
		        test_property_get_int(handler);
		        test_property_get_uint(handler);
		        test_property_get_string(handler);
		        test_property_get_array(handler);
		        test_property_get_cdata(handler);
		        test_property_get_attr(handler);
		        test_property_get_list_count(handler);
		        // 最后释放资源
		        test_property_destroy(handler);
		        return handler;
		    }
	- json 与 xml 解析库
		- property_destroy	
		
			删除 JSON 与 XML 字符串数据解析标志符
			
				    function test_property_destroy(uint hanlder) public returns (bool)
				    {
				        return property_destroy(hanlder);
				    }
		- property_get_bool
		
			解析 JSON 与 XML 中的 bool 类型的节点数值。
			
				    function test_property_get_bool(uint hanlder) public returns (int, bool)
				    {
				        string memory path;
				        path = "node_config.identity";
				        int err;
				        bool ret;
				        (err, ret) = property_get_bool(hanlder, path);
				        return (err, ret);
				    }
		- property_get_int
		
			解析 JSON 与 XML 中的 int 类型的节点数值。
			
				    function test_property_get_int(uint hanlder) public returns (int, int)
				    {
				        string memory path;
				        path = "node_config.node.port";
				        int err;
				        int ret;
				        (err, ret) = property_get_int(hanlder, path);
				        return (err, ret);
				    }
		- property_get_uint

			解析 JSON 与 XML 中的 uint 类型的节点数值。
			
				    function test_property_get_uint(uint hanlder) public returns (int, uint)
				    {
				        string memory path;
				        path = "node_config.node.port";
				        int err;
				        uint ret;
				        (err, ret) = property_get_uint(hanlder, path);
				        return (err, ret);
				    }
		- property_get_string
		
			解析 JSON 与 XML 中的 string 类型的节点数值
			
				    function test_property_get_string(uint hanlder) public returns (int, string memory)
				    {
				        string memory path;
				        path = "node_config.node.ip";
				        int err;
				        string memory ret;
				        (err, ret) = property_get_string(hanlder, path);
				        return (err, ret);
				    }
		- property_get_array
				    
			    function test_property_get_array(uint hanlder) public returns (int, string memory)
			    {
			        // string memory path;
			        // path = "node_config.user_keys[0].key_name";
			        int err;
			        string memory ret;
			        (err, ret) = property_get_string(hanlder, "node_config.user_keys[0].key_name");
			        return (err, ret);
			    }
		- property_get_list_count

			property_get_list_count 接口函数用于解析 JSON 或 XML 中的节点列表大小
			
			    function test_property_get_list_count(uint hanlder) public returns (uint) {
			        return property_get_list_count(hanlder, "node_config.user_keys");
			    }
		- property_get_cdata
		
				function test_property_get_cdata(uint hanlder) public returns (int, string memory)
				    {
				        string memory path;
				        path = "node_config.<xmlcdata>";
				        int err;
				        string memory ret;
				        (err, ret) = property_get_string(hanlder, path);
				        return (err, ret);
				    }
		- property_get_attr
		  		    
				    function test_property_get_attr(uint hanlder) public returns (int, string memory)
				    {
				        string memory path;
				        path = "node_config.<xmlattr>.key_path";
				        int err;
				        string memory ret;
				        (err, ret) = property_get_string(hanlder, path);
				        return (err, ret);
				    }
				}
		 
		- 属性设置  
		
				contract test_write {
				    ///////test this interface only
		- property_write
		
			property_write 接口函数用于生成 JSON 或 XML 格式的数据
			
				function test_property_write() public returns (string memory)
				    {
				        string memory property_value;
				        int property_type = 0;
				 
				        // 第一步调用 property_parse 
				        uint handler = property_parse(property_value, property_type);
				        // 然后设置各属性值
				        test_property_set_bool(handler);
				        test_property_set_int(handler);
				        test_property_set_uint(handler);
				        test_property_set_string(handler);
				        property_type = 1;
				        // 生成 xml/json
				        string memory ret = property_write(handler, property_type);
				        property_destroy(handler);
				        return ret;
				    }
		- property_set_bool
		
			构造 JSON 与 XML 格式的数据，向其中插入 bool 类型数据
			
				function test_property_set_bool(uint handler) public returns (bool)
				    {
				        string memory path;
				        path = "a.b.c";
				        return property_set_bool(handler, path, true);
				    }
		- property_set_int

			构造 JSON 与 XML 格式的数据，并向其中插入 int 类型数据。
			
			    function test_property_set_int(uint handler) public returns (bool)
			    {
			        string memory path;
			        path = "e.f.g.h";
			        return property_set_int(handler, path, 0x12);
			    }
		- property_set_uint
			
			构造 JSON 与 XML 格式的数据，并向其中插入 uint 类型数据
			
			    function test_property_set_uint(uint handler) public returns (bool)
			    {
			        string memory path;
			        path = "h.m.l";
			        return property_set_uint(handler, path, 1);
			    }
		- property_set_string
		
			构造 JSON 与 XML 格式的数据，并向其中插入 string 类型数据
			
			    function test_property_set_string(uint handler) public returns (bool)
			    {
			        string memory path;
			        path = "a.b.g";
			        string memory val;
			        val = "testhahahaha";
			        return property_set_string(handler, path, val);
			    }
		- property_set_cdata
			    
			    function test_property_set_cdata(uint handler) public returns (bool)
			    {
			        string memory path;
			        path = "zz.<xmlcdata>";
			        string memory val;
			        val = "cdata";
			        return property_set_string(handler, path, val);
			    }
		- property_set_attr			    
		    
			    function test_property_set_attr(uint handler) public returns (bool)
			    {
			        string memory path;
			        path = "zz.<xmlattr>.attr";
			        string memory val;
			        val = "attr";
			        return property_set_string(handler, path, val);
			    }
		- property_remove
			    
			    function test_property_remove(uint handler) public returns (bool)
			    {
			        string memory path;
			        path = "a.b.g";
			        return property_remove(handler, path);
			    }
				}
- 隐私接口函数例

	蚂蚁区块链平台在支持原生 Solidity 的接口基础上，又添加了部分隐私接口函数，主要包括三个函数：

	- 验证承诺(返回布尔 true or false)
	
			function test_verify_commitment() public returns (bool)
			{
			    bytes memory b2 = new bytes(65);
			    string memory name = "abcdefghijklmnopqrstuvwxyz";
			    b2 = "0123456789012345678901234567890123456789012345678901234567890123";
			    identity addr = 0x123456;
			    return verify_commitment(name, 0x30, addr,  b2);
			}
	- 验证余额(返回布尔 true or false)			
		
			function test_verify_balance() public returns (bool)
			{
			   return verify_balance(0x21);
			}
	- 验证范围(返回布尔 true or false)
		
			function test_verify_range() public returns (bool)
			{
			    return verify_range(0x10, 0x20);
			}
- 签名校验接口函数

	平台还添加了对签名验证的接口函数支持，其使用示例如下所示
	
	- 函数原型

			verify_sig_rsa(bytes hash, bytes pub, bytes sig) returns(bool result);
	- 参数
		- hash
			- 字节
			- 消息数据，原始的消息。如果是 ASCII 字符串，需要转换为 bytes。 
		- pub
			- 字节
			- 公钥数据，用户的公钥，要求编码为 X509 DER。如果原公钥为 PEM 格式，需要先进行 Base64 解码。  
		- sig
			- 字节
			- 签名数据，原始消息的签名，要求编码为 PKCS#1 DER。如果是 PEM 格式，需要先进行 Base64 解码 
	- 例		
		
			contract VerifyRsa {
			    function hexstring2byte(bytes1 bp1,bytes1 bp2) public returns (bytes1) {
			        byte bp3;
			        byte bp4;
			 
			        if(bp1 >= 0x30 && bp1 <= 0x39) {
			            bp3 = byte(uint8(bp1) - 0x30);
			        }
			        if(bp1 >= 0x41 && bp1 <= 0x46) {
			            bp3 = byte(uint8(bp1) - 0x41 + 10);
			        }
			        if(bp1 >= 0x61 && bp1 <= 0x66) {
			            bp3 = byte(uint8(bp1) - 0x61 + 10);
			        }
			 
			        if(bp2 >= 0x30 && bp2 <= 0x39) {
			            bp4 = byte(uint8(bp2) - 0x30);
			        }
			        if(bp2 >= 0x41 && bp2 <= 0x46) {
			            bp4 = byte(uint8(bp2) - 0x41 + 10);
			        }
			        if(bp2 >= 0x61 && bp2 <= 0x66) {
			            bp4 = byte(uint8(bp2) - 0x61 + 10);
			        }
			 
			        return ((bp3<<4) | bp4);
			    }
			
			// verify_sig_rsa 1024 bit 为签名校验函数     
			function test_verify_sig_rsa1024() public returns (bool)
			    {
			        bytes memory pub2 = new bytes(162);
			        bytes memory sig2 = new bytes(128);
			        bytes memory msg = new bytes(5);
			 
			        bytes memory spub = new bytes(162*2);
			        bytes memory ssig = new bytes(128*2);
			        msg  = "hello";
			        spub = "30819f300d06092a864886f70d010101050003818d0030818902818100c56a48792cf3a070e2b00a13b528cf1b4a101df653d04d8fef5244f8cf73876044bf1d0fe8f999651d7ae962afc8e3fd6630e0b5bbbf45cf8898936e3e3ac50f977015bdc1b0e077270b21789da72a5b89e2c18f5740dedb5b3ee582a60d6f5406b5350904dd64580d6b9ba65d2bd584a32da45c14c78c789126a45d44df6be50203010001";
			        ssig = "18b8e7861d041ab6edf23647d25765f60055daae6d14de63e3505afa3a3f7831bb926d985ba9c30b2ff20a62ce9b409605f9df635c306530e29b5ff80d8ff75161ad70de18dcc3ea44a7992e895251542065c1f827ca242526addceb747cc5f5c1ed87f5c940b0a1a8a8c874672c04a868df3b05f82625ac047c5ddb4d5064e5";
			 
			        for (uint ip = 0; ip < 162; ip++) {
			            pub2[ip] = hexstring2byte(spub[2*ip], spub[2*ip+1]);
			        }
			 
			        for ( ip = 0; ip < 128; ip++) {
			 
			            sig2[ip] = hexstring2byte(ssig[2*ip], ssig[2*ip+1]);
			        }
			 
			        return verify_sig_rsa(msg, pub2, sig2);
			    }
			 
			    // verify_sig_rsa 2048 bit 为签名校验函数  
			    function test_verify_sig_rsa2048() public returns (bool)
			    {
			        bytes memory pub2 = new bytes(294);
			        bytes memory sig2 = new bytes(256);
			        bytes memory msg = new bytes(5);
			 
			        bytes memory spub = new bytes(294*2);
			        bytes memory ssig = new bytes(256*2);
			 
			        msg  = "hello";
			        spub = "30820122300d06092a864886f70d01010105000382010f003082010a0282010100a2ab422dcdfd5e333ad5046d7c10a8f6776d57ed5b4e32d0d3187994a9d45c363d29ebde2e84c615db9261c0053c659a27ef050268bd6a9c39ac74bda904f8e2f54b9e0d15e98c0ba5b4cc9c8c1c8156287d43af181b8983cfafbbc76841fb035c4672491037d5ade9abb772ee11e1d5932d39ed8162426f798e62e623022718564b271f6aa2f4fb12c0215f4ed279d3d5c81a3692b5ce0d75a67f2d9cbfc1964f14523ce2d2ac6188cc41c5142853594aaf7446b3745b98ecbfa1b95ec828d1e8879ce3707f977d0d77e737d0ef473e17853161beb4019bd4be5fa91af1d3e9164df90355b1f561bf5597748eb93b53405dddba45c0bf6c46f8e0fba278bf4f0203010001";
			        ssig = "27e0fc850cb0dc27756fe49898eeac5e32376eff15f476236cfd650d58f63a5969f473669df2c058ea278e1c73ccb0572f909ab867936ef8c46e91569471710f4ccff047b70c8ec3862608d4fec0f28d1148fe228afb31fdd57b76f41a765969bff523368aeef71f24c025c39ea2449280b4f0f0a526008691a58c8ebcf8abcfea3602f28b482249962c937306cacc860a60f0a84ddc3341550f0a64612b18898fafba7de1bc8d4a6416f5502ab1c6606c360f5fe32316aadccae7b08fef336cee0af4ff87d0f2dc264feacf4340603eed9a4bfcd9aed7e0710a2c4c44f5cd06fb55c8d6441636ea219064a257b635d0996c155bc8f6ae796f4653466dfd678e";
			 
			        for (uint ip = 0; ip < 294; ip++) {
			            pub2[ip] = hexstring2byte(spub[2*ip], spub[2*ip+1]);
			        }
			 
			        for ( ip = 0; ip < 256; ip++) {
			 
			            sig2[ip] = hexstring2byte(ssig[2*ip], ssig[2*ip+1]);
			        }
			 
			        return verify_sig_rsa(msg, pub2, sig2);
			    }
			 
			    // verify_sig_rsa 4096 bit 为签名校验函数  
			    function test_verify_sig_rsa4096() public returns (bool)
			    {
			        bytes memory pub2 = new bytes(550);
			        bytes memory sig2 = new bytes(512);
			        bytes memory msg = new bytes(5);
			 
			        bytes memory spub = new bytes(550*2);
			        bytes memory ssig = new bytes(512*2);
			        msg  = "hello";
			        spub = "30820222300d06092a864886f70d01010105000382020f003082020a0282020100af19134848e0735ac6f94b4ba3bada2ce8c3966e87754d7b2d901bafa2959bc80a39a737b3e1fc69ccef3f5606d59632ac7eaa0d87f8148faff7d0c6b0a825ad64893628a849f9576fc3f8c81bda1e9dee82093adda886d9761e3307e5eda579a22c97b1b0860ad1289ae76c618373e087d4c16ba9e511323e5f7ca16133c2cbaecb5ba1d79b384b48f716e252e159a4070e6b9b689228c931a031b05a2c73ca9257fdf77546f7c92fa1d6875aaa02181964c4e7181fc27b5deb32ad8180e7e931cc7697abba7bddb565d92ad8b9f0a0ea46ad1a1aca6a3ed22c2dd6047da5582b32ea558e76617b4b62560e1dbad9ea7255b487430f6dd28e89ea74d5bd1adfe8afadb4ca714786bd9119d8097fa6316ee101c3c00a6654643f9e66dc521162a289f709c0ea67d500189485923258442c9b00e79f7c09788149545e72c675ad83f07626c150b764a4d091bbf417b3b2bc40e147566c14c478444f368ff841902b2e13961a615bf9ee5c081f3ad33c7f18398eecd8f3ef4fe55304b6e4cf9140fca84fbb8e7f0f74ec11b25332c480a4514119920e368e78154c33f32531fbb1acafb0ba667a8c7d49627f2c95c8db87d57012635653ae75229d8042e912fe101b9f660cae3410406fc1fcdc5bbc405b32949dd6b490fe9b5c0380760484fc2dc7892c03e8db8190eac7558457afbc99d1049d18abef3dd8ef47b8d8347503e10203010001";
			        ssig = "5408d84e7a28002020838d017a89c40158ebe54a9e8d4b8dc9deeaa57030f2510b4e858a474cc20c330732773add0a0dca65dfbcc9853b7d27468dd37476711eafcc722da14e05f3cff0c1e36fadf3471c953a6c130d95f4c87e4a156110fb69ae821879a42e1689c0563ede9376cb0e297526d486988c2a69a9b5dc7ceeafbde5b7d1773af2413f238f6807e7dafb8eec25d3a0b8895c10b265edc1de661d273483fc31c6f627ec3d6a253b52de6acac451eee2832ed1231aea22085c8a8c4ebca548aa1466e2d9c493e119ade8bed1f4b19960ff55fa68a7143a53a662a4a77afea92745774c60f0642a633a8b10ea939c833707d4b636f9dd1430b9b6ab5fb6930e58164b949e06f532ea39219fac07dd7ae15511cfbcc02823bdba5ff7977266efdce93916ae00f00d97c1c1bb6403f7be93d4043320a35373b11c110d0191e344e6c465a72de9d4b4e2b66ebd56770a14fd1a9864a7bae6245d124e1f4df8d8bdc292f8a03f0aa747db79eba16f5c47c39c9b075ca9d7c3e2d272709f3c2411510692956116f8fe3eadee667bbdefdbbe176c86a1f9a9f34d916f71f7cdb2709ad730ff54ea8d03a06397d945e04708d8269e88afcf4ab9c9d6fb8b467069ce02f11d4929bb70bca649fab7504e66a762c27725bd6435616db2d15e1a6106182dde2079100c4045e02ce0864f7a4fbae83ec1cab18ec7fa2bfd1f89cc8c";
			 
			        for (uint ip = 0; ip < 550; ip++) {
			            pub2[ip] = hexstring2byte(spub[2*ip], spub[2*ip+1]);
			        }
			 
			        for ( ip = 0; ip < 512; ip++) {
			 
			            sig2[ip] = hexstring2byte(ssig[2*ip], ssig[2*ip+1]);
			        }
			        return verify_sig_rsa(msg, pub2, sig2);
			    }
- base 64 编解码接口函数

	base64 编解码能力是平台提供的一套编解码规则，主要为验签函数提供签名，其使用示例如下所示
	
	- base64_encode
		- base64 编码函数
				 
				function test_base64_encode() returns (bool , string memroy)
				{
				    string memory name = "http://test_base64 ~!@#$%";
				    return base64_encode(name);
				} 
	- base64_decode
		- base64 解码函数。
		
				function test_base64_decode() returns (bool , string memroy)
				{
				    string memory name = "aHR0cDovL3Rlc3RfYmFzZTY0IH4hQCMkJQ==";
				    return base64_decode(name);
				}
- 平台接口函数

	蚂蚁区块链合约平台为合约开发者提供一些新的特性接口支持，包括对区块数据获取、交易数据获取、加密方法的支持。

	- 区块数据接口函数
		- block.blockhash(uint blockNumber) returns (bytes32)：传入 blockNumber，返回块的哈希值。
		- block.gaslimit (uint)：系统中的 gas 最大值。
		- block.number (uint)：最新已经形成的区块高度，注意不是当前正在形成的区块高度。
		- block.timestamp (uint)：最新已经形成的区块时间戳，注意不是当前正在形成的区块时间戳。
		- now (uint)：block.timestamp 的别名。
	- 交易数据接口函数
	
		以下方法介绍中，括号内是返回的结果数据类型，并不是传入参数。
	
		- msg.data (bytes)：用户的输入数据。
		- msg.gas (uint)：用户交易中的 gas 值。
		- msg.sender (identity)：用户交易中的发送方。
		- msg.sig (bytes4)：用户交易输入数据的前四字节。
		- msg.value (uint)：用户交易中的 gas 值。
	
	蚂蚁区块链合约平台还支持查询交易哈希，示例如下

		tx.txhash   (identity)
	可通过该方法获取当前交易的哈希值，类型为 identity
	
	- 加密(签名)接口函数

		蚂蚁区块链合约平台对 ecrecover 加密函数进行了修改，通过签名数据的哈希结果和签名获得公钥后，采用 sha256 加密函数对公钥进行加密，并将加密的结果作为 ID 返回给用户。
		
		- sha256 加密
			
			蚂蚁区块链合约平台对 sha256 加密函数进行了修改，采用 OpenSSL 加密库进行实现
			
			- 函数原型

					sha256(bytes data) returns(bytes32 result) ;
			- 参数
				- data(字节) 明文
			- 返回
				- result(字节) sha256 加密结果   
		- sha256 恢复
			- 函数原型

					ecrecover(bytes32 hash, uint8 v, bytes32 r,bytes s) returns(identity id) ; 
			- 参数
				- hash(字节32) 签名数据的哈希结果
				- v(uint8) 签名最后一字节
				- r(字节32)签名前 32 字节
				- s(字节32)签名后 32 字节
			- 返回
				- id(身份)账户id
	- md160
	
		在蚂蚁区块链合约平台中，不提供 ripemd160 加密函数库
- 事件和日志

	事件是以太坊虚拟机（Ethereum Virtual Machine，简称“EVM”）提供的一种日志基础设施。事件可以用来做操作记录，存储为日志。也可以用来实现一些交互功能，比如通知 UI，返回函数调用结果等。日志和事件机制是平台与终端用户连接的桥梁

	- 合约日志示例

		您可以通过日志和事件机制获得合约代码的执行情况。下面是一个简单的合约示例
		
			pragma solidity ^0.4.0;
			 
			contract ClientReceipt {
			    event Deposit(
			        identity indexed _from,
			        uint _id,
			        uint _value
			    );
			 
			    function deposit(uint _id) {
			        Deposit(msg.sender, _id, msg.value);   
			    }
			}
		在部署该合约之后，可以通过调用 `deposit(uint256)` 方法获得 log 事件输出。可使用 event 关键字定义一个事件，参数列表中为要记录的日志参数的名称及类型。合约输出结果如下所示

			from: 1122334455667788991011121314151347181920929293949596979812345678
			to: 10237462546362184738205736165f7391947195472655869214456471048395
			log_data:00000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000032
			topics：[90890809c654f11d6e72a28fa60149770a0d11ec6c92319d6ceb2bb0a4ea1a15
			1122334455667788991011121314151347181920929293949596979812345678]
		从以上示例中可以看到，日志输出主要包含 from、to、log_data、topics 属性。具体结构信息，参见合约日志结构。
		
		![](./pic/antchain89.png)
- 合约间调用函数

	蚂蚁区块链合约平台主要支持两种合约调用方式，分别为 
	
	- call

		call 类型的合约调用主要是通过调用其他合约代码获取某个方法的调用结果。同时，在执行该合约时，被调用合约的变量会被修改（即修改的是被调用合约的内存），调用执行成功时返回 true，失败则返回 false。如果被调用合约不存在，则返回执行调用合约的 fallback 函数。
		
		- 原型

				id.call(bytes4(keccak256(data), args)) returns (bool result)
		![](./pic/antchain90.png)
	- delegatecall
	
		delegatecall 类型的合约调用也是调用其他合约的方法，与 call 不同的是，delegatecall 修改的是合约调用方的内存。此方法的主要目的在于让合约能够在不传输自身状态（如 balance、storage）的情况下使用其他合约的代码。delegatecall 不支持传输 value。
		
		- 原型
		
				id.delegatecall(bytes4(keccak256(data), args)) returns (bool result)
		![](./pic/antchain91.png)
	- call 与 delegatecall 对比分析
		- 相同点
			- 调用时，call 与 delegatecall 均会将本合约所有可用的 gas 传输过去。
			- 执行失败时均返回 false。
		- 不同点
			- call 可以使用 .value 传 gas 给被调用合约。
			- 假设在 contract_test 合约中分别有 nameReg.call("somefunction") 以及 nameReg.delegatecall("somefunction")：
				- nameReg.call 以 nameReg 合约的身份在 nameReg 中执行 somefunction。
				- nameReg.delegatecall 以 contract_test 合约的身份在 nameReg 中执行 somefunction。
			- delegatecall 的目的就是让合约在不用传输自身状态（如 balance、storage）的情况下可以使用其他合约的代码。
- digest 函数

	digest 函数用来计算摘要，原 sha256() 函数废弃
	
	- 原型

			digest(bytes data, int type) returns(bool result, bytes32 data);
	![](./pic/antchain92.png)						
#### [应用例子](https://antchain.antgroup.com/docs/11/143718)
### [错误码](https://antchain.antgroup.com/docs/11/143756)
		 
			
				