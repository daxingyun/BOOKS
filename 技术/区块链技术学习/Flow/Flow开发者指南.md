# Flow 开发者指南-流程概念
## 概念
当我们谈论像 Flow 这样的系统、网络背后的技术以及您将用来与之交互的系统设计时，有很多内容需要涵盖。本节将帮助您发现有助于您更好地了解 Flow 的活动部件的信息。
### 技术背景
Flow [Technical Primer](https://www.onflow.org/primer) 是开始了解 Flow 工作原理的好地方。
Flow 团队发布了 3 份技术[白皮书](https://www.onflow.org/technical-paper)，深入介绍了 Flow 区块链网络背后的独特创新。
### 代币经济学
- 要了解有关 Flow 代币经济学和 FLOW 代币的更多信息，您可以阅读 [Flow 代币经济学指南](https://www.onflow.org/flow-token-economics)。
- FLOW 代币是 Flow 的原生 Fungible 代币。要了解有关如何在您的应用程序中使用它们的更多信息，请访问[此处](https://docs.onflow.org/flow-token)

### 更多概念
如果您是一名开发人员，希望更好地了解在您的应用程序中使用 Flow，请继续阅读来探索概念页面。

## 账户、密钥和签名
Flow 引入了新功能，为应用程序和最终用户在管理密钥、帐户和其中的资产时提供更多的安全性和灵活性。
### 帐户
Flow 上的一个账户是一个处于链状态的记录，它包含以下信息：

- 地址- 帐户的唯一标识符
- 余额- 默认代币余额
- 公钥- 在账户上授权的公钥
- 代码- 部署到账户的 Cadence 合约
- 存储- 用于存储资源资产的帐户区域

### 帐户创建
与比特币和以太坊不同，Flow 地址不是从加密公钥派生的。相反，每个 Flow 地址都由遵循确定性寻址序列的链上函数分配。

这种解耦允许多个公钥与一个账户相关联或者单个公钥可以跨多个账户使用。

用户必须提交账户创建交易才能创建新账户。这些交易的行为与任何其他交易一样，因此必须有付款人。

- 谁将支付创建我的帐户的费用？

	账户创建费用相对较低，我们预计当用户第一次将法定货币转换为加密货币时，钱包提供商和交易所将承担费用。

	从概念上讲，这与其他链没有太大不同。在比特币和以太坊上，可以离线保留帐户地址，但在有人向该地址提交（并支付）交易之前，该帐户对网络不可见。
- 账户创建交易是什么样的？

	以下是如何使用 Go SDK 提交账户创建交易的示例：账户创建[示例](https://github.com/onflow/flow-go-sdk/blob/master/examples/create_account/main.go)。
- 智能合约呢？

	以太坊区分了账户和合约，两者都是可寻址的。以太坊合约是不可变的，部署后无法升级。

	要在 Flow 中实现相同的目的，只需使用已部署的代码和授权密钥的空列表创建一个帐户。这使帐户无法授权会改变帐户代码的交易，从而使帐户不可变。

### 帐户地址
文档即将推出...
### 钥匙
Flow 帐户可以配置多个用于控制访问的公钥。关联私钥的所有者可以签署交易以改变帐户的状态。
#### 为账户添加密钥
向账户添加公钥时，您必须指定以下信息：

- ID（用于识别账户内的密钥）
- 原始公钥（编码为字节）
- 签名算法（见下面的代码）
- 哈希算法（见下面的代码）
- 重量（1-1000之间的整数）

包含签名算法是因为 Flow 有可能支持具有不同参数的各种签名方案。包含的散列算法指定用于验证签名的散列函数。
#### 如何将密钥添加到帐户？
要将密钥添加到帐户，您可以提交有权访问该帐户的交易。

以下是如何使用 Go SDK 添加帐户密钥的示例：

- [添加帐户密钥示例](https://github.com/onflow/flow-go-sdk/blob/master/examples/add_account_key/main.go)。

#### 从帐户中撤销密钥
功能和文档即将推出...
#### 支持的签名和哈希算法
Flow 将初步支持一组预定义的签名和哈希配对，但将来会添加更多曲线和算法。

- 签名算法

	算法|曲线|ID|代码
	---|---|---|---
	ECDSA|P-256|ECDSA_P256|2
	ECDSA|ecp256k1	|ECDSA_secp256k1|3

	ECDSA 算法通常使用两条曲线，secp256r1（OID 1.2.840.10045.3.1.7，也称为“NIST P-256.”曲线）和secp256k1（OID 1.3.132.0.10，“使用的曲线”比特币”）。请务必在注册密钥之前仔细检查您使用的参数，因为使用另一个代码和格式下的曲线显示密钥将产生错误。
- 哈希算法

	算法|输出尺寸|ID|代码
	---|---|---|---
	SHA-2|256|SHA2_256|1
	SHA-3|256|SHA3​​_256|3
- 兼容性表

||SHA2_256|SHA3​​_256
---|---|---|
ECDSA_P256|✅|✅
ECDSA_secp256k1|✅|✅

#### 加权键
每个帐户密钥都有一个权重，决定了它拥有的签名能力。除非交易的总签名权重大于或等于1000权重阈值，否则该交易无权访问帐户。

例如，一个帐户可能包含以下键：

- 密钥 ID：1，权重：500
- 密钥 ID：2，权重：500
- 密钥 ID：3，权重：500

这表示 2-of-3 多重签名法定人数，其中如果交易从 3 个密钥中的至少2 个收到签名，则它被授权访问该帐户。

## 签署交易
为 Flow 签署一笔交易是一个多步骤的过程，可能涉及一个或多个账户，每个账户签署的目的不同。
### 签名者角色
- 提议者：指定提议键的账户。
- 付款人：支付交易费用的账户。
- 授权人：零个或多个账户授权交易改变其状态。

### 提案密钥
每笔交易都必须声明一个提案密钥，该密钥可以是来自任何 Flow 账户的账户密钥。拥有提案密钥的帐户称为提案人。

提案密钥定义声明帐户密钥的地址、密钥 ID 和最新序列号。


	{
	  // 其他交易字段
	  // ...
	  "proposalKey": {
	    "address": "0x01",
	    "keyId": 7,
	    "sequenceNumber": 42
	  }
	}
### 序列号
Flow 使用序列号来确保每个事务最多运行一次。这可以防止许多不需要的情况，例如[事务重放攻击](https://en.wikipedia.org/wiki/Replay_attack)。

序列号的工作方式与以太坊中的交易随机数类似，但有几个关键区别：

- 帐户中的每个密钥都有一个与之关联的专用序列号。与以太坊不同的是，整个账户没有序列号。
- 创建交易时，只有提议者必须指定序列号。付款人和授权人不需要。

交易提议者只需要为单个帐户密钥指定一个序列号，即使它使用多个密钥签名。该密钥称为提议密钥。

每次将账户密钥用作提案密钥时，其序列号加 1。序列号在执行后更新，即使交易在执行期间失败（恢复）。

如果交易的提议密钥没有指定与执行时存储在帐户中的序列号相等的序列号，则该交易将被拒绝。

例子：下面的交易执行后，账户地址 `0x01` 的第7个 `Key` ，序号会增加到43。

	{
	  // other transaction fields
	  // ...
	  "proposalKey": {
	    "address": "0x01",
	    "keyId": 7,
	    "sequenceNumber": 42
	  },
	  "payer": "0x02",
	  "authorizers": [ "0x01" ],
	}
	
### 交易剖析
由于存在加权密钥和分裂签名角色，Flow 交易有时需要由一方或多方多次签名。也就是说，可能需要多个唯一签名来授权单个交易。

一个交易可以包含三层数据，第一层是有效载荷、第二层和第三层是两种类型的签名：有效载荷签名和信封签名。

![](pic/flow.png)

- 有效载荷

	交易有效负载是交易的最内部部分，包含唯一标识交易应用的操作的数据。在 Flow 中，具有相同负载的两个事务永远不会被执行多次。

	交易提议者和授权者只需要签署交易有效负载。这些签名是有效载荷签名。
- 授权信封签名

	交易授权信封包含交易的
	
	- 有效载荷
	- 有效载荷签名
	
	交易付款人需要在授权信封上签名。这些签名是信封签名。

	❗特殊情况：如果一个账户既是付款人又是提议人或授权人，则只需在信封上签名。
- 付款信封签名

	包含有效载荷和信封签名的交易的最外面部分被称为支付信封。

	- 付款人最后签字
	
		付款人必须签署包含有效载荷签名的交易部分，这意味着付款人必须始终最后签署。这允许付款人确保他们正在使用所有必需的有效负载签名签署有效的交易。

### 签名结构
交易签名是一个包含三个字段的复合结构：

- 地址
- 钥匙编号
- 签名数据

该地址和密钥 ID 字段声明生成的签名，这是为了验证对正确的公钥签名所需的帐户键。

### 签名场景
以下是需要不同签名组合来授权交易的几种场景。

- 单方单密钥签名

	最简单的 Flow 交易将单个帐户声明为提议者、付款者和授权者。在这种情况下，该帐户可以使用单个签名来签署交易。

	由于提案密钥必须始终具有有效签名，因此只有在提案密钥具有完整签名权重时才可能出现这种情况。

	帐户|钥匙编号|重量
	---|---|---
	0x01|1|1.0


		{
		  "payload": {
		    "proposalKey": {
		      "address": "0x01",
		      "keyId": 1,
		      "sequenceNumber": 42
		    },
		    "payer": "0x01",
		    "authorizers": [ "0x01" ]
		  },
		  "payloadSignatures": [], // 0x01 是付款者,所以仅需要在付款信封上签名
		  "envelopeSignatures": [
		    {
		      "address": "0x01",
		      "keyId": 1,
		      "sig": "0xabc123"
		    }
		  ]
		}
- 单方多密钥签名

	如果账户使用加权密钥来实现多重签名功能，那么声明单个账户作为提议者、付款人和授权人的交易仍然可以指定多个签名。

	帐户|钥匙编号|重量
	---|---|---
	0x01|1|0.5
	0x01|2|0.5

		{
		  "payload": {
		    "proposalKey": {
		      "address": "0x01",
		      "keyId": 1,
		      "sequenceNumber": 42
		    },
		    "payer": "0x01",
		    "authorizers": [ "0x01" ]
		  },
		  "payloadSignatures": [], // 0x01 是付款者,所以仅需要在付款信封上签名
		  "envelopeSignatures": [
		    {
		      "address": "0x01",
		      "keyId": 1,
		      "sig": "0xabc123"
		    },
		    {
		      "address": "0x01",
		      "keyId": 2,
		      "sig": "0xdef456"
		    }
		  ]
		}
- 多方，每方单签名

	为每个签名角色声明不同账户的交易将需要每个账户至少有一个签​​名。

	帐户|钥匙编号|重量
	---|---|---
	0x01|1|1.0
	0x02|1|1.0

		{
		  "payload": {
		    "proposalKey": {
		      "address": "0x01",
		      "keyId": 1,
		      "sequenceNumber": 42
		    },
		    "payer": "0x02",
		    "authorizers": [ "0x01" ]
		  },
		  "payloadSignatures": [
		    {
		      "address": "0x01", // 0x01 不是付款者, 所以需要在 payload 签名
		      "keyId": 1,
		      "sig": "0xabc123"
		    }
		  ],
		  "envelopeSignatures": [
		    {
		      "address": "0x02",
		      "keyId": 1,
		      "sig": "0xdef456"
		    },
		  ]
		}
- 多方、多方签名

	如果这些帐户使用加权密钥来实现多重签名功能，那么为每个签名角色声明不同帐户的交易可能需要每个帐户多个签名。

	帐户|钥匙编号|重量
	---|---|---
	0x01|1|0.5
	0x01|2|0.5
	0x02|1|0.5
	0x02|2|0.5

		{
		  "payload": {
		    "proposalKey": {
		      "address": "0x01",
		      "keyId": 1,
		      "sequenceNumber": 42
		    },
		    "payer": "0x02",
		    "authorizers": [ "0x01" ]
		  },
		  "payloadSignatures": [
		    {
		      "address": "0x01", // 0x01 不是付款者, 所以需要在 payload 签名
		      "keyId": 1,
		      "sig": "0xabc123"
		    },
		        {
		      "address": "0x01", // 0x01 不是付款者, 所以需要在 payload 签名
		      "keyId": 2,
		      "sig": "0x123abc"
		    }
		  ],
		  "envelopeSignatures": [
		    {
		      "address": "0x02",
		      "keyId": 1,
		      "sig": "0xdef456"
		    },
		    {
		      "address": "0x02",
		      "keyId": 2,
		      "sig": "0x456def"
		    },
		  ]
		}

## 在 Flow 上存储数据
### 概述
每个 Flow 帐户都有一个使用的关联存储。使用的帐户存储是帐户存储中存储的所有数据的字节大小。账户还具有存储容量，这与账户拥有的 Flow 代币数量直接相关。该帐户可以在不增加任何额外费用的情况下使用其存储容量内的任何存储量。如果交易会使帐户超出存储容量，则该交易将失败并被恢复。同样，如果交易将账户余额降至 0.001 Flow 代币以下，这是账户可以拥有的最小值，交易也会失败。
### 存储容量
帐户的存储容量取决于其拥有的 FLOW 数量。一个账户可以拥有的最小流量是 0.001。此最小值由帐户创建者在创建帐户时提供。最低账户预留确保大多数账户在有人向账户存入任何东西（如 NFT）时不会耗尽存储容量。

账户拥有的确切存储容量是账户拥有的 FLOW 数量乘以智能合约 `storageBytesPerReservedFlow` 上定义的变量 `StorageFees`，即：

- 每 1 个预留 FLOW 10 MB
- 每 0.1 个预留 FLOW 1 MB
- 每 0.01 保留 FLOW 100 kB
- 每 0.001 保留流量 10 kB

任何账户都可以通过向账户存入更多的 FLOW 来增加账户的存储容量

### 使用的存储空间
帐户存储中的所有数据均计入已使用的存储。即使新创建的帐户也不是空的。它的仓库中已经有一些物品：

- 标记帐户存在的元数据。
- 一个空的 FLOW 保险库，以及存储的接收器能力。
- 如果帐户是使用密钥创建的，则该密钥的公钥。
- 如果帐户是使用合约创建的，则在帐户上部署智能合约。
- 用作无符号整数的帐户存储值。

向帐户添加额外的密钥、智能合约、功能、资源等会计入所使用的存储空间。

### 存储参数
两个参数定义了存储限制：

- 最小账户流量为 0.001 FLOW，代表10 kB 的存储容量。这也是新账户的创建者需要为账户的存储预留提供的 FLOW 数量。( `StorageFees.minimumStorageReservation`)
- 一个 FLOW 代表的存储容量是每个 FLOW 10 MB。( `StorageFees.storageMegaBytesPerReservedFlow`)

### 常问问题
- 为什么有账户最低余额？

	Flow 上存储的数据越多，对需要存储数据的执行节点的存储要求就越高。随着数据规模的增长，执行节点越来越难以满足这些要求，成本也越来越高。存储费用已到位，以规范存储在 Flow 区块链上的数据的增长。
- 我当前的存储使用量是多少？

	已用存储和存储容量的值可用作 `AuthAccount` 和 `PublicAccount` Cadence 类型的字段。
	
		pub fun main(address: Address) {
		    let account = getAccount(address)
		    log(account.storageUsed)
		    log(account.storageCapacity)
		}
		
### 进一步阅读
可以在此处找到相关的 Cadence 更改：[https://docs.onflow.org/cadence/language/accounts#account-storage](https://docs.onflow.org/cadence/language/accounts#account-storage)

存储费用的FLIP（流量改进提案）可在此处找到：[20201310-storage-fees.md](https://github.com/onflow/flow/blob/master/flips/20201310-storage-fees.md)。		