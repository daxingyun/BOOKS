# Flow 开发者指南-Flow 
## Cadence 介绍 Flow 的智能合约语言
我们通常将存储在用户帐户中的程序称为智能合约。智能合约是一种无需可信第三方即可验证和执行合约的程序。在区块链上运行的程序通常被称为智能合约，因为它们可以调解重要的功能（例如货币）而无需依赖中央机构（例如银行）。
### 一种新的编程语言
Cadence 是一种面向资源的编程语言，它为智能合约编程引入了新功能，可帮助开发人员确保其代码安全、可靠、清晰且易于使用。其中一些功能是：

- 类型安全和强静态类型系统
- 面向资源的编程

	一种将线性类型与对象功能配对的新范式，通过确保资源（及其相关资产）一次只能存在于一个位置，不能被复制，从而为数字所有权创建安全的声明性模型，以及不能意外丢失或删除
- 功能和事务的内置前置条件和后置条件
- 利用基于能力的安全性

	通过要求对对象的访问仅限于所有者和对对象具有有效引用的人来强制执行访问控制
Swift 和 Rust 启发了 Cadence 的语法。它对资源类型的使用很好地映射到了由 Libra 团队开发的编程语言 Move。

### Cadence 的编程语言支柱
Cadence 是一种新的高级编程语言，遵循以下要求：

- 安全和保障

	安全是任何智能合约的基本可靠性（即，它没有错误并执行其功能）。安全是防止对网络或智能合约的攻击（即恶意行为者未经授权的行为）。由于区块链的不可变性质，并且因为它们经常处理高价值资产，安全和保障在智能合约中至关重要。虽然审计和审查代码将是智能合约开发的关键部分，但 Cadence 可以最大限度地提高效率，同时在其基础上保持最高水平的安全和保障。它通过强大的静态类型系统、契约设计和受线性类型启发的所有权原语（在处理资产时很有用）来实现这一点。
- 清晰

	代码需要易于阅读，其含义应尽可能明确。它还应该适用于验证，以便工具可以帮助确保安全和保障。这些保证可以通过使代码具有声明性并允许开发人员直接表达他们的意图来实现。我们通过设计使这些意图明确，这与可读性一起，使审计和审查更有效，而冗长的代价很小。
- 平易近人

	编写代码和创建程序应该尽可能平易近人。结合 Swift 和 Rust 等语言的特性，开发人员应该会发现 Cadence 的语法和语义很熟悉。实用的工具、文档和示例使开发人员能够快速有效地开始创建程序。
- 开发者体验

	开发者应该在整个开发生命周期中得到支持，从最初的应用逻辑到链上错误修复。
- 直观的资源所有权

	资源是一种复合数据类型，类似于结构，表示资产的直接所有权。Cadence 强大的静态类型系统确保资源一次只能存在于一个位置，并且不会因为编码错误而被复制或丢失。大多数智能合约语言目前使用分类账式方法来记录所有权，其中像可替代代币这样的资产作为中央分类账的条目存储在智能合约中。Cadence 的资源直接将资产的所有权与帐户联系起来通过将资源保存在帐户的存储中来拥有它。因此，所有权并不集中在智能合约的存储中。每个账户拥有自己的资产，资产可以在账户之间自由转移，无需通过中央智能合约进行仲裁。

### 用现有语言应对挑战
其他语言率先开发了智能合约，但它们在影响下一代应用程序长期可行性的领域有所欠缺。
### 安全(Safety)
安全性是智能合约按预期执行其功能的可靠性。它受到智能合约不可更改的一次部署性质的严重影响：开发人员必须在发布智能合约之前避免引入任何潜在的灾难性弱点。例如，在 2016 年，DAO 代码中一个被忽视的漏洞从智能合约中窃取了数百万美元，最终导致以太坊和两个独立的活跃区块链（以太坊和以太坊经典）分叉。

仅当智能合约旨在支持更改时才能修复错误，该功能会引入复杂性和安全问题。冗长的审计和审查过程可以确保无错误的智能合约。尽管如此，它们仍然为让智能合约的核心逻辑正常工作已经很耗时的任务增加了大量时间。

被忽视的错误会导致最具破坏性的情况。很容易丢失或复制货币价值或资产，因为现有语言不会检查相关的不变量或使其更难表达。例如，一个普通数字代表可能被意外（或恶意）乘以或忽略的转移金额。

一些语言还表达了开发人员往往会忘记的行为。例如，固定范围类型可能表示货币价值，而不考虑潜在的上溢或下溢。在密实度，溢出导致值环绕，如[这里](https://ethfiddle.com/CAp-kQrDUP)。Solidity 还允许合约在不初始化变量的情况下声明变量。如果开发人员忘记在某处添加初始化，然后尝试读取代码中其他地方的变量，期望它是特定值，则会出现问题。

Cadence 是类型安全的，并具有强大的静态类型系统，可防止在编译时（即在程序在链上运行之前）出现重要的错误或不良程序行为类。静态检查类型并且不会隐式转换。Cadence 还通过防止算术下溢和溢出来提高程序的安全性，引入了可选项使 nil 情况显式，并且始终要求初始化变量。这有助于确保这些智能合约的行为是显而易见的，而不依赖于上下文。
### 安全(Security)
Security与Safety相结合，通过防止未经批准的访问并保证只有经过授权的操作才能在协议中执行，从而确保智能合约随着时间的推移成功执行。在某些语言中，默认情况下函数是公开的，从而产生允许恶意用户找到攻击媒介的漏洞。Cadence 利用基于功能的安全性，允许类型系统根据用户和开发人员可以控制的规则强制执行访问控制。

与其他智能合约交互时，安全性是一个考虑因素。任何外部调用都可能允许执行恶意代码。例如，在 Solidity 中，当被调用的函数签名与任何可用的签名都不匹配时，它会触发 Solidity 的回退函数。这些功能可以以恶意方式使用。多继承和重载或分派等语言特性也可能导致难以确定调用了哪些代码。

在 Cadence 中，按合同设计和所有权原语增强了程序的安全性。 契约式设计允许开发人员以声明的方式声明函数和接口的前置条件和后置条件，以便调用者可以确定被调用代码的行为。所有权原语受到线性类型的启发，并在处理资产时提高了安全性。例如，它们可确保贵重资产不会意外或恶意丢失或复制。
### 清晰易懂
隐式性、上下文依赖性和表达性是开发人员经常遇到的基于语言的挑战。它们影响语言和使用它构建的程序的清晰度（即代码的可读性和确定其预期功能的能力）和易接近性（即解释或编写代码的能力）。例如，在 Solidity 中，存储必须以低级的 key-value 方式实现，这混淆了开发人员的意图。语法混淆是另一个例子，“=+”是导致赋值而不是可能预期的增量的合法语法。Solidity 还具有可能导致意外结果的不常见行为的特征。 [多重继承可能导致程序出现意外行为](https://medium.com/consensys-diligence/a-case-against-inheritance-in-smart-contracts-d7f2c738f78e)，并且测试和审计代码不太可能发现这个问题。以太坊区块链的代码不变性表明需要考虑可扩展性和允许临时修复的机制。

Trail of Bits 详细介绍了以太坊当前的升级策略及其问题：使用“数据分离”方法进行升级的开发人员可能会遇到数据结构复杂性的问题，而使用“基于委托调用的代理”的开发人员可能会遇到一致性问题内存布局。无论哪种方式，这些挑战都会损害可接近性和整体可扩展性。

Cadence 通过利用接口来实现合同之间的可扩展性、代码重用和互操作性，从而提高了程序的清晰度和可扩展性。Cadence 模块还具有内置的可配置和透明的可升级性，使项目能够在使其代码不可变之前进行测试和迭代。

Cadence 允许使用参数标签来描述函数参数的含义。它还提供了一个丰富的标准库，其中包含适用于常见用例的有用数据结构（例如，字典、集合）和数据类型，例如定点算术，这有助于处理货币。
### 直观的资源所有权
大多数智能合约语言目前使用分类账式方法来记录所有权，其中资产作为中央分类账的条目存储在智能合约中，而该分类账是围绕资产所有权的真实来源。这种设计有很多缺点，尤其是在跟踪属于单个帐户的多个资产的所有权时。要找出一个账户拥有的所有资产，您必须枚举可能包含该账户的所有可能的智能合约，并搜索该账户是否拥有这些资产。

在像 Cadence 公司面向资源的语言，资源直接联系起来的一种资产账户，通过储蓄账户中的存储资源的拥有它。因此，所有权并不集中在单个中央智能合约的存储中。相反，每个账户拥有并存储自己的资产，资产可以在账户之间自由转移，无需通过中央智能合约进行仲裁。

资源受到线性类型的启发，并在使用资产时提高安全性，这些资产通常具有真实的内在价值。资源，由 Cadence 的类型系统强制执行，确保资产被正确操作而不是被滥用。

- 每个资源都只有一个所有者。如果资源用作函数参数、变量的初始值或类似的东西，则不会复制该对象。相反，它被移动到新位置，旧位置立即失效。
- 如果资源的所有权未正确转移，即当程序尝试为资源引入多个所有者或资源最终处于没有所有者的状态时，该语言将报告错误。例如，一个资源只能分配给一个变量，不能多次传递给函数。
- 资源不能超出范围。如果一个函数或交易从一个账户的存储中删除了一个资源，它要么需要在账户的存储中结束该交易，要么需要明确且安全地删除它。资源没有“垃圾收集”。

Resource 对象的特殊状态必须由运行时强制执行；如果它们只是一个编译器抽象，恶意代码很容易破坏价值保证。

资源改变了资产在编程环境中的使用方式，以更好地模拟现实世界中的资产。用户将他们的货币和资产存储在他们自己的账户中，在他们自己的钱包存储中，他们可以随心所欲地使用它们。用户可以为资源定义自定义逻辑和结构，从而灵活地存储资源。此外，由于每个人都存储自己的资产，因此状态租金的计算和收取在网络中的所有用户之间是公平和平衡的。

### 一种口译语言
目前，Cadence 是一种解释型语言，而不是编译型语言。这意味着没有 Cadence 程序集、字节码、编译器或 Cadence VM。

语言的结构非常适合编译（例如，静态类型），但是在第一个版本中使用解释器可以让我们在定义语言特性时更快地改进它们。

## Flow 设计模式
这是核心 Flow 开发人员在编写 Cadence 代码以部署到 Flow Mainnet 时开发的软件设计模式的选择。

[设计模式](https://en.wikipedia.org/wiki/Software_design_pattern)是软件开发的构建块。它们可能会为您在 Cadence 中编写智能合约时遇到的问题提供解决方案。请记住，如果它们确实适合，对于给定情况，它们可能不是正确的解决方案，并且即使在更好的解决方案代表自己的情况下，它们也不意味着要完全遵循一组处方。

### 能力接收器
- 问题

	一个账户必须被赋予对另一个账户中的资源或合约的[能力](https://docs.onflow.org/cadence/language/capability-based-access-control/)，但不能轻易产生由两个账户授权的单个交易。这可以防止单个事务从一个帐户获取功能并将其交付给另一个帐户。
- 解决方案
	
	账户 B 创建一个可以接收能力的资源并将其存储在他们的 `/storage/` 区域中。然后在他们的 `/public/` 区域中公开一个 `Capability`，该功能可以接收所需的 `Capability` 并将其存储在资源中以备后用。

	账户 A 从 B 的 `/public/` 区域获取接收者能力，创建所需的能力，并将其传递给接收者函数。接收者函数将能力存储在它位于账户 B 的 `/storage/` 区域中的资源中，以备后用。

	此工作流程有两个细微差别，需要确保其安全。

	- 第一个
	
		只有账户 A 应该能够创建所需能力的实例。这确保没有其他人可以创建它的实例并在 B 的接收器功能上调用接收器函数而不是 A。这意味着 A 可能是管理员帐户。
	- 第二个
	
		接收器资源上存储所需能力的字段应该是 `access(contract)` 并且只能由需要的合同中的代码访问。这确保 B 不能复制和与其他任何人共享能力。
- 示例代码
	- [LockedTokens.cdc](https://github.com/onflow/flow-core-contracts/blob/bfb115869bd9f815cde1fe64ab6d91ca95c0938e/contracts/LockedTokens.cdc#L527)
	- [Guardian_setup_account_creator.cdc](https://github.com/onflow/flow-core-contracts/blob/79941fe65b634800065a440ae5243744b2ca8a2f/transactions/lockedTokens/admin/custody_setup_account_creator.cdc)
	- [admin_deposit_account_creator.cdc](https://github.com/onflow/flow-core-contracts/blob/79941fe65b634800065a440ae5243744b2ca8a2f/transactions/lockedTokens/admin/admin_deposit_account_creator.cdc)

### 能力撤销
- 问题

	一个账户向第二个账户提供的能力必须能够被第一个账户撤销，而无需第二个账户的合作
- 解决方案
	- 创建能力
		- 第一个帐户应创建功能作为指向 `/private/` 中功能的链接
		- 然后链接到 `/storage/` 中的资源
		- 然后将第一个链接传递给第二个帐户,作为他们使用的功能。这可以存储在他们的私人存储或能力接收器中。
			- Account1 ： `/private/capability →/storage/resource`
			- Account2： `Capability Receiver(Capability(→Account 1: /private/capability))`
	- 撤销能力
		- 如果第一个帐户要撤销对存储中资源的访问权限，则应删除 `/private/` 第二个帐户的能力所指的链接。能力使用路径而不是资源标识符，所以这会破坏能力。
		- 一旦能力被撤销，第一个账户应该注意不要在其私有存储的相同位置创建另一个链接，否则这将恢复第二个账户的能力。

### 初始化单例
- 问题

	必须创建管理资源并将其交付给指定的帐户。不应该有执行此操作的功能，因为这将允许任何人创建管理资源。
- 解决方案

	在合约的 `init()` 函数中创建任何一次性资源，并将它们传送到指定为参数的地址或 `AuthAccount`。

	在 LockedTokens 合约 init 函数中查看这是如何完成的

	[LockedTokens.cdc](https://github.com/onflow/flow-core-contracts/blob/master/contracts/LockedTokens.cdc#L583)

	并在用于部署它的事务中：

	[admin_deploy_contract.cdc](https://github.com/onflow/flow-core-contracts/blob/master/transactions/lockedTokens/admin/admin_deploy_contract.cdc)

### 命名值字段
- 问题

	您的合同、资源和脚本都必须引用相同的值。一个数字，一个字符串，一个存储路径。在事务和脚本中手动输入这些值是潜在的错误来源。参见：[https : //en.wikipedia.org/wiki/Magic number](https://en.wikipedia.org/wiki/Magic_number_(programming))（编程）
- 解决方案

	向负责该值的合约添加一个 `access(all)` 字段，例如一个 `Path`，并将其设置在合约的初始值设定项中。然后通过此公共字段引用该值，而不是手动指定它。
- [示例代码](https://github.com/onflow/flow-core-contracts/blob/master/contracts/LockedTokens.cdc#L583)

### 脚本可访问的公共字段
- 问题

	你的合约、资源或结构有一个需要在链外读取和使用的字段，通常是批量的。
- 解决方案

	确保可以从脚本（使用 `Account`）而不是需要事务（使用 `AuthAccount`）访问该字段。这节省了必须使用事务读取属性所需的时间和费用。制作该字段 `access(all)` 并通过 `/public/` 功能将其公开将允许这样做。这样做时请注意不要暴露任何应该保密的数据或功能。

### 脚本可访问报告
- 问题

	您的合约、资源或结构具有您希望通过脚本访问链外字段的资源。但是脚本不能返回资源。
- 解决方案

	声明一个结构来保存您希望从脚本返回的数据。编写一个函数，用您希望访问的资源中的数据填充此结构的字段。然后在您希望访问脚本中的字段的资源上调用它，并从脚本中返回结构。

	有关如何最好地公开此功能，请参阅上面的 [Script-Accessible Public Field](https://docs.onflow.org/cadence/design-patterns/#script-accessible-public-field)。
- 示例代码

		pub contract AContract {
		    pub struct BReportStruct {
		        pub var c: UInt64
		        pub var d: string
		
		        init(c: UInt64, d: string) {
		            self.c = c
		            self.d = d
		        }
		
		    }
		
		    pub resource BResource {
		        pub var c: UInt64
		        pub var d: string
		
		        pub fun generateReport() BReportStruct {
		            return BReportStruct(c: c, d: d)
		        }
		
		        init(c: UInt64, d: string) {
		            self.c = c
		            self.d = d
		        }
		    }
		}
		...
		import A from 0xA
		
		pub fun main(): A.BReport {
		    let b: AContract.BResource // Borrow the resource
		    let report = b.generateReport()
		    return b
		}

## Flow 反模式
这是一个自以为是的问题列表，如果在用于生产的 Cadence 代码中发现它们可以改进。
### 安全性和稳健性(来自资源的事件可能不是唯一的)
创建资源的合约上的公共函数可以被任何账户调用。

如果该资源具有发出事件的函数，则任何帐户都可以创建该资源的实例并发出这些事件。

如果这些事件旨在指示使用该资源的单个实例（例如管理对象、交换机或注册表）或通过特定工作流创建的实例所采取的操作，那么这将使事件日志搜索和管理更加困难，因为来自其他实例可能与您希望检查的实例混合在一起。

为了解决这个问题，如果应该只有一个资源实例，则应该 `link()` 在合约初始化期间创建它并编辑到管理员帐户存储中的公共路径。
### 命名值字段是首选
在合同、资源和脚本都必须重复引用相同的常量值的情况下，手动输入这些是潜在的错误来源。这些被称为[魔法值](https://en.wikipedia.org/wiki/Magic_number_(programming))。

不是在函数、交易和脚本中手动输入值，而是将值存储在负责合约的字段中，然后通过这些字段访问它们。这是命名值字段模式
### 应避免使用公共函数和字段
在构建代码时一定要跟踪访问修饰符，并且只公开应该公开的内容。
### 数组或字典字段应该是私有的
- 问题

	这是上面“应避免使用公共功能和字段”的一个具体案例。

	公共数组或字典字段不能直接覆盖，但如果字段是公共的，则可以访问和覆盖它们的成员。如果这些字段被错误地公开，这可能会导致合约的安全漏洞。

		pub contract Array {
		    // array is inteded to be initialized to something constant
		    pub let shouldBeConstantArray: [Int]
		}
	任何人都可以使用这样的交易来修改它：

		import Array from 0x01
		
		transaction {
		    execute {
				    Array.shouldbeConstantArray[0] = 1000
		    }
		}
- 解决方案

	确保合同、结构或资源中的任何数组或字典字段是 `access(contract)` 或` access(self)`除非它们需要有意公开。

		pub contract Array {
		    //数组在初始化为常量
		    access(self) let shouldBeConstantArray: [Int]
		}

### 公共管理资源创建功能不安全
这是上面“应避免使用公共功能和字段”的一个具体案例。

创建资源的合约上的公共函数可以被任何账户调用。

如果该资源提供对管理功能的访问，则该功能不应是公开的。

为了解决这个问题，使用它创建的该资源的单个实例然后  `link()` 在合约初始化期间编辑到管理员帐户存储中的私有路径。如果创建资源的代码足够复杂，需要自己的函数，则创建资源的函数应用 `access(contract)` 作其访问修饰符。
### 公共能力领域是一个安全漏洞
这是上面“应避免使用公共功能和字段”的一个具体案例。

可以复制公共字段的值。能力是值类型。任何获得能力的人都可以使用它。因此，如果他们可以从公共字段复制它，他们就可以调用它公开的函数。

如果以这种方式存储功能，这几乎肯定不是您想要的。要公开访问某个功能，请将其放置在帐户公共区域中。
### 用户可能会重新绑定受限公共能力路径
用户帐户上的公共功能是标准资源（例如 Vault）的变体，该功能实施了额外的逻辑来限制或改变其行为，可以由该用户在同一路径上替换为另一个没有这些功能的资源改动。

要解决此问题，请确保在访问它的任何代码中仔细指定您期望的功能类型。
## 可读性
### 描述性名称是首选
- `account/accounts` 比 `array/element` 好
- `providerAccount/tokenRecipientAccount` 比 `acct1/acct2` 好

当然，除非您正在处理真正以这种方式命名的实体，例如在实用程序代码中。

### 最好在约束中省略“任何”类型
不想 `&{Receiver}` 给 `&AnyResource{Receiver}`。

它更清晰，而且 `Any...` 是隐含的。

请注意，这并不意味着应始终发出受限类型，仅当它是特定的 `AnyStruct` 或 `AnyResource`.

代码何时应指定受限制类型的一个很好的例子是检查 FLOW 余额：代码必须借用 `&FlowToken.Vault{FungibleToken.Balance}`，以确保它获得 FLOW 代币余额，而不仅仅是 `&{FungibleToken.Balance}` 任何余额——用户可以存储另一个对象符合余额接口并返回任何值作为金额。
### 数组和映射的复数名称是首选
例如，`accounts` 而不是 `account` 用于一系列帐户。

这表示该字段或变量不是标量。它还使迭代期间变量名称的单数形式更容易。

## msg․发件人认为有害
每个 Solidity 用户在开始使用 Cadence 编程时都会问的一个问题是 “我如何检查 `msg.sender`？”。在以太坊上，检查 `msg.sender` 用于识别调用函数的帐户并适当地修改该函数的行为。这样做是以太坊身份、权限、所有权和安全性的关键。

Cadence 没有 `msg.sender` 也没有交易级别的方式让 Cadence 代码唯一标识其调用者，尤其是因为每笔交易都可以由多个帐户签名。这随后转化为可以访问所有签名者帐户的交易。与以太坊的另一个区别是，虽然以太坊和 Flow 都有可以包含合约代码和数据的账户，但在 Cadence 中，个人用户拥有的资源（如 NFT）被放置在用户账户的存储区域而不是合约账户的存储区域中。

所有这一切都意味着，由msg.senderSolidity 中的单个中央合同检查来实现的任务将需要在 Cadence 中采用不同的方法。Cadence 的设计有所不同，它遵循基于能力的安全模型，而不是基于访问控制列表的模型。我们相信这种设计为代码的健壮性和安全性提供了明显的优势。本文描述了如何以惯用的方式执行一些常见任务，以利用这些优势，还描述了一些处理应避免的相同任务的方法。

图案
管理员权限
管理设施应包含在管理资源中。这可以是具有通过不同接口提供的功能的单个资源，以向不同角色公开不同的功能，也可以是每个角色的不同资源。

这在 Patterns 文档中描述：

https://docs.onflow.org/cadence/design-patterns#init-singleton

一个很好的例子是铸造代币：

https://github.com/onflow/kitty-items/KittyItems.cdc

在必须将管理功能的访问权限授予多个不同帐户和/或可撤销的情况下，能力接收器模式支持这一点。

这在 Patterns 文档中描述：

https://docs.onflow.org/cadence/design-patterns#capability-receiver

https://docs.onflow.org/cadence/design-patterns#capability-revocation

允许/阻止列表
限制用户对他们拥有的资源的控制，除非在特殊情况下被认为是非 Flow-like。如果您必须为合规性实施允许/阻止帐户列表，请通过access(contract)其合同上的代码路由来自您资源中的函数的调用，该代码检查包含检查允许或阻止帐户所需信息的管理员控制字典。

此代码可以检查资源所有者，但这样做是一种反模式（见下文），不应使用，因为它不能被依赖。最好使用对象的uuid：

https://docs.onflow.org/cadence/language/composite-types/#resource-identifier

例如：【即将推出】

需要注意的是，uuid 不标识所有者，资源可以转移到不同的所有者，并移动到同一用户存储内的不同路径或替换为同一路径上的不同资源。

操作员/津贴
应通过私有功能实现为另一个用户提供对资源的临时部分控制权。

直接能力
可以通过以下方式限制对正确资源的访问：（例如）创建一个仅包含配额的新 Vault，或创建一个仅包含其他用户是操作员的 NFT 的新集合。

可以通过向其他用户提供受限于所需界面的能力来限制对正确功能的访问。

可以在需要时撤销该能力以移除该能力。

可撤销功能在 Patterns 文档中描述：

https://docs.onflow.org/cadence/design-patterns#capability-revocation

它们在教程中进行了讨论：

https://docs.onflow.org/cadence/tutorial/02-hello-world#creating-capabilities-and-references-to-stored-resources

包装能力
或者，原始资源（Vault、Collection 等）上的功能可以包装在强制执行所有这些限制的资源中，然后将此（或最好是它的功能）传递给其他用户。

例如，请参阅 KittyItemsMarket 对 NonFungibleToken.Provider 的谨慎限制使用：

https://github.com/onflow/kitty-items/cadence/contracts/KittyItemsMarket.cdc

所有权
如果帐户的存储包含资源（例如 NFT、NFT 集合或 FT 保管库），则该帐户拥有它。无需在其他任何地方记录此内容。它可以通过公共功能进行检查。如果用户删除公共功能，那是他们的选择。

例如，NFT 标准中的 Collection 资源、其接口以及放置在用户存储中的功能：

https://github.com/onflow/flow-nft/contracts/ExampleNFT.cdc

托管 NFT 市场拥有资源的临时所有权。他们应该能够识别代币的原始所有者，并在未售出时将其退还给他们。

例如：【即将推出】

用户档案
用户配置文件可以作为放置在用户帐户存储中的资源来实现，并通过公共功能进行读取访问。

在适当的情况下，可以使用私有功能、access(contract)代码或使用合同中只能create由管理员将其作为函数参数的类型来实现对用户配置文件的管理员控制。

例如：【即将推出】

反模式
检查 Contract.account
合约具有成员变量let account: Account，即部署合约的帐户：

https://docs.onflow.org/cadence/language/contracts/

这在替换 中的用途有限msg.sender，因为它本质上是 Flow 上的同义反复，因为合约被部署到您部署它们的帐户。

检查 Resource.owner
存储中的资源（但不是那些位于内存中的资源，例如，当资源刚刚创建时）具有隐式字段let owner: PublicAccount?：

https://docs.onflow.org/cadence/language/composite-types/#resource-owner

这可以通过使用新创建的资源来解决，因为所有者将为零。

将 AuthAccount 传入合约代码
您永远不应要求用户出于任何原因将 AuthAccount 传递到您的合同代码中。这包括用于身份验证目的。

AuthAccounts 提供对用户帐户的无限制访问，包括对帐户公钥及其所有存储的完全访问。这可以在交易中受到限制，但很难推断何时传递到合约代码中。

唯一的例外是您将自己的合约部署到您控制的帐户并希望将资源存入单独的帐户。在这种情况下，您可以将 AuthAccount 传递给初始化程序。但这引入了一个协调问题，因为您必须从两个帐户中获取签名。将资源存入合约的存储并使用单独的事务将其移动到另一个帐户，或者能力接收者模式，都同样有效：

https://docs.onflow.org/cadence/design-patterns#capability-receiver